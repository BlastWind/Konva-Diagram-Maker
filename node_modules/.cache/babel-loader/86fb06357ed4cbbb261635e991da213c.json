{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _classCallCheck from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\src\\\\App.js\";\n//todo: allow for picture inside of rect/ellipse/stfar\n//todo: connect using arrow\n//todo: for rightToolBar, show fontSize,fontFamily for text for the rest allow to add pictures\n//todo: zoomable\nimport React, { Component } from \"react\";\nimport { Stage, Layer, Rect, Transformer, Ellipse, Star, Text, Arrow } from \"react-konva\";\nimport Connector from \"./Connector.jsx\";\nimport Toolbar from \"./Toolbar.js\";\nimport \"./Graphics.css\";\n\nvar TransformerComponent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(TransformerComponent, _React$Component);\n\n  function TransformerComponent() {\n    _classCallCheck(this, TransformerComponent);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TransformerComponent).apply(this, arguments));\n  }\n\n  _createClass(TransformerComponent, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.checkNode();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.checkNode();\n    }\n  }, {\n    key: \"checkNode\",\n    value: function checkNode() {\n      var stage = this.transformer.getStage();\n      var selectedShapeName = this.props.selectedShapeName;\n\n      if (selectedShapeName === \"\") {\n        this.transformer.detach();\n        return;\n      }\n\n      var selectedNode = stage.findOne(\".\" + selectedShapeName);\n\n      if (selectedNode === this.transformer.node()) {\n        return;\n      }\n\n      if (selectedNode) {\n        this.transformer.attachTo(selectedNode);\n      } else {\n        this.transformer.detach();\n      }\n\n      this.transformer.getLayer().batchDraw();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n\n      if (this.props.selectedShapeName.includes(\"text\")) {\n        var stuff = React.createElement(Transformer, {\n          ref: function ref(node) {\n            _this.transformer = node;\n          },\n          name: \"transformer\",\n          boundBoxFunc: function boundBoxFunc(oldBox, newBox) {\n            newBox.width = Math.max(30, newBox.width);\n            return newBox;\n          },\n          enabledAnchors: [\"middle-left\", \"middle-right\"],\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 52\n          },\n          __self: this\n        });\n      } else if (this.props.selectedShapeName.includes(\"star\")) {\n        var stuff = React.createElement(Transformer, {\n          ref: function ref(node) {\n            _this.transformer = node;\n          },\n          name: \"transformer\",\n          enabledAnchors: [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"],\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 66\n          },\n          __self: this\n        });\n      } else if (this.props.selectedShapeName.includes(\"arrow\")) {\n        var stuff = React.createElement(Transformer, {\n          ref: function ref(node) {\n            _this.transformer = node;\n          },\n          name: \"transformer\",\n          resizeEnabled: false,\n          rotateEnabled: false,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 81\n          },\n          __self: this\n        });\n      } else {\n        var stuff = React.createElement(Transformer, {\n          ref: function ref(node) {\n            _this.transformer = node;\n          },\n          name: \"transformer\",\n          keepRatio: true,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 92\n          },\n          __self: this\n        });\n      }\n\n      return stuff;\n    }\n  }]);\n\n  return TransformerComponent;\n}(React.Component);\n\nvar history = [];\nvar historyStep = 0;\n\nvar Graphics =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Graphics, _Component);\n\n  function Graphics(props) {\n    var _this2;\n\n    _classCallCheck(this, Graphics);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Graphics).call(this, props));\n\n    _this2.handleSave = function () {\n      var rects = _this2.state.rectangles,\n          ellipses = _this2.state.ellipses,\n          stars = _this2.state.stars,\n          texts = _this2.state.texts,\n          arrows = _this2.state.arrows;\n\n      if (JSON.stringify(_this2.state.saved) !== JSON.stringify([rects, ellipses, stars, texts, arrows])) {\n        _this2.setState({\n          saved: [rects, ellipses, stars, texts, arrows]\n        });\n\n        var arrows1 = _this2.state.arrows;\n        arrows1.forEach(function (eachArrow) {\n          //for \"from & to of each arrow\"\n          if (eachArrow.from && eachArrow.from.attrs) {\n            if (eachArrow.from.attrs.name.includes(\"text\")) {\n              eachArrow.from.textWidth = eachArrow.from.textWidth;\n              eachArrow.from.textHeight = eachArrow.from.textHeight;\n            }\n          }\n\n          if (eachArrow.to && eachArrow.to.attrs) {\n            if (eachArrow.to.attrs.name.includes(\"text\")) {\n              eachArrow.to.attrs.textWidth = eachArrow.to.textWidth;\n              eachArrow.to.attrs.textHeight = eachArrow.to.textHeight;\n            }\n          }\n        });\n\n        if (_this2.state.roadmapId) {\n          //if draft already exists\n          _this2.setState({\n            saving: true\n          });\n\n          fetch(\"/api/roadmap/modifyDraftDB\", {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n              roadmapId: _this2.state.roadmapId,\n              data: {\n                rects: rects,\n                ellipses: ellipses,\n                stars: stars,\n                texts: texts,\n                arrows: arrows1\n              }\n            })\n          }).then(function (res) {\n            _this2.setState({\n              saving: false\n            });\n          });\n        } else {\n          //if first time pressing sav\n          _this2.setState({\n            saving: true\n          });\n\n          fetch(\"/api/roadmap/saveRoadmapToDB\", {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n              userId: _this2.props.auth.user.id,\n              roadmapType: \"draft\",\n              data: {\n                rects: rects,\n                ellipses: ellipses,\n                stars: stars,\n                texts: texts,\n                arrows: arrows\n              }\n            })\n          }).then(function (res) {\n            return res.json().then(function (data) {\n              _this2.setState({\n                saving: false\n              });\n\n              _this2.setState({\n                roadmapId: data.roadmapId\n              });\n            });\n          });\n        }\n      }\n    };\n\n    _this2.handleStageClick = function (e) {\n      var pos = _this2.refs.layer2.getStage().getPointerPosition();\n\n      var shape = _this2.refs.layer2.getIntersection(pos);\n\n      console.log(\"texts\", _this2.state.texts);\n\n      if (shape !== null && shape.name() !== undefined && shape !== undefined && shape.name() !== undefined) {\n        _this2.setState({\n          selectedShapeName: shape.name()\n        }, function () {\n          _this2.refs.graphicStage.draw();\n        });\n      } //arrow logic\n\n\n      if (_this2.state.newArrowRef !== \"\") {\n        if (_this2.state.previousShape) {\n          if (_this2.state.previousShape.attrs.id !== \"ContainerRect\") {\n            //console.log(this.refs.graphicStage.findOne(\".\" + this.state.newArrowRef));\n            //\n            _this2.state.arrows.map(function (eachArrow) {\n              if (eachArrow.name === _this2.state.newArrowRef) {\n                eachArrow.to = _this2.state.previousShape;\n              }\n            }); //console.log(newConnector, this.state.newArrowRef);\n            //newConnector.setAttr(\"to\", this.state.previousShape);\n            //console.log(newConnector);\n\n          }\n        } //handle connector more\n        //if the currentArrow ref has a from, and that e.target.attrs.id isn't containerRect,\n        //then find the current shape with stage find name and then yeah\n\n\n        _this2.state.arrows.map(function (eachArrow) {\n          if (eachArrow.name === _this2.state.newArrowRef) {\n            eachArrow.fill = \"black\";\n            eachArrow.stroke = \"black\";\n          }\n        }); //arrow logic, there's e.evt.pageX, pageY\n\n\n        _this2.setState({\n          arrowDraggable: false,\n          newArrowRef: \"\"\n        });\n      }\n    };\n\n    _this2.handleMouseOver = function (event) {\n      //get the currennt arrow ref and modify its position by filtering & pushing again\n      //console.log(\"lastFill: \", this.state.lastFill);\n      var pos = _this2.refs.graphicStage.getPointerPosition();\n\n      var shape = _this2.refs.graphicStage.getIntersection(pos);\n\n      if (shape && shape.attrs.link) {\n        document.body.style.cursor = \"pointer\";\n      } else {\n        document.body.style.cursor = \"default\";\n      } //if we are moving an arrow\n\n\n      if (_this2.state.newArrowRef !== \"\") {\n        //filling color logic:\n        var transform = _this2.refs.layer2.getAbsoluteTransform().copy();\n\n        transform.invert();\n        pos = transform.point(pos);\n\n        _this2.setState({\n          arrowEndX: pos.x,\n          arrowEndY: pos.y\n        }); //last non arrow object\n\n\n        if (shape && shape.attrs && shape.attrs.name != undefined) {\n          //  console.log(shape);\n          if (!shape.attrs.name.includes(\"arrow\")) {\n            //after first frame\n            if (_this2.state.previousShape) if (_this2.state.previousShape !== shape) {\n              //arrow entered a new shape\n              //set current arrow to blue\n              if (_this2.state.previousShape.attrs.id !== \"ContainerRect\") {\n                _this2.state.arrows.map(function (eachArrow) {\n                  if (eachArrow.name === _this2.state.newArrowRef) {\n                    eachArrow.fill = \"black\";\n                    eachArrow.stroke = \"black\";\n                  }\n                });\n\n                _this2.forceUpdate();\n              } else {\n                _this2.state.arrows.map(function (eachArrow) {\n                  if (eachArrow.name === _this2.state.newArrowRef) {\n                    eachArrow.fill = \"#ccf5ff\";\n                    eachArrow.stroke = \"#ccf5ff\";\n                  }\n                });\n\n                _this2.forceUpdate();\n              }\n            } //if arrow is moving in a single shape\n          }\n\n          if (!shape.attrs.name.includes(\"arrow\")) {\n            _this2.setState({\n              previousShape: shape\n            });\n          }\n        }\n      }\n\n      var arrows = _this2.state.arrows;\n      arrows.map(function (eachArrow) {\n        if (eachArrow.name === _this2.state.newArrowRef) {\n          var index = arrows.indexOf(eachArrow);\n          var currentArrow = eachArrow;\n          currentArrow.points = [currentArrow.points[0], currentArrow.points[1], pos.x, pos.y\n          /*  event.evt.pageY -\r\n            document.getElementById(\"NavBar\").getBoundingClientRect().height */\n          ];\n          _this2.state.arrows[index] = currentArrow;\n        }\n      });\n    };\n\n    _this2.handleUndo = function () {\n      if (!_this2.state.isTransforming) {\n        if (!_this2.state.textEditVisible) {\n          if (historyStep === 0) {\n            return;\n          }\n\n          historyStep -= 1;\n\n          _this2.setState({\n            rectangles: history[historyStep].rectangles,\n            arrows: history[historyStep].arrows,\n            ellipses: history[historyStep].ellipses,\n            stars: history[historyStep].stars,\n            texts: history[historyStep].texts,\n            connectors: history[historyStep].connectors,\n            redoing: true,\n            selectedShapeName: _this2.shapeIsGone(history[historyStep]) ? \"\" : _this2.state.selectedShapeName\n          }, function () {\n            _this2.refs.graphicStage.draw();\n          });\n        }\n      }\n    };\n\n    _this2.handleRedo = function () {\n      if (historyStep === history.length - 1) {\n        return;\n      }\n\n      historyStep += 1;\n      var next = history[historyStep];\n\n      _this2.setState({\n        rectangles: next.rectangles,\n        arrows: next.arrows,\n        ellipses: next.ellipses,\n        stars: next.stars,\n        texts: next.texts,\n        redoing: true,\n        selectedShapeName: _this2.shapeIsGone(history[historyStep]) ? \"\" : _this2.state.selectedShapeName\n      }, function () {\n        _this2.forceUpdate();\n      });\n    };\n\n    _this2.shapeIsGone = function (returnTo) {\n      var toReturn = true;\n      var currentShapeName = _this2.state.selectedShapeName;\n      var _ref = [returnTo.rectangles, returnTo.ellipses, returnTo.stars, returnTo.arrows, returnTo.texts],\n          rectangles = _ref[0],\n          ellipses = _ref[1],\n          stars = _ref[2],\n          arrows = _ref[3],\n          texts = _ref[4];\n      rectangles.map(function (eachRect) {\n        if (eachRect.name === currentShapeName) {\n          toReturn = false;\n        }\n      });\n      ellipses.map(function (eachEllipse) {\n        if (eachEllipse.name === currentShapeName) {\n          toReturn = false;\n        }\n      });\n      stars.map(function (eachStar) {\n        if (eachStar.name === currentShapeName) {\n          toReturn = false;\n        }\n      });\n      arrows.map(function (eachArrow) {\n        if (eachArrow.name === currentShapeName) {\n          toReturn = false;\n        }\n      });\n      texts.map(function (eachText) {\n        if (eachText.name === currentShapeName) {\n          toReturn = false;\n        }\n      });\n      return toReturn;\n    };\n\n    _this2.IsJsonString = function (str) {\n      try {\n        JSON.parse(str);\n      } catch (e) {\n        return false;\n      }\n\n      return true;\n    };\n\n    _this2.state = {\n      layerX: 0,\n      layerY: 0,\n      layerScale: 1,\n      selectedShapeName: \"\",\n      errMsg: \"\",\n      rectangles: [],\n      ellipses: [],\n      stars: [],\n      texts: [],\n      arrows: [],\n      connectors: [],\n      currentTextRef: \"\",\n      shouldTextUpdate: true,\n      textX: 0,\n      textY: 0,\n      textEditVisible: false,\n      arrowDraggable: false,\n      newArrowRef: \"\",\n      count: 0,\n      newArrowDropped: false,\n      newConnectorDropped: false,\n      arrowEndX: 0,\n      arrowEndY: 0,\n      isTransforming: false,\n      lastFill: null,\n      saving: null,\n      saved: [],\n      roadmapId: null,\n      alreadyCreated: false,\n      publishing: false,\n      title: \"\",\n      category: \"\",\n      description: \"\",\n      thumbnail: \"\",\n      isPasteDisabled: false,\n      ellipseDeleteCount: 0,\n      starDeleteCount: 0,\n      arrowDeleteCount: 0,\n      textDeleteCount: 0,\n      rectDeleteCount: 0\n    };\n    _this2.handleWheel = _this2.handleWheel.bind(_assertThisInitialized(_assertThisInitialized(_this2)));\n    return _this2;\n  }\n\n  _createClass(Graphics, [{\n    key: \"handleWheel\",\n    value: function handleWheel(event) {\n      if (this.state.rectangles.length === 0 && this.state.ellipses.length === 0 && this.state.stars.length === 0 && this.state.texts.length === 0 && this.state.arrows.length === 0) {} else {\n        event.evt.preventDefault();\n        var scaleBy = 1.2;\n        var stage = this.refs.graphicStage;\n        var layer = this.refs.layer2;\n        var oldScale = layer.scaleX();\n        var mousePointTo = {\n          x: stage.getPointerPosition().x / oldScale - this.state.layerX / oldScale,\n          y: stage.getPointerPosition().y / oldScale - this.state.layerY / oldScale\n        };\n        var newScale = event.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy;\n        layer.scale({\n          x: newScale,\n          y: newScale\n        });\n        /*  console.log(\r\n          oldScale,\r\n          mousePointTo,\r\n          stage.getPointerPosition().x,\r\n          stage.getPointerPosition().y\r\n        );\r\n        */\n\n        this.setState({\n          layerScale: newScale,\n          layerX: -(mousePointTo.x - stage.getPointerPosition().x / newScale) * newScale,\n          layerY: -(mousePointTo.y - stage.getPointerPosition().y / newScale) * newScale\n        });\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var prevMainShapes = [prevState.rectangles, prevState.ellipses, prevState.stars, prevState.arrows, prevState.connectors, prevState.texts];\n      var currentMainShapes = [this.state.rectangles, this.state.ellipses, this.state.stars, this.state.arrows, this.state.connectors, this.state.texts];\n      if (!this.state.redoing && !this.state.isTransforming) if (JSON.stringify(this.state) !== JSON.stringify(prevState)) {\n        if (JSON.stringify(prevMainShapes) !== JSON.stringify(currentMainShapes)) {\n          //if text shouldn't update, don't append to  history\n          if (this.state.shouldTextUpdate) {\n            var uh = history;\n            history = uh.slice(0, historyStep + 1); //console.log(\"sliced\", history);\n\n            var toAppend = this.state;\n            history = history.concat(toAppend); //console.log(\"new\", history);\n\n            historyStep += 1; //console.log(history, historyStep, history[historyStep]);\n          }\n        }\n      } else {//console.log(\"compoenntDidUpdate but attrs didn't change\");\n        }\n      this.state.redoing = false;\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function () {\n      var _componentDidMount = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                history.push(this.state);\n                this.setState({\n                  selectedShapeName: \"\"\n                }); //if draft\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function componentDidMount() {\n        return _componentDidMount.apply(this, arguments);\n      }\n\n      return componentDidMount;\n    }()\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var saveText;\n      var saving = this.state.saving;\n\n      if (saving !== null) {\n        if (saving) {\n          saveText = React.createElement(\"div\", {\n            style: {\n              color: \"white\"\n            },\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 573\n            },\n            __self: this\n          }, \"Saving\");\n        } else {\n          saveText = React.createElement(\"div\", {\n            style: {\n              color: \"white\"\n            },\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 575\n            },\n            __self: this\n          }, \"Saved\");\n        }\n      }\n\n      var canvas = document.createElement(\"canvas\");\n      var ctx = canvas.getContext(\"2d\");\n      var gradient = ctx.createLinearGradient(0, 0, 100, 100);\n      gradient.addColorStop(0.0, \"red\");\n      gradient.addColorStop(1 / 6, \"orange\");\n      gradient.addColorStop(2 / 6, \"yellow\");\n      gradient.addColorStop(3 / 6, \"green\");\n      gradient.addColorStop(4 / 6, \"aqua\");\n      gradient.addColorStop(5 / 6, \"blue\");\n      gradient.addColorStop(1.0, \"purple\");\n      var errMsg = this.state.errMsg;\n      var errDisplay;\n\n      if (errMsg !== \"\") {\n        errDisplay = React.createElement(\"div\", {\n          className: \"errMsginner\",\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 595\n          },\n          __self: this\n        }, React.createElement(\"span\", {\n          style: {\n            color: \"white\"\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 596\n          },\n          __self: this\n        }, errMsg !== \"\" ? errMsg : null));\n      } else {}\n\n      var countryOptions = [{\n        key: \"1\",\n        value: \"Machine Learning\",\n        text: \"Machine Learning\"\n      }, {\n        key: \"2\",\n        value: \"Computer Science\",\n        text: \"Computer Science\"\n      }, {\n        key: \"3\",\n        value: \"Software Engineering\",\n        text: \"Software Engineering\"\n      }, {\n        key: \"12\",\n        value: \"Technology\",\n        text: \"Technology\"\n      }, {\n        key: \"4\",\n        value: \"Engineering\",\n        text: \"Engineering\"\n      }, {\n        key: \"6\",\n        value: \"Sciences and Mathematics\",\n        text: \"Sciences and Mathematics\"\n      }, {\n        key: \"7\",\n        value: \"Law, Economics and Social Sciences\",\n        text: \"Law, Economics and Social Sciences\"\n      }, {\n        key: \"8\",\n        value: \"Humanities\",\n        text: \"Humanities\"\n      }, {\n        key: \"9\",\n        value: \"Linguistics and Cultural Studies\",\n        text: \"Linguistics and Cultural Studies\"\n      }, {\n        key: \"10\",\n        value: \"Art and Music\",\n        text: \"Art and Music\"\n      }, {\n        key: \"11\",\n        value: \"Lifestyle\",\n        text: \"Lifestyle\"\n      }, {\n        key: \"13\",\n        value: \"Others\",\n        text: \"Others\"\n      }];\n      return React.createElement(React.Fragment, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 641\n        },\n        __self: this\n      }, React.createElement(\"div\", {\n        onKeyDown: function onKeyDown(event) {\n          var x = 88,\n              deleteKey = 46,\n              copy = 67,\n              paste = 86,\n              z = 90,\n              y = 89;\n\n          if ((event.ctrlKey && event.keyCode === x || event.keyCode === deleteKey) && !_this3.state.isPasteDisabled) {\n            if (_this3.state.selectedShapeName !== \"\") {\n              var that = _this3; //delete it from the state too\n\n              var name = _this3.state.selectedShapeName;\n              var rectDeleted = false,\n                  ellipseDeleted = false,\n                  starDeleted = false,\n                  arrowDeleted = false,\n                  textDeleted = false;\n\n              var rects = _this3.state.rectangles.filter(function (eachRect) {\n                if (eachRect.name === name) {\n                  that.setState({\n                    rectDeleteCount: that.state.rectDeleteCount + 1\n                  });\n                }\n\n                return eachRect.name !== name;\n              });\n\n              var ellipses = _this3.state.ellipses.filter(function (eachRect) {\n                if (eachRect.name === name) {\n                  that.setState({\n                    ellipseDeleteCount: that.state.ellipseDeleteCount + 1\n                  });\n                }\n\n                return eachRect.name !== name;\n              });\n\n              var stars = _this3.state.stars.filter(function (eachRect) {\n                if (eachRect.name === name) {\n                  that.setState({\n                    starDeleteCount: that.state.starDeleteCount + 1\n                  });\n                }\n\n                return eachRect.name !== name;\n              });\n\n              var arrows = _this3.state.arrows.filter(function (eachRect) {\n                if (eachRect.name === name) {\n                  that.setState({\n                    arrowDeleteCount: that.state.arrowDeleteCount + 1\n                  });\n                }\n\n                return eachRect.name !== name;\n              });\n\n              var texts = _this3.state.texts.filter(function (eachRect) {\n                if (eachRect.name === name) {\n                  that.setState({\n                    textDeleteCount: that.state.textDeleteCount + 1\n                  });\n                }\n\n                return eachRect.name !== name;\n              });\n\n              _this3.setState({\n                rectangles: rects,\n                ellipses: ellipses,\n                stars: stars,\n                arrows: arrows,\n                texts: texts,\n                selectedShapeName: \"\"\n              });\n            }\n          } else if (event.shiftKey && event.ctrlKey && event.keyCode === z) {\n            _this3.handleRedo();\n          } else if (event.ctrlKey && event.keyCode === z) {\n            _this3.handleUndo();\n          } else if (event.ctrlKey && event.keyCode === y) {\n            _this3.handleRedo();\n          } else if (event.ctrlKey && event.keyCode === copy) {\n            if (_this3.state.selectedShapeName !== \"\") {\n              //find it\n              var _name = _this3.state.selectedShapeName;\n              var copiedElement = null;\n\n              if (_name.includes(\"rect\")) {\n                copiedElement = _this3.state.rectangles.filter(function (eachRect) {\n                  return eachRect.name === _name;\n                });\n              } else if (_name.includes(\"ellipse\")) {\n                copiedElement = _this3.state.ellipses.filter(function (eachRect) {\n                  return eachRect.name === _name;\n                });\n              } else if (_name.includes(\"star\")) {\n                copiedElement = _this3.state.stars.filter(function (eachRect) {\n                  return eachRect.name === _name;\n                });\n              } else if (_name.includes(\"text\")) {\n                copiedElement = _this3.state.texts.filter(function (eachRect) {\n                  return eachRect.name === _name;\n                });\n              } else if (_name.includes(\"arrow\")) {\n                copiedElement = _this3.state.arrows.filter(function (eachRect) {\n                  return eachRect.name === _name;\n                });\n              }\n\n              _this3.setState({\n                copiedElement: copiedElement\n              }, function () {\n                console.log(\"copied ele\", _this3.state.copiedElement);\n              });\n            }\n          } else if (event.ctrlKey && event.keyCode === paste && !_this3.state.isPasteDisabled) {\n            var _copiedElement = _this3.state.copiedElement[0];\n            console.log(_copiedElement);\n            var length;\n\n            if (_copiedElement) {\n              if (_copiedElement.attrs) {} else {\n                if (_copiedElement.name.includes(\"rectangle\")) {\n                  length = _this3.state.rectangles.length + 1 + _this3.state.rectDeleteCount;\n                  var toPush = {\n                    x: _copiedElement.x + 10,\n                    y: _copiedElement.y + 10,\n                    width: _copiedElement.width,\n                    height: _copiedElement.height,\n                    stroke: _copiedElement.stroke,\n                    strokeWidth: _copiedElement.strokeWidth,\n                    name: \"rectangle\" + (_this3.state.rectangles.length + _this3.state.rectDeleteCount + 1),\n                    ref: \"rectangle\" + (_this3.state.rectangles.length + _this3.state.rectDeleteCount + 1),\n                    fill: _copiedElement.fill,\n                    useImage: _copiedElement.useImage,\n                    link: _copiedElement.link,\n                    rotation: _copiedElement.rotation\n                  };\n                  var newName = _this3.state.selectedShapeName;\n\n                  _this3.setState(function (prevState) {\n                    return {\n                      rectangles: [].concat(_toConsumableArray(prevState.rectangles), [toPush])\n                    };\n                  }, function () {\n                    _this3.setState({\n                      selectedShapeName: \"rectangle\" + _this3.state.rectangles.length\n                    });\n                  });\n                } else if (_copiedElement.name.includes(\"arrow\")) {\n                  length = _this3.state.arrows.length + 1 + _this3.state.arrowDeleteCount;\n\n                  if (_copiedElement.to || _copiedElement.from) {\n                    _this3.setState({\n                      errMsg: \"Connectors cannot be pasted\"\n                    }, function () {\n                      var that = _this3;\n                      setTimeout(function () {\n                        that.setState({\n                          errMsg: \"\"\n                        });\n                      }, 1000);\n                    });\n                  } else {\n                    var toPush = {\n                      points: [_copiedElement.points[0] + 30, _copiedElement.points[1] + 30, _copiedElement.points[2] + 30, _copiedElement.points[3] + 30],\n                      fill: _copiedElement.fill,\n                      link: _copiedElement.link,\n                      stroke: _copiedElement.stroke,\n                      strokeWidth: _copiedElement.strokeWidth,\n                      name: \"arrow\" + (_this3.state.arrows.length + 1 + _this3.state.arrowDeleteCount),\n                      ref: \"arrow\" + (_this3.state.arrows.length + 1 + _this3.state.arrowDeleteCount),\n                      rotation: _copiedElement.rotation\n                    };\n                    var _newName = _this3.state.selectedShapeName;\n\n                    _this3.setState(function (prevState) {\n                      return {\n                        arrows: [].concat(_toConsumableArray(prevState.arrows), [toPush])\n                      };\n                    }, function () {\n                      _this3.setState({\n                        selectedShapeName: \"arrow\" + _this3.state.arrows.length\n                      });\n                    });\n                  }\n                } else if (_copiedElement.name.includes(\"ellipse\")) {\n                  length = _this3.state.ellipses.length + 1 + _this3.state.ellipseDeleteCount;\n                  var toPush = {\n                    x: _copiedElement.x + 10,\n                    y: _copiedElement.y + 10,\n                    radiusX: _copiedElement.radiusX,\n                    radiusY: _copiedElement.radiusY,\n                    stroke: _copiedElement.stroke,\n                    strokeWidth: _copiedElement.strokeWidth,\n                    name: \"ellipse\" + (_this3.state.ellipses.length + 1 + _this3.state.ellipseDeleteCount),\n                    ref: \"ellipse\" + (_this3.state.ellipses.length + 1 + _this3.state.ellipseDeleteCount),\n                    fill: _copiedElement.fill,\n                    link: _copiedElement.link,\n                    useImage: _copiedElement.useImage,\n                    rotation: _copiedElement.rotation\n                  };\n                  var _newName2 = _this3.state.selectedShapeName;\n\n                  _this3.setState(function (prevState) {\n                    return {\n                      ellipses: [].concat(_toConsumableArray(prevState.ellipses), [toPush])\n                    };\n                  }, function () {\n                    _this3.setState({\n                      selectedShapeName: \"ellipse\" + _this3.state.ellipses.length\n                    });\n                  });\n                } else if (_copiedElement.name.includes(\"star\")) {\n                  length = _this3.state.stars.length + 1 + _this3.state.starDeleteCount;\n                  var toPush = {\n                    x: _copiedElement.x + 10,\n                    y: _copiedElement.y + 10,\n                    link: _copiedElement.link,\n                    innerRadius: _copiedElement.innerRadius,\n                    outerRadius: _copiedElement.outerRadius,\n                    stroke: _copiedElement.stroke,\n                    strokeWidth: _copiedElement.strokeWidth,\n                    name: \"star\" + (_this3.state.stars.length + 1 + _this3.state.starDeleteCount),\n                    ref: \"star\" + (_this3.state.stars.length + 1 + _this3.state.starDeleteCount),\n                    fill: _copiedElement.fill,\n                    useImage: _copiedElement.useImage,\n                    rotation: _copiedElement.rotation\n                  };\n                  var _newName3 = _this3.state.selectedShapeName;\n\n                  _this3.setState(function (prevState) {\n                    return {\n                      stars: [].concat(_toConsumableArray(prevState.stars), [toPush])\n                    };\n                  }, function () {\n                    _this3.setState({\n                      selectedShapeName: \"star\" + _this3.state.stars.length\n                    });\n                  });\n                } else if (_copiedElement.name.includes(\"text\")) {\n                  length = _this3.state.texts.length + 1 + _this3.state.textDeleteCount;\n                  var toPush = {\n                    x: _copiedElement.x + 10,\n                    y: _copiedElement.y + 10,\n                    link: _copiedElement.link,\n                    name: \"text\" + (_this3.state.texts.length + 1 + _this3.state.textDeleteCount),\n                    ref: \"text\" + (_this3.state.texts.length + 1 + _this3.state.textDeleteCount),\n                    fill: _copiedElement.fill,\n                    fontSize: _copiedElement.fontSize,\n                    fontFamily: _copiedElement.fontFamily,\n                    useImage: _copiedElement.useImage,\n                    text: _copiedElement.text,\n                    width: _copiedElement.width,\n                    rotation: _copiedElement.rotation\n                  };\n                  var _newName4 = _this3.state.selectedShapeName;\n\n                  _this3.setState(function (prevState) {\n                    return {\n                      texts: [].concat(_toConsumableArray(prevState.texts), [toPush])\n                    };\n                  }, function () {\n                    _this3.setState({\n                      selectedShapeName: \"text\" + (_this3.state.texts.length + _this3.state.textDeleteCount)\n                    }, function () {\n                      console.log(_this3.state.selectedShapeName);\n                    });\n                  });\n                }\n              }\n            }\n          }\n        },\n        tabIndex: \"0\",\n        style: {\n          outline: \"none\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 642\n        },\n        __self: this\n      }, React.createElement(Stage, {\n        onClick: this.handleStageClick,\n        onMouseMove: this.handleMouseOver,\n        onWheel: function onWheel(event) {\n          return _this3.handleWheel(event);\n        },\n        height: window.innerHeight,\n        width: window.innerWidth,\n        ref: \"graphicStage\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1002\n        },\n        __self: this\n      }, React.createElement(Layer, {\n        scaleX: this.state.layerScale,\n        scaleY: this.state.layerScale,\n        x: this.state.layerX,\n        y: this.state.layerY,\n        height: window.innerHeight,\n        width: window.innerWidth,\n        draggable: true,\n        onDragEnd: function onDragEnd() {\n          _this3.setState({\n            layerX: _this3.refs.layer2.x(),\n            layerY: _this3.refs.layer2.y()\n          });\n        },\n        ref: \"layer2\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1010\n        },\n        __self: this\n      }, React.createElement(Rect, {\n        x: -5 * window.innerWidth,\n        y: -5 * window.innerHeight,\n        height: window.innerHeight * 10,\n        width: window.innerWidth * 10,\n        name: \"\",\n        id: \"ContainerRect\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1026\n        },\n        __self: this\n      }), this.state.rectangles.map(function (eachRect) {\n        return React.createElement(Rect, {\n          onClick: function onClick() {\n            var that = _this3;\n\n            if (eachRect.link !== undefined && eachRect.link !== \"\") {\n              _this3.setState({\n                errMsg: \"Links will not be opened in create mode\"\n              }, function () {\n                setTimeout(function () {\n                  that.setState({\n                    errMsg: \"\"\n                  });\n                }, 1000);\n              });\n            }\n          },\n          onTransformStart: function onTransformStart() {\n            _this3.setState({\n              isTransforming: true\n            });\n\n            var rect = _this3.refs[eachRect.ref];\n            rect.setAttr(\"lastRotation\", rect.rotation());\n          },\n          onTransform: function onTransform() {\n            var rect = _this3.refs[eachRect.ref];\n\n            if (rect.attrs.lastRotation !== rect.rotation()) {\n              _this3.state.arrows.map(function (eachArrow) {\n                if (eachArrow.to && eachArrow.to.name() === rect.name()) {\n                  _this3.setState({\n                    errMsg: \"Rotating rects with connectors might skew things up!\"\n                  });\n                }\n\n                if (eachArrow.from && eachArrow.from.name() === rect.name()) {\n                  _this3.setState({\n                    errMsg: \"Rotating rects with connectors might skew things up!\"\n                  });\n                }\n              });\n            }\n\n            rect.setAttr(\"lastRotation\", rect.rotation());\n          },\n          onTransformEnd: function onTransformEnd() {\n            _this3.setState({\n              isTransforming: false\n            });\n\n            var rect = _this3.refs[eachRect.ref];\n\n            _this3.setState(function (prevState) {\n              return {\n                errMsg: \"\",\n                rectangles: prevState.rectangles.map(function (eachRect) {\n                  return eachRect.name === rect.attrs.name ? _objectSpread({}, eachRect, {\n                    width: rect.width() * rect.scaleX(),\n                    height: rect.height() * rect.scaleY(),\n                    rotation: rect.rotation(),\n                    x: rect.x(),\n                    y: rect.y()\n                  }) : eachRect;\n                })\n              };\n            }, function () {\n              _this3.forceUpdate();\n            });\n\n            rect.setAttr(\"scaleX\", 1);\n            rect.setAttr(\"scaleY\", 1);\n          },\n          rotation: eachRect.rotation,\n          ref: eachRect.ref,\n          fill: eachRect.fill,\n          name: eachRect.name,\n          x: eachRect.x,\n          y: eachRect.y,\n          width: eachRect.width,\n          height: eachRect.height,\n          stroke: eachRect.stroke,\n          strokeWidth: eachRect.strokeWidth,\n          strokeScaleEnabled: false,\n          draggable: true,\n          onDragMove: function onDragMove() {\n            _this3.state.arrows.map(function (eachArrow) {\n              if (eachArrow.from !== undefined) {\n                if (eachRect.name === eachArrow.from.attrs.name) {\n                  eachArrow.points = [eachRect.x, eachRect.y, eachArrow.points[2], eachArrow.points[3]];\n\n                  _this3.forceUpdate();\n                }\n              }\n\n              if (eachArrow.to !== undefined) {\n                if (eachRect.name == eachArrow.to.attrs.name) {\n                  eachArrow.points = [eachArrow.points[0], eachArrow.points[1], eachRect.x, eachRect.y];\n\n                  _this3.forceUpdate();\n                }\n              }\n            });\n          },\n          onDragEnd: function onDragEnd(event) {\n            //cannot compare by name because currentSelected might not be the same\n            //have to use ref, which appears to be overcomplicated\n            var shape = _this3.refs[eachRect.ref];\n            /*    this.state.rectangles.map(eachRect => {\r\n                if (eachRect.name === shape.attrs.name) {\r\n                  shape.position({\r\n                    x: event.target.x(),\r\n                    y: event.target.y()\r\n                  });\r\n                }\r\n              });*/\n\n            _this3.setState(function (prevState) {\n              return {\n                rectangles: prevState.rectangles.map(function (eachRect) {\n                  return eachRect.name === shape.attrs.name ? _objectSpread({}, eachRect, {\n                    x: event.target.x(),\n                    y: event.target.y()\n                  }) : eachRect;\n                })\n              };\n            });\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1037\n          },\n          __self: this\n        });\n      }), this.state.ellipses.map(function (eachEllipse) {\n        return React.createElement(Ellipse, {\n          ref: eachEllipse.ref,\n          name: eachEllipse.name,\n          x: eachEllipse.x,\n          y: eachEllipse.y,\n          rotation: eachEllipse.rotation,\n          radiusX: eachEllipse.radiusX,\n          radiusY: eachEllipse.radiusY,\n          fill: eachEllipse.fill,\n          stroke: eachEllipse.stroke,\n          strokeWidth: eachEllipse.strokeWidth,\n          strokeScaleEnabled: false,\n          onClick: function onClick() {\n            var that = _this3;\n\n            if (eachEllipse.link !== undefined && eachEllipse.link !== \"\") {\n              _this3.setState({\n                errMsg: \"Links will not be opened in create mode\"\n              }, function () {\n                setTimeout(function () {\n                  that.setState({\n                    errMsg: \"\"\n                  });\n                }, 1000);\n              });\n            }\n          },\n          onTransformStart: function onTransformStart() {\n            _this3.setState({\n              isTransforming: true\n            });\n\n            var ellipse = _this3.refs[eachEllipse.ref];\n            ellipse.setAttr(\"lastRotation\", ellipse.rotation());\n          },\n          onTransform: function onTransform() {\n            var ellipse = _this3.refs[eachEllipse.ref];\n\n            if (ellipse.attrs.lastRotation !== ellipse.rotation()) {\n              _this3.state.arrows.map(function (eachArrow) {\n                if (eachArrow.to && eachArrow.to.name() === ellipse.name()) {\n                  _this3.setState({\n                    errMsg: \"Rotating ellipses with connectors might skew things up!\"\n                  });\n                }\n\n                if (eachArrow.from && eachArrow.from.name() === ellipse.name()) {\n                  _this3.setState({\n                    errMsg: \"Rotating ellipses with connectors might skew things up!\"\n                  });\n                }\n              });\n            }\n\n            ellipse.setAttr(\"lastRotation\", ellipse.rotation());\n          },\n          onTransformEnd: function onTransformEnd() {\n            _this3.setState({\n              isTransforming: false\n            });\n\n            var ellipse = _this3.refs[eachEllipse.ref];\n            var scaleX = ellipse.scaleX(),\n                scaleY = ellipse.scaleY();\n\n            _this3.setState(function (prevState) {\n              return {\n                errMsg: \"\",\n                ellipses: prevState.ellipses.map(function (eachEllipse) {\n                  return eachEllipse.name === ellipse.attrs.name ? _objectSpread({}, eachEllipse, {\n                    radiusX: ellipse.radiusX() * ellipse.scaleX(),\n                    radiusY: ellipse.radiusY() * ellipse.scaleY(),\n                    rotation: ellipse.rotation(),\n                    x: ellipse.x(),\n                    y: ellipse.y()\n                  }) : eachEllipse;\n                })\n              };\n            });\n\n            ellipse.setAttr(\"scaleX\", 1);\n            ellipse.setAttr(\"scaleY\", 1);\n\n            _this3.forceUpdate();\n          },\n          draggable: true,\n          onDragMove: function onDragMove() {\n            console.log(\"name of ellipse moving: \", eachEllipse.name, \"new x y\", eachEllipse.x, eachEllipse.y);\n\n            _this3.state.arrows.map(function (eachArrow) {\n              if (eachArrow.from !== undefined) {\n                console.log(\"prevArrow: \", eachArrow.points);\n\n                if (eachEllipse.name == eachArrow.from.attrs.name) {\n                  eachArrow.points = [eachEllipse.x, eachEllipse.y, eachArrow.points[2], eachArrow.points[3]];\n\n                  _this3.forceUpdate();\n\n                  _this3.refs.graphicStage.draw();\n                }\n\n                console.log(\"new arrows:\", eachArrow.points);\n              }\n\n              if (eachArrow.to !== undefined) {\n                if (eachEllipse.name === eachArrow.to.attrs.name) {\n                  eachArrow.points = [eachArrow.points[0], eachArrow.points[1], eachEllipse.x, eachEllipse.y];\n\n                  _this3.forceUpdate();\n\n                  _this3.refs.graphicStage.draw();\n                }\n              }\n            });\n          },\n          onDragEnd: function onDragEnd(event) {\n            //cannot compare by name because currentSelected might not be the same\n            //have to use ref, which appears to be overcomplicated\n            var shape = _this3.refs[eachEllipse.ref];\n\n            _this3.setState(function (prevState) {\n              return {\n                ellipses: prevState.ellipses.map(function (eachEllipse) {\n                  return eachEllipse.name === shape.attrs.name ? _objectSpread({}, eachEllipse, {\n                    x: event.target.x(),\n                    y: event.target.y()\n                  }) : eachEllipse;\n                })\n              };\n            });\n\n            _this3.refs.graphicStage.draw();\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1187\n          },\n          __self: this\n        });\n      }), this.state.stars.map(function (eachStar) {\n        return React.createElement(Star, {\n          ref: eachStar.ref,\n          name: eachStar.name,\n          x: eachStar.x,\n          y: eachStar.y,\n          innerRadius: eachStar.innerRadius,\n          outerRadius: eachStar.outerRadius,\n          numPoints: eachStar.numPoints,\n          stroke: eachStar.stroke,\n          strokeWidth: eachStar.strokeWidth,\n          fill: eachStar.fill,\n          strokeScaleEnabled: false,\n          rotation: eachStar.rotation,\n          onClick: function onClick() {\n            var that = _this3;\n\n            if (eachStar.link !== undefined && eachStar.link !== \"\") {\n              _this3.setState({\n                errMsg: \"Links will not be opened in create mode\"\n              }, function () {\n                setTimeout(function () {\n                  that.setState({\n                    errMsg: \"\"\n                  });\n                }, 1000);\n              });\n            }\n          },\n          onTransformStart: function onTransformStart() {\n            _this3.setState({\n              isTransforming: true\n            });\n          },\n          onTransformEnd: function onTransformEnd() {\n            _this3.setState({\n              isTransforming: false\n            });\n\n            var star = _this3.refs[eachStar.ref];\n            var scaleX = star.scaleX(),\n                scaleY = star.scaleY();\n\n            _this3.setState(function (prevState) {\n              return {\n                stars: prevState.stars.map(function (eachStar) {\n                  return eachStar.name === star.attrs.name ? _objectSpread({}, eachStar, {\n                    innerRadius: star.innerRadius() * star.scaleX(),\n                    outerRadius: star.outerRadius() * star.scaleX(),\n                    rotation: star.rotation(),\n                    x: star.x(),\n                    y: star.y()\n                  }) : eachStar;\n                })\n              };\n            });\n\n            star.setAttr(\"scaleX\", 1);\n            star.setAttr(\"scaleY\", 1);\n\n            _this3.forceUpdate();\n          },\n          draggable: true,\n          onDragMove: function onDragMove() {\n            _this3.state.arrows.map(function (eachArrow) {\n              if (eachArrow.from !== undefined) {\n                if (eachStar.name == eachArrow.from.attrs.name) {\n                  eachArrow.points = [eachStar.x, eachStar.y, eachArrow.points[2], eachArrow.points[3]];\n\n                  _this3.forceUpdate();\n                }\n              }\n\n              if (eachArrow.to !== undefined) {\n                if (eachStar.name === eachArrow.to.attrs.name) {\n                  eachArrow.points = [eachArrow.points[0], eachArrow.points[1], eachStar.x, eachStar.y];\n\n                  _this3.forceUpdate();\n                }\n              }\n            });\n          },\n          onDragEnd: function onDragEnd(event) {\n            //cannot compare by name because currentSelected might not be the same\n            //have to use ref, which appears to be overcomplicated\n            var shape = _this3.refs[eachStar.ref];\n\n            _this3.setState(function (prevState) {\n              return {\n                stars: prevState.stars.map(function (eachStar) {\n                  return eachStar.name === shape.attrs.name ? _objectSpread({}, eachStar, {\n                    x: event.target.x(),\n                    y: event.target.y()\n                  }) : eachStar;\n                })\n              };\n            });\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1340\n          },\n          __self: this\n        });\n      }), this.state.texts.map(function (eachText) {\n        return (//perhaps this.state.texts only need to contain refs?\n          //so that we only need to store the refs to get more information\n          React.createElement(Text, {\n            textDecoration: eachText.link ? \"underline\" : \"\",\n            onTransformStart: function onTransformStart() {\n              var currentText = _this3.refs[_this3.state.selectedShapeName];\n              currentText.setAttr(\"lastRotation\", currentText.rotation());\n            },\n            onTransform: function onTransform() {\n              var currentText = _this3.refs[_this3.state.selectedShapeName];\n              currentText.setAttr(\"width\", currentText.width() * currentText.scaleX());\n              currentText.setAttr(\"scaleX\", 1);\n              currentText.draw();\n\n              if (currentText.attrs.lastRotation !== currentText.rotation()) {\n                _this3.state.arrows.map(function (eachArrow) {\n                  if (eachArrow.to && eachArrow.to.name() === currentText.name()) {\n                    _this3.setState({\n                      errMsg: \"Rotating texts with connectors might skew things up!\"\n                    });\n                  }\n\n                  if (eachArrow.from && eachArrow.from.name() === currentText.name()) {\n                    _this3.setState({\n                      errMsg: \"Rotating texts with connectors might skew things up!\"\n                    });\n                  }\n                });\n              }\n\n              currentText.setAttr(\"lastRotation\", currentText.rotation());\n            },\n            onTransformEnd: function onTransformEnd() {\n              var currentText = _this3.refs[_this3.state.selectedShapeName];\n\n              _this3.setState(function (prevState) {\n                return {\n                  errMsg: \"\",\n                  texts: prevState.texts.map(function (eachText) {\n                    return eachText.name === _this3.state.selectedShapeName ? _objectSpread({}, eachText, {\n                      width: currentText.width(),\n                      rotation: currentText.rotation(),\n                      textWidth: currentText.textWidth,\n                      textHeight: currentText.textHeight,\n                      x: currentText.x(),\n                      y: currentText.y()\n                    }) : eachText;\n                  })\n                };\n              });\n\n              currentText.setAttr(\"scaleX\", 1);\n              currentText.draw();\n            },\n            link: eachText.link,\n            width: eachText.width,\n            fill: eachText.fill,\n            name: eachText.name,\n            ref: eachText.ref,\n            rotation: eachText.rotation,\n            fontFamily: eachText.fontFamily,\n            fontSize: eachText.fontSize,\n            x: eachText.x,\n            y: eachText.y,\n            text: eachText.text,\n            draggable: true,\n            onDragMove: function onDragMove() {\n              _this3.state.arrows.map(function (eachArrow) {\n                if (eachArrow.from !== undefined) {\n                  if (eachText.name === eachArrow.from.attrs.name) {\n                    eachArrow.points = [eachText.x, eachText.y, eachArrow.points[2], eachArrow.points[3]];\n\n                    _this3.forceUpdate();\n                  }\n                }\n\n                if (eachArrow.to !== undefined) {\n                  if (eachText.name === eachArrow.to.attrs.name) {\n                    eachArrow.points = [eachArrow.points[0], eachArrow.points[1], eachText.x, eachText.y];\n\n                    _this3.forceUpdate();\n                  }\n                }\n              });\n            },\n            onDragEnd: function onDragEnd(event) {\n              //cannot compare by name because currentSelected might not be the same\n              //have to use ref, which appears to be overcomplicated\n              var shape = _this3.refs[eachText.ref];\n\n              _this3.setState(function (prevState) {\n                return {\n                  texts: prevState.texts.map(function (eachtext) {\n                    return eachtext.name === shape.attrs.name ? _objectSpread({}, eachtext, {\n                      x: event.target.x(),\n                      y: event.target.y()\n                    }) : eachtext;\n                  })\n                };\n              });\n            },\n            onClick: function onClick() {\n              var that = _this3;\n\n              if (eachText.link !== undefined && eachText.link !== \"\") {\n                _this3.setState({\n                  errMsg: \"Links will not be opened in create mode\"\n                }, function () {\n                  setTimeout(function () {\n                    that.setState({\n                      errMsg: \"\"\n                    });\n                  }, 1000);\n                }); //var win = window.open(eachText.link, \"_blank\");\n                //win.focus();\n\n              }\n            },\n            onDblClick: function onDblClick() {\n              // turn into textarea\n              var stage = _this3.refs.graphicStage;\n              var text = stage.findOne(\".\" + eachText.name);\n\n              _this3.setState({\n                textX: text.absolutePosition().x,\n                textY: text.absolutePosition().y,\n                textEditVisible: !_this3.state.textEditVisible,\n                text: eachText.text,\n                textNode: eachText,\n                currentTextRef: eachText.ref,\n                textareaWidth: text.textWidth,\n                textareaHeight: text.textHeight,\n                textareaFill: text.attrs.fill,\n                textareaFontFamily: text.attrs.fontFamily,\n                textareaFontSize: text.attrs.fontSize\n              });\n\n              var textarea = _this3.refs.textarea;\n              textarea.focus();\n              text.hide();\n              var transformer = stage.findOne(\".transformer\");\n              transformer.hide();\n\n              _this3.refs.layer2.draw();\n            },\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 1447\n            },\n            __self: this\n          })\n        );\n      }), this.state.arrows.map(function (eachArrow) {\n        if (!eachArrow.from && !eachArrow.to) {\n          return React.createElement(Arrow, {\n            ref: eachArrow.ref,\n            name: eachArrow.name,\n            points: [eachArrow.points[0], eachArrow.points[1], eachArrow.points[2], eachArrow.points[3]],\n            stroke: eachArrow.stroke,\n            fill: eachArrow.fill,\n            draggable: true,\n            onDragEnd: function onDragEnd(event) {\n              //set new points to current position\n              //usually: state => star => x & y\n              //now: state => arrow => attr => x & y\n              var oldPoints = [eachArrow.points[0], eachArrow.points[1], eachArrow.points[2], eachArrow.points[3]];\n              var shiftX = _this3.refs[eachArrow.ref].attrs.x;\n              var shiftY = _this3.refs[eachArrow.ref].attrs.y;\n              var newPoints = [oldPoints[0] + shiftX, oldPoints[1] + shiftY, oldPoints[2] + shiftX, oldPoints[3] + shiftY];\n\n              _this3.refs[eachArrow.ref].position({\n                x: 0,\n                y: 0\n              });\n\n              _this3.refs.layer2.draw();\n\n              _this3.setState(function (prevState) {\n                return {\n                  arrows: prevState.arrows.map(function (eachArr) {\n                    return eachArr.name === eachArrow.name ? _objectSpread({}, eachArr, {\n                      points: newPoints\n                    }) : eachArr;\n                  })\n                };\n              });\n            },\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 1619\n            },\n            __self: this\n          });\n        } else if (eachArrow.name === _this3.state.newArrowRef && (eachArrow.from || eachArrow.to)) {\n          return React.createElement(Connector, {\n            name: eachArrow.name,\n            from: eachArrow.from,\n            to: eachArrow.to,\n            arrowEndX: _this3.state.arrowEndX,\n            arrowEndY: _this3.state.arrowEndY,\n            current: true,\n            stroke: eachArrow.stroke,\n            fill: eachArrow.fill,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 1675\n            },\n            __self: this\n          });\n        } else if (eachArrow.from || eachArrow.to) {\n          //if arrow construction is completed\n          return React.createElement(Connector, {\n            name: eachArrow.name,\n            from: eachArrow.from,\n            to: eachArrow.to,\n            points: eachArrow.points,\n            current: false,\n            stroke: eachArrow.stroke,\n            fill: eachArrow.fill,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 1689\n            },\n            __self: this\n          });\n        }\n      }), this.state.selectedShapeName.includes(\"text\") ? React.createElement(TransformerComponent, {\n        selectedShapeName: this.state.selectedShapeName,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1703\n        },\n        __self: this\n      }) : React.createElement(TransformerComponent, {\n        selectedShapeName: this.state.selectedShapeName,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1707\n        },\n        __self: this\n      })), React.createElement(Layer, {\n        height: window.innerHeight,\n        width: window.innerWidth,\n        ref: \"layer\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1713\n        },\n        __self: this\n      }, React.createElement(Toolbar, {\n        layer: this.refs.layer2,\n        rectName: this.state.rectangles.length + 1 + this.state.rectDeleteCount,\n        ellipseName: this.state.ellipses.length + 1 + this.state.ellipseDeleteCount,\n        starName: this.state.stars.length + 1 + this.state.starDeleteCount,\n        textName: this.state.texts.length + 1 + this.state.textDeleteCount,\n        newArrowOnDragEnd: function newArrowOnDragEnd(toPush) {\n          if (toPush.from !== undefined) {\n            //  console.log(\"we are making a connector\");\n            var transform = _this3.refs.layer2.getAbsoluteTransform().copy();\n\n            transform.invert();\n            var uh = transform.point({\n              x: toPush.x,\n              y: toPush.y\n            });\n            toPush.x = uh.x;\n            toPush.y = uh.y;\n            var newArrow = {\n              points: toPush.points,\n              ref: \"arrow\" + (_this3.state.arrows.length + 1 + _this3.state.arrowDeleteCount),\n              name: \"arrow\" + (_this3.state.arrows.length + 1 + _this3.state.arrowDeleteCount),\n              from: toPush.from,\n              stroke: toPush.stroke,\n              strokeWidth: toPush.strokeWidth,\n              fill: toPush.fill\n            }; //  console.log(newArrow);\n\n            _this3.setState(function (prevState) {\n              return {\n                arrows: [].concat(_toConsumableArray(prevState.arrows), [newArrow]),\n                newArrowDropped: true,\n                newArrowRef: newArrow.name,\n                arrowEndX: toPush.x,\n                arrowEndY: toPush.y\n              };\n            });\n          } else {\n            //  console.log(\"we are making just an aarrow\");\n            var transform = _this3.refs.layer2.getAbsoluteTransform().copy();\n\n            transform.invert();\n\n            var _uh = transform.point({\n              x: toPush.x,\n              y: toPush.y\n            });\n\n            toPush.x = _uh.x;\n            toPush.y = _uh.y;\n            var newArrow = {\n              points: [toPush.x, toPush.y, toPush.x, toPush.y],\n              ref: \"arrow\" + (_this3.state.arrows.length + 1 + _this3.state.arrowDeleteCount),\n              name: \"arrow\" + (_this3.state.arrows.length + 1 + _this3.state.arrowDeleteCount),\n              from: toPush.from,\n              stroke: toPush.stroke,\n              strokeWidth: toPush.strokeWidth,\n              fill: toPush.fill\n            };\n\n            _this3.setState(function (prevState) {\n              return {\n                arrows: [].concat(_toConsumableArray(prevState.arrows), [newArrow]),\n                newArrowDropped: true,\n                newArrowRef: newArrow.name,\n                arrowEndX: toPush.x,\n                arrowEndY: toPush.y\n              };\n            });\n          } //this.refs updates after forceUpdate (because arrow gets instantiated), might be risky in the future\n          //only this.state.arrows.length because it was pushed earlier, cancelling the +1\n\n        },\n        appendToRectangles: function appendToRectangles(stuff) {\n          var layer = _this3.refs.layer2;\n          var toPush = stuff;\n          var stage = _this3.refs.graphicStage;\n\n          var transform = _this3.refs.layer2.getAbsoluteTransform().copy();\n\n          transform.invert();\n          var pos = transform.point({\n            x: toPush.x,\n            y: toPush.y\n          });\n\n          if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\n            toPush.x = pos.x;\n            toPush.y = pos.y;\n          }\n\n          _this3.setState(function (prevState) {\n            return {\n              rectangles: [].concat(_toConsumableArray(prevState.rectangles), [toPush]),\n              selectedShapeName: toPush.name\n            };\n          });\n        },\n        appendToEllipses: function appendToEllipses(stuff) {\n          var layer = _this3.refs.layer2;\n          var toPush = stuff;\n          var stage = _this3.refs.graphicStage;\n\n          var transform = _this3.refs.layer2.getAbsoluteTransform().copy();\n\n          transform.invert();\n          var pos = transform.point({\n            x: toPush.x,\n            y: toPush.y\n          });\n\n          if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\n            toPush.x = pos.x;\n            toPush.y = pos.y;\n          }\n\n          _this3.setState(function (prevState) {\n            return {\n              ellipses: [].concat(_toConsumableArray(prevState.ellipses), [toPush]),\n              selectedShapeName: toPush.name\n            };\n          });\n        },\n        appendToStars: function appendToStars(stuff) {\n          var layer = _this3.refs.layer2;\n          var toPush = stuff;\n          var stage = _this3.refs.graphicStage;\n\n          var transform = _this3.refs.layer2.getAbsoluteTransform().copy();\n\n          transform.invert();\n          var pos = transform.point({\n            x: toPush.x,\n            y: toPush.y\n          });\n\n          if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\n            toPush.x = pos.x;\n            toPush.y = pos.y;\n          }\n\n          _this3.setState(function (prevState) {\n            return {\n              stars: [].concat(_toConsumableArray(prevState.stars), [toPush]),\n              selectedShapeName: toPush.name\n            };\n          });\n        },\n        appendToTexts: function appendToTexts(stuff) {\n          var layer = _this3.refs.layer2;\n          var toPush = stuff;\n          var stage = _this3.refs.graphicStage;\n\n          var transform = _this3.refs.layer2.getAbsoluteTransform().copy();\n\n          transform.invert();\n          var pos = transform.point({\n            x: toPush.x,\n            y: toPush.y\n          });\n\n          if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\n            toPush.x = pos.x;\n            toPush.y = pos.y;\n          }\n\n          _this3.setState(function (prevState) {\n            return {\n              texts: [].concat(_toConsumableArray(prevState.texts), [toPush])\n            };\n          }); //we can also just get element by this.refs.toPush.ref\n          //  let text = stage.findOne(\".\" + toPush.name);\n\n\n          var text = _this3.refs[toPush.ref]; //this.setState({firstTimeTextEditing: true});\n\n          text.fire(\"dblclick\");\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1718\n        },\n        __self: this\n      }))), React.createElement(\"textarea\", {\n        ref: \"textarea\",\n        id: \"textarea\",\n        value: this.state.text,\n        onChange: function onChange(e) {\n          _this3.setState({\n            text: e.target.value,\n            shouldTextUpdate: false\n          });\n        },\n        onKeyDown: function onKeyDown(e) {\n          if (e.keyCode === 13) {\n            _this3.setState({\n              textEditVisible: false,\n              shouldTextUpdate: true\n            }); // get the current textNode we are editing, get the name from there\n            //match name with elements in this.state.texts,\n\n\n            var node = _this3.refs[_this3.state.currentTextRef];\n            console.log(\"node width before set\", node.textWidth);\n            var name = node.attrs.name;\n\n            _this3.setState(function (prevState) {\n              return {\n                selectedShapeName: name,\n                texts: prevState.texts.map(function (eachText) {\n                  return eachText.name === name ? _objectSpread({}, eachText, {\n                    text: _this3.state.text\n                  }) : eachText;\n                })\n              };\n            }, function () {\n              _this3.setState(function (prevState) {\n                return {\n                  texts: prevState.texts.map(function (eachText) {\n                    return eachText.name === name ? _objectSpread({}, eachText, {\n                      textWidth: node.textWidth,\n                      textHeight: node.textHeight\n                    }) : eachText;\n                  })\n                };\n              });\n            });\n\n            node.show();\n\n            _this3.refs.graphicStage.findOne(\".transformer\").show();\n          }\n        },\n        onBlur: function onBlur() {\n          _this3.setState({\n            textEditVisible: false,\n            shouldTextUpdate: true\n          }); // get the current textNode we are editing, get the name from there\n          //match name with elements in this.state.texts,\n\n\n          var node = _this3.refs.graphicStage.findOne(\".\" + _this3.state.currentTextRef);\n\n          var name = node.attrs.name;\n\n          _this3.setState(function (prevState) {\n            return {\n              selectedShapeName: name,\n              texts: prevState.texts.map(function (eachText) {\n                return eachText.name === name ? _objectSpread({}, eachText, {\n                  text: _this3.state.text\n                }) : eachText;\n              })\n            };\n          }, function () {\n            _this3.setState(function (prevState) {\n              return {\n                texts: prevState.texts.map(function (eachText) {\n                  return eachText.name === name ? _objectSpread({}, eachText, {\n                    textWidth: node.textWidth,\n                    textHeight: node.textHeight\n                  }) : eachText;\n                })\n              };\n            });\n          });\n\n          node.show();\n\n          _this3.refs.graphicStage.findOne(\".transformer\").show();\n\n          _this3.refs.graphicStage.draw();\n        },\n        style: {\n          //set position, width, height, fontSize, overflow, lineHeight, color\n          display: this.state.textEditVisible ? \"block\" : \"none\",\n          position: \"absolute\",\n          top: this.state.textY + 80 + \"px\",\n          left: this.state.textX + \"px\",\n          width: \"300px\",\n          height: \"300px\",\n          overflow: \"hidden\",\n          fontSize: this.state.textareaFontSize,\n          fontFamily: this.state.textareaFontFamily,\n          color: this.state.textareaFill,\n          border: \"none\",\n          padding: \"0px\",\n          margin: \"0px\",\n          outline: \"none\",\n          resize: \"none\",\n          background: \"none\"\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1920\n        },\n        __self: this\n      }), React.createElement(\"div\", {\n        className: \"errMsg\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 2037\n        },\n        __self: this\n      }, errDisplay)));\n    }\n  }]);\n\n  return Graphics;\n}(Component);\n\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    auth: state.auth\n  };\n};\n\nexport default Graphics;","map":{"version":3,"sources":["C:\\Users\\andre\\Desktop\\Great React Projects\\livesearch\\src\\App.js"],"names":["React","Component","Stage","Layer","Rect","Transformer","Ellipse","Star","Text","Arrow","Connector","Toolbar","TransformerComponent","checkNode","stage","transformer","getStage","selectedShapeName","props","detach","selectedNode","findOne","node","attachTo","getLayer","batchDraw","includes","stuff","oldBox","newBox","width","Math","max","history","historyStep","Graphics","handleSave","rects","state","rectangles","ellipses","stars","texts","arrows","JSON","stringify","saved","setState","arrows1","forEach","eachArrow","from","attrs","name","textWidth","textHeight","to","roadmapId","saving","fetch","method","headers","body","data","then","res","userId","auth","user","id","roadmapType","json","handleStageClick","e","pos","refs","layer2","getPointerPosition","shape","getIntersection","console","log","undefined","graphicStage","draw","newArrowRef","previousShape","map","fill","stroke","arrowDraggable","handleMouseOver","event","link","document","style","cursor","transform","getAbsoluteTransform","copy","invert","point","arrowEndX","x","arrowEndY","y","forceUpdate","index","indexOf","currentArrow","points","handleUndo","isTransforming","textEditVisible","connectors","redoing","shapeIsGone","handleRedo","length","next","returnTo","toReturn","currentShapeName","eachRect","eachEllipse","eachStar","eachText","IsJsonString","str","parse","layerX","layerY","layerScale","errMsg","currentTextRef","shouldTextUpdate","textX","textY","count","newArrowDropped","newConnectorDropped","lastFill","alreadyCreated","publishing","title","category","description","thumbnail","isPasteDisabled","ellipseDeleteCount","starDeleteCount","arrowDeleteCount","textDeleteCount","rectDeleteCount","handleWheel","bind","evt","preventDefault","scaleBy","layer","oldScale","scaleX","mousePointTo","newScale","deltaY","scale","prevProps","prevState","prevMainShapes","currentMainShapes","uh","slice","toAppend","concat","push","saveText","color","canvas","createElement","ctx","getContext","gradient","createLinearGradient","addColorStop","errDisplay","countryOptions","key","value","text","deleteKey","paste","z","ctrlKey","keyCode","that","rectDeleted","ellipseDeleted","starDeleted","arrowDeleted","textDeleted","filter","shiftKey","copiedElement","toPush","height","strokeWidth","ref","useImage","rotation","newName","setTimeout","radiusX","radiusY","innerRadius","outerRadius","fontSize","fontFamily","outline","window","innerHeight","innerWidth","rect","setAttr","lastRotation","scaleY","target","ellipse","numPoints","star","currentText","eachtext","absolutePosition","textNode","textareaWidth","textareaHeight","textareaFill","textareaFontFamily","textareaFontSize","textarea","focus","hide","oldPoints","shiftX","shiftY","newPoints","position","eachArr","newArrow","fire","show","display","top","left","overflow","border","padding","margin","resize","background","mapStateToProps"],"mappings":"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","sourcesContent":["//todo: allow for picture inside of rect/ellipse/stfar\r\n//todo: connect using arrow\r\n//todo: for rightToolBar, show fontSize,fontFamily for text for the rest allow to add pictures\r\n//todo: zoomable\r\nimport React, { Component } from \"react\";\r\n\r\nimport {\r\n  Stage,\r\n  Layer,\r\n  Rect,\r\n  Transformer,\r\n  Ellipse,\r\n  Star,\r\n  Text,\r\n  Arrow\r\n} from \"react-konva\";\r\nimport Connector from \"./Connector.jsx\";\r\nimport Toolbar from \"./Toolbar.js\";\r\n\r\nimport \"./Graphics.css\";\r\n\r\nclass TransformerComponent extends React.Component {\r\n  componentDidMount() {\r\n    this.checkNode();\r\n  }\r\n  componentDidUpdate() {\r\n    this.checkNode();\r\n  }\r\n  checkNode() {\r\n    const stage = this.transformer.getStage();\r\n\r\n    const { selectedShapeName } = this.props;\r\n    if (selectedShapeName === \"\") {\r\n      this.transformer.detach();\r\n      return;\r\n    }\r\n    const selectedNode = stage.findOne(\".\" + selectedShapeName);\r\n    if (selectedNode === this.transformer.node()) {\r\n      return;\r\n    }\r\n\r\n    if (selectedNode) {\r\n      this.transformer.attachTo(selectedNode);\r\n    } else {\r\n      this.transformer.detach();\r\n    }\r\n    this.transformer.getLayer().batchDraw();\r\n  }\r\n  render() {\r\n    if (this.props.selectedShapeName.includes(\"text\")) {\r\n      var stuff = (\r\n        <Transformer\r\n          ref={node => {\r\n            this.transformer = node;\r\n          }}\r\n          name=\"transformer\"\r\n          boundBoxFunc={(oldBox, newBox) => {\r\n            newBox.width = Math.max(30, newBox.width);\r\n            return newBox;\r\n          }}\r\n          enabledAnchors={[\"middle-left\", \"middle-right\"]}\r\n        />\r\n      );\r\n    } else if (this.props.selectedShapeName.includes(\"star\")) {\r\n      var stuff = (\r\n        <Transformer\r\n          ref={node => {\r\n            this.transformer = node;\r\n          }}\r\n          name=\"transformer\"\r\n          enabledAnchors={[\r\n            \"top-left\",\r\n            \"top-right\",\r\n            \"bottom-left\",\r\n            \"bottom-right\"\r\n          ]}\r\n        />\r\n      );\r\n    } else if (this.props.selectedShapeName.includes(\"arrow\")) {\r\n      var stuff = (\r\n        <Transformer\r\n          ref={node => {\r\n            this.transformer = node;\r\n          }}\r\n          name=\"transformer\"\r\n          resizeEnabled={false}\r\n          rotateEnabled={false}\r\n        />\r\n      );\r\n    } else {\r\n      var stuff = (\r\n        <Transformer\r\n          ref={node => {\r\n            this.transformer = node;\r\n          }}\r\n          name=\"transformer\"\r\n          keepRatio={true}\r\n        />\r\n      );\r\n    }\r\n    return stuff;\r\n  }\r\n}\r\n\r\nvar history = [];\r\nvar historyStep = 0;\r\n\r\nclass Graphics extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      layerX: 0,\r\n      layerY: 0,\r\n      layerScale: 1,\r\n      selectedShapeName: \"\",\r\n      errMsg: \"\",\r\n      rectangles: [],\r\n      ellipses: [],\r\n      stars: [],\r\n      texts: [],\r\n      arrows: [],\r\n      connectors: [],\r\n      currentTextRef: \"\",\r\n      shouldTextUpdate: true,\r\n      textX: 0,\r\n      textY: 0,\r\n      textEditVisible: false,\r\n      arrowDraggable: false,\r\n      newArrowRef: \"\",\r\n      count: 0,\r\n      newArrowDropped: false,\r\n      newConnectorDropped: false,\r\n      arrowEndX: 0,\r\n      arrowEndY: 0,\r\n      isTransforming: false,\r\n      lastFill: null,\r\n\r\n      saving: null,\r\n      saved: [],\r\n      roadmapId: null,\r\n      alreadyCreated: false,\r\n      publishing: false,\r\n      title: \"\",\r\n      category: \"\",\r\n      description: \"\",\r\n      thumbnail: \"\",\r\n      isPasteDisabled: false,\r\n      ellipseDeleteCount: 0,\r\n      starDeleteCount: 0,\r\n      arrowDeleteCount: 0,\r\n      textDeleteCount: 0,\r\n      rectDeleteCount: 0\r\n    };\r\n\r\n    this.handleWheel = this.handleWheel.bind(this);\r\n\r\n  }\r\n\r\n  handleSave = () => {\r\n    const rects = this.state.rectangles,\r\n      ellipses = this.state.ellipses,\r\n      stars = this.state.stars,\r\n      texts = this.state.texts,\r\n      arrows = this.state.arrows;\r\n    if (\r\n      JSON.stringify(this.state.saved) !==\r\n      JSON.stringify([rects, ellipses, stars, texts, arrows])\r\n    ) {\r\n      this.setState({ saved: [rects, ellipses, stars, texts, arrows] });\r\n\r\n      let arrows1 = this.state.arrows;\r\n      arrows1.forEach(eachArrow => {\r\n        //for \"from & to of each arrow\"\r\n        if (eachArrow.from && eachArrow.from.attrs) {\r\n          if (eachArrow.from.attrs.name.includes(\"text\")) {\r\n            eachArrow.from.textWidth = eachArrow.from.textWidth;\r\n\r\n            eachArrow.from.textHeight = eachArrow.from.textHeight;\r\n          }\r\n        }\r\n        if (eachArrow.to && eachArrow.to.attrs) {\r\n          if (eachArrow.to.attrs.name.includes(\"text\")) {\r\n            eachArrow.to.attrs.textWidth = eachArrow.to.textWidth;\r\n            eachArrow.to.attrs.textHeight = eachArrow.to.textHeight;\r\n          }\r\n        }\r\n      });\r\n\r\n      if (this.state.roadmapId) {\r\n        //if draft already exists\r\n        this.setState({ saving: true });\r\n        fetch(\"/api/roadmap/modifyDraftDB\", {\r\n          method: \"POST\",\r\n          headers: { \"Content-Type\": \"application/json\" },\r\n          body: JSON.stringify({\r\n            roadmapId: this.state.roadmapId,\r\n\r\n            data: {\r\n              rects: rects,\r\n              ellipses: ellipses,\r\n              stars: stars,\r\n              texts: texts,\r\n              arrows: arrows1\r\n            }\r\n          })\r\n        }).then(res => {\r\n          this.setState({ saving: false });\r\n        });\r\n      } else {\r\n        //if first time pressing sav\r\n        this.setState({ saving: true });\r\n        fetch(\"/api/roadmap/saveRoadmapToDB\", {\r\n          method: \"POST\",\r\n          headers: { \"Content-Type\": \"application/json\" },\r\n          body: JSON.stringify({\r\n            userId: this.props.auth.user.id,\r\n            roadmapType: \"draft\",\r\n            data: {\r\n              rects: rects,\r\n              ellipses: ellipses,\r\n              stars: stars,\r\n              texts: texts,\r\n              arrows: arrows\r\n            }\r\n          })\r\n        }).then(res =>\r\n          res.json().then(data => {\r\n            this.setState({ saving: false });\r\n            this.setState({ roadmapId: data.roadmapId });\r\n          })\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  handleStageClick = e => {\r\n    var pos = this.refs.layer2.getStage().getPointerPosition();\r\n    var shape = this.refs.layer2.getIntersection(pos);\r\n\r\n    console.log(\"texts\", this.state.texts);\r\n\r\n    if (\r\n      shape !== null &&\r\n      shape.name() !== undefined &&\r\n      shape !== undefined &&\r\n      shape.name() !== undefined\r\n    ) {\r\n      this.setState(\r\n        {\r\n          selectedShapeName: shape.name()\r\n        },\r\n        () => {\r\n          this.refs.graphicStage.draw();\r\n        }\r\n      );\r\n    }\r\n\r\n    //arrow logic\r\n    if (this.state.newArrowRef !== \"\") {\r\n      if (this.state.previousShape) {\r\n        if (this.state.previousShape.attrs.id !== \"ContainerRect\") {\r\n          //console.log(this.refs.graphicStage.findOne(\".\" + this.state.newArrowRef));\r\n          //\r\n\r\n          this.state.arrows.map(eachArrow => {\r\n            if (eachArrow.name === this.state.newArrowRef) {\r\n              eachArrow.to = this.state.previousShape;\r\n            }\r\n          });\r\n\r\n          //console.log(newConnector, this.state.newArrowRef);\r\n          //newConnector.setAttr(\"to\", this.state.previousShape);\r\n          //console.log(newConnector);\r\n        }\r\n      }\r\n\r\n      //handle connector more\r\n      //if the currentArrow ref has a from, and that e.target.attrs.id isn't containerRect,\r\n      //then find the current shape with stage find name and then yeah\r\n      this.state.arrows.map(eachArrow => {\r\n        if (eachArrow.name === this.state.newArrowRef) {\r\n          eachArrow.fill = \"black\";\r\n          eachArrow.stroke = \"black\";\r\n        }\r\n      });\r\n      //arrow logic, there's e.evt.pageX, pageY\r\n      this.setState({\r\n        arrowDraggable: false,\r\n        newArrowRef: \"\"\r\n      });\r\n    }\r\n  };\r\n  handleMouseOver = event => {\r\n    //get the currennt arrow ref and modify its position by filtering & pushing again\r\n    //console.log(\"lastFill: \", this.state.lastFill);\r\n    var pos = this.refs.graphicStage.getPointerPosition();\r\n    var shape = this.refs.graphicStage.getIntersection(pos);\r\n\r\n    if (shape && shape.attrs.link) {\r\n      document.body.style.cursor = \"pointer\";\r\n    } else {\r\n      document.body.style.cursor = \"default\";\r\n    }\r\n\r\n    //if we are moving an arrow\r\n    if (this.state.newArrowRef !== \"\") {\r\n      //filling color logic:\r\n\r\n      var transform = this.refs.layer2.getAbsoluteTransform().copy();\r\n      transform.invert();\r\n\r\n      pos = transform.point(pos);\r\n      this.setState({ arrowEndX: pos.x, arrowEndY: pos.y });\r\n      //last non arrow object\r\n      if (shape && shape.attrs && shape.attrs.name != undefined) {\r\n        //  console.log(shape);\r\n        if (!shape.attrs.name.includes(\"arrow\")) {\r\n          //after first frame\r\n          if (this.state.previousShape)\r\n            if (this.state.previousShape !== shape) {\r\n              //arrow entered a new shape\r\n\r\n              //set current arrow to blue\r\n              if (this.state.previousShape.attrs.id !== \"ContainerRect\") {\r\n                this.state.arrows.map(eachArrow => {\r\n                  if (eachArrow.name === this.state.newArrowRef) {\r\n                    eachArrow.fill = \"black\";\r\n                    eachArrow.stroke = \"black\";\r\n                  }\r\n                });\r\n                this.forceUpdate();\r\n              } else {\r\n                this.state.arrows.map(eachArrow => {\r\n                  if (eachArrow.name === this.state.newArrowRef) {\r\n                    eachArrow.fill = \"#ccf5ff\";\r\n                    eachArrow.stroke = \"#ccf5ff\";\r\n                  }\r\n                });\r\n                this.forceUpdate();\r\n              }\r\n            }\r\n          //if arrow is moving in a single shape\r\n        }\r\n\r\n        if (!shape.attrs.name.includes(\"arrow\")) {\r\n          this.setState({ previousShape: shape });\r\n        }\r\n      }\r\n    }\r\n    var arrows = this.state.arrows;\r\n\r\n    arrows.map(eachArrow => {\r\n      if (eachArrow.name === this.state.newArrowRef) {\r\n        var index = arrows.indexOf(eachArrow);\r\n        let currentArrow = eachArrow;\r\n        currentArrow.points = [\r\n          currentArrow.points[0],\r\n          currentArrow.points[1],\r\n          pos.x,\r\n          pos.y\r\n          /*  event.evt.pageY -\r\n            document.getElementById(\"NavBar\").getBoundingClientRect().height */\r\n        ];\r\n\r\n        this.state.arrows[index] = currentArrow;\r\n      }\r\n    });\r\n  };\r\n  handleWheel(event) {\r\n    if (\r\n      this.state.rectangles.length === 0 &&\r\n      this.state.ellipses.length === 0 &&\r\n      this.state.stars.length === 0 &&\r\n      this.state.texts.length === 0 &&\r\n      this.state.arrows.length === 0\r\n    ) {\r\n    } else {\r\n      event.evt.preventDefault();\r\n      const scaleBy = 1.2;\r\n      const stage = this.refs.graphicStage;\r\n      const layer = this.refs.layer2;\r\n      const oldScale = layer.scaleX();\r\n      const mousePointTo = {\r\n        x:\r\n          stage.getPointerPosition().x / oldScale -\r\n          this.state.layerX / oldScale,\r\n        y:\r\n          stage.getPointerPosition().y / oldScale - this.state.layerY / oldScale\r\n      };\r\n\r\n      const newScale =\r\n        event.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy;\r\n\r\n      layer.scale({ x: newScale, y: newScale });\r\n\r\n      /*  console.log(\r\n        oldScale,\r\n        mousePointTo,\r\n        stage.getPointerPosition().x,\r\n        stage.getPointerPosition().y\r\n      );\r\n    */\r\n      this.setState({\r\n        layerScale: newScale,\r\n        layerX:\r\n          -(mousePointTo.x - stage.getPointerPosition().x / newScale) *\r\n          newScale,\r\n        layerY:\r\n          -(mousePointTo.y - stage.getPointerPosition().y / newScale) * newScale\r\n      });\r\n    }\r\n  }\r\n  componentDidUpdate(prevProps, prevState) {\r\n    let prevMainShapes = [\r\n      prevState.rectangles,\r\n      prevState.ellipses,\r\n      prevState.stars,\r\n      prevState.arrows,\r\n      prevState.connectors,\r\n      prevState.texts\r\n    ];\r\n    let currentMainShapes = [\r\n      this.state.rectangles,\r\n      this.state.ellipses,\r\n      this.state.stars,\r\n      this.state.arrows,\r\n      this.state.connectors,\r\n      this.state.texts\r\n    ];\r\n\r\n    if (!this.state.redoing && !this.state.isTransforming)\r\n      if (JSON.stringify(this.state) !== JSON.stringify(prevState)) {\r\n        if (\r\n          JSON.stringify(prevMainShapes) !== JSON.stringify(currentMainShapes)\r\n        ) {\r\n          //if text shouldn't update, don't append to  history\r\n          if (this.state.shouldTextUpdate) {\r\n            var uh = history;\r\n            history = uh.slice(0, historyStep + 1);\r\n            //console.log(\"sliced\", history);\r\n            var toAppend = this.state;\r\n            history = history.concat(toAppend);\r\n            //console.log(\"new\", history);\r\n            historyStep += 1;\r\n            //console.log(history, historyStep, history[historyStep]);\r\n          }\r\n        }\r\n      } else {\r\n        //console.log(\"compoenntDidUpdate but attrs didn't change\");\r\n      }\r\n    this.state.redoing = false;\r\n  }\r\n\r\n  handleUndo = () => {\r\n    if (!this.state.isTransforming) {\r\n      if (!this.state.textEditVisible) {\r\n        if (historyStep === 0) {\r\n          return;\r\n        }\r\n        historyStep -= 1;\r\n\r\n        this.setState(\r\n          {\r\n            rectangles: history[historyStep].rectangles,\r\n            arrows: history[historyStep].arrows,\r\n            ellipses: history[historyStep].ellipses,\r\n            stars: history[historyStep].stars,\r\n            texts: history[historyStep].texts,\r\n            connectors: history[historyStep].connectors,\r\n            redoing: true,\r\n            selectedShapeName: this.shapeIsGone(history[historyStep])\r\n              ? \"\"\r\n              : this.state.selectedShapeName\r\n          },\r\n          () => {\r\n            this.refs.graphicStage.draw();\r\n          }\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  handleRedo = () => {\r\n    if (historyStep === history.length - 1) {\r\n      return;\r\n    }\r\n    historyStep += 1;\r\n    const next = history[historyStep];\r\n    this.setState(\r\n      {\r\n        rectangles: next.rectangles,\r\n        arrows: next.arrows,\r\n        ellipses: next.ellipses,\r\n        stars: next.stars,\r\n        texts: next.texts,\r\n        redoing: true,\r\n        selectedShapeName: this.shapeIsGone(history[historyStep])\r\n          ? \"\"\r\n          : this.state.selectedShapeName\r\n      },\r\n      () => {\r\n        this.forceUpdate();\r\n      }\r\n    );\r\n  };\r\n\r\n  shapeIsGone = returnTo => {\r\n    var toReturn = true;\r\n    let currentShapeName = this.state.selectedShapeName;\r\n    let [rectangles, ellipses, stars, arrows, texts] = [\r\n      returnTo.rectangles,\r\n      returnTo.ellipses,\r\n      returnTo.stars,\r\n      returnTo.arrows,\r\n\r\n      returnTo.texts\r\n    ];\r\n    rectangles.map(eachRect => {\r\n      if (eachRect.name === currentShapeName) {\r\n        toReturn = false;\r\n      }\r\n    });\r\n    ellipses.map(eachEllipse => {\r\n      if (eachEllipse.name === currentShapeName) {\r\n        toReturn = false;\r\n      }\r\n    });\r\n    stars.map(eachStar => {\r\n      if (eachStar.name === currentShapeName) {\r\n        toReturn = false;\r\n      }\r\n    });\r\n    arrows.map(eachArrow => {\r\n      if (eachArrow.name === currentShapeName) {\r\n        toReturn = false;\r\n      }\r\n    });\r\n\r\n    texts.map(eachText => {\r\n      if (eachText.name === currentShapeName) {\r\n        toReturn = false;\r\n      }\r\n    });\r\n\r\n    return toReturn;\r\n  };\r\n  IsJsonString = str => {\r\n    try {\r\n      JSON.parse(str);\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n\r\n  async componentDidMount() {\r\n    history.push(this.state);\r\n    this.setState({ selectedShapeName: \"\" });\r\n\r\n\r\n\r\n    //if draft\r\n\r\n  }\r\n\r\n  render() {\r\n    let saveText;\r\n\r\n    let saving = this.state.saving;\r\n    if (saving !== null) {\r\n      if (saving) {\r\n        saveText = <div style={{ color: \"white\" }}>Saving</div>;\r\n      } else {\r\n        saveText = <div style={{ color: \"white\" }}>Saved</div>;\r\n      }\r\n    }\r\n\r\n    const canvas = document.createElement(\"canvas\");\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    var gradient = ctx.createLinearGradient(0, 0, 100, 100);\r\n    gradient.addColorStop(0.0, \"red\");\r\n    gradient.addColorStop(1 / 6, \"orange\");\r\n    gradient.addColorStop(2 / 6, \"yellow\");\r\n    gradient.addColorStop(3 / 6, \"green\");\r\n    gradient.addColorStop(4 / 6, \"aqua\");\r\n    gradient.addColorStop(5 / 6, \"blue\");\r\n    gradient.addColorStop(1.0, \"purple\");\r\n\r\n    const errMsg = this.state.errMsg;\r\n    let errDisplay;\r\n    if (errMsg !== \"\") {\r\n      errDisplay = (\r\n        <div className=\"errMsginner\">\r\n          <span style={{ color: \"white\" }}>\r\n            {errMsg !== \"\" ? errMsg : null}\r\n          </span>\r\n        </div>\r\n      );\r\n    } else {\r\n    }\r\n\r\n    const countryOptions = [\r\n      { key: \"1\", value: \"Machine Learning\", text: \"Machine Learning\" },\r\n      { key: \"2\", value: \"Computer Science\", text: \"Computer Science\" },\r\n      {\r\n        key: \"3\",\r\n        value: \"Software Engineering\",\r\n        text: \"Software Engineering\"\r\n      },\r\n      { key: \"12\", value: \"Technology\", text: \"Technology\" },\r\n      { key: \"4\", value: \"Engineering\", text: \"Engineering\" },\r\n\r\n      {\r\n        key: \"6\",\r\n        value: \"Sciences and Mathematics\",\r\n        text: \"Sciences and Mathematics\"\r\n      },\r\n      {\r\n        key: \"7\",\r\n        value: \"Law, Economics and Social Sciences\",\r\n        text: \"Law, Economics and Social Sciences\"\r\n      },\r\n      { key: \"8\", value: \"Humanities\", text: \"Humanities\" },\r\n      {\r\n        key: \"9\",\r\n        value: \"Linguistics and Cultural Studies\",\r\n        text: \"Linguistics and Cultural Studies\"\r\n      },\r\n      { key: \"10\", value: \"Art and Music\", text: \"Art and Music\" },\r\n      { key: \"11\", value: \"Lifestyle\", text: \"Lifestyle\" },\r\n      {\r\n        key: \"13\",\r\n        value: \"Others\",\r\n        text: \"Others\"\r\n      }\r\n    ];\r\n\r\n    return (\r\n      <React.Fragment>\r\n        <div\r\n          onKeyDown={event => {\r\n            const x = 88,\r\n              deleteKey = 46,\r\n              copy = 67,\r\n              paste = 86,\r\n              z = 90,\r\n              y = 89;\r\n\r\n            if (\r\n              ((event.ctrlKey && event.keyCode === x) ||\r\n                event.keyCode === deleteKey) &&\r\n              !this.state.isPasteDisabled\r\n            ) {\r\n              if (this.state.selectedShapeName !== \"\") {\r\n                var that = this;\r\n                //delete it from the state too\r\n                let name = this.state.selectedShapeName;\r\n                let rectDeleted = false,\r\n                  ellipseDeleted = false,\r\n                  starDeleted = false,\r\n                  arrowDeleted = false,\r\n                  textDeleted = false;\r\n\r\n                var rects = this.state.rectangles.filter(function(eachRect) {\r\n                  if (eachRect.name === name) {\r\n                    that.setState({\r\n                      rectDeleteCount: that.state.rectDeleteCount + 1\r\n                    });\r\n                  }\r\n                  return eachRect.name !== name;\r\n                });\r\n\r\n                var ellipses = this.state.ellipses.filter(function(eachRect) {\r\n                  if (eachRect.name === name) {\r\n                    that.setState({\r\n                      ellipseDeleteCount: that.state.ellipseDeleteCount + 1\r\n                    });\r\n                  }\r\n                  return eachRect.name !== name;\r\n                });\r\n\r\n                var stars = this.state.stars.filter(function(eachRect) {\r\n                  if (eachRect.name === name) {\r\n                    that.setState({\r\n                      starDeleteCount: that.state.starDeleteCount + 1\r\n                    });\r\n                  }\r\n                  return eachRect.name !== name;\r\n                });\r\n\r\n                var arrows = this.state.arrows.filter(function(eachRect) {\r\n                  if (eachRect.name === name) {\r\n                    that.setState({\r\n                      arrowDeleteCount: that.state.arrowDeleteCount + 1\r\n                    });\r\n                  }\r\n                  return eachRect.name !== name;\r\n                });\r\n\r\n                var texts = this.state.texts.filter(function(eachRect) {\r\n                  if (eachRect.name === name) {\r\n                    that.setState({\r\n                      textDeleteCount: that.state.textDeleteCount + 1\r\n                    });\r\n                  }\r\n                  return eachRect.name !== name;\r\n                });\r\n\r\n                this.setState({\r\n                  rectangles: rects,\r\n                  ellipses: ellipses,\r\n                  stars: stars,\r\n                  arrows: arrows,\r\n                  texts: texts,\r\n                  selectedShapeName: \"\"\r\n                });\r\n              }\r\n            } else if (event.shiftKey && event.ctrlKey && event.keyCode === z) {\r\n              this.handleRedo();\r\n            } else if (event.ctrlKey && event.keyCode === z) {\r\n              this.handleUndo();\r\n            } else if (event.ctrlKey && event.keyCode === y) {\r\n              this.handleRedo();\r\n            } else if (event.ctrlKey && event.keyCode === copy) {\r\n              if (this.state.selectedShapeName !== \"\") {\r\n                //find it\r\n                let name = this.state.selectedShapeName;\r\n                let copiedElement = null;\r\n                if (name.includes(\"rect\")) {\r\n                  copiedElement = this.state.rectangles.filter(function(\r\n                    eachRect\r\n                  ) {\r\n                    return eachRect.name === name;\r\n                  });\r\n                } else if (name.includes(\"ellipse\")) {\r\n                  copiedElement = this.state.ellipses.filter(function(\r\n                    eachRect\r\n                  ) {\r\n                    return eachRect.name === name;\r\n                  });\r\n                } else if (name.includes(\"star\")) {\r\n                  copiedElement = this.state.stars.filter(function(eachRect) {\r\n                    return eachRect.name === name;\r\n                  });\r\n                } else if (name.includes(\"text\")) {\r\n                  copiedElement = this.state.texts.filter(function(eachRect) {\r\n                    return eachRect.name === name;\r\n                  });\r\n                } else if (name.includes(\"arrow\")) {\r\n                  copiedElement = this.state.arrows.filter(function(eachRect) {\r\n                    return eachRect.name === name;\r\n                  });\r\n                }\r\n\r\n                this.setState({ copiedElement: copiedElement }, () => {\r\n                  console.log(\"copied ele\", this.state.copiedElement);\r\n                });\r\n              }\r\n            } else if (\r\n              event.ctrlKey &&\r\n              event.keyCode === paste &&\r\n              !this.state.isPasteDisabled\r\n            ) {\r\n              let copiedElement = this.state.copiedElement[0];\r\n              console.log(copiedElement);\r\n              var length;\r\n              if (copiedElement) {\r\n                if (copiedElement.attrs) {\r\n                } else {\r\n                  if (copiedElement.name.includes(\"rectangle\")) {\r\n                    length =\r\n                      this.state.rectangles.length +\r\n                      1 +\r\n                      this.state.rectDeleteCount;\r\n                    var toPush = {\r\n                      x: copiedElement.x + 10,\r\n                      y: copiedElement.y + 10,\r\n                      width: copiedElement.width,\r\n                      height: copiedElement.height,\r\n                      stroke: copiedElement.stroke,\r\n                      strokeWidth: copiedElement.strokeWidth,\r\n                      name:\r\n                        \"rectangle\" +\r\n                        (this.state.rectangles.length +\r\n                          this.state.rectDeleteCount +\r\n                          1),\r\n                      ref:\r\n                        \"rectangle\" +\r\n                        (this.state.rectangles.length +\r\n                          this.state.rectDeleteCount +\r\n                          1),\r\n                      fill: copiedElement.fill,\r\n                      useImage: copiedElement.useImage,\r\n                      link: copiedElement.link,\r\n                      rotation: copiedElement.rotation\r\n                    };\r\n                    let newName = this.state.selectedShapeName;\r\n\r\n                    this.setState(\r\n                      prevState => ({\r\n                        rectangles: [...prevState.rectangles, toPush]\r\n                      }),\r\n                      () => {\r\n                        this.setState({\r\n                          selectedShapeName:\r\n                            \"rectangle\" + this.state.rectangles.length\r\n                        });\r\n                      }\r\n                    );\r\n                  } else if (copiedElement.name.includes(\"arrow\")) {\r\n                    length =\r\n                      this.state.arrows.length +\r\n                      1 +\r\n                      this.state.arrowDeleteCount;\r\n\r\n                    if (copiedElement.to || copiedElement.from) {\r\n                      this.setState(\r\n                        {\r\n                          errMsg: \"Connectors cannot be pasted\"\r\n                        },\r\n                        () => {\r\n                          var that = this;\r\n                          setTimeout(function() {\r\n                            that.setState({\r\n                              errMsg: \"\"\r\n                            });\r\n                          }, 1000);\r\n                        }\r\n                      );\r\n                    } else {\r\n                      var toPush = {\r\n                        points: [\r\n                          copiedElement.points[0] + 30,\r\n                          copiedElement.points[1] + 30,\r\n                          copiedElement.points[2] + 30,\r\n                          copiedElement.points[3] + 30\r\n                        ],\r\n                        fill: copiedElement.fill,\r\n                        link: copiedElement.link,\r\n                        stroke: copiedElement.stroke,\r\n                        strokeWidth: copiedElement.strokeWidth,\r\n                        name:\r\n                          \"arrow\" +\r\n                          (this.state.arrows.length +\r\n                            1 +\r\n                            this.state.arrowDeleteCount),\r\n                        ref:\r\n                          \"arrow\" +\r\n                          (this.state.arrows.length +\r\n                            1 +\r\n                            this.state.arrowDeleteCount),\r\n                        rotation: copiedElement.rotation\r\n                      };\r\n\r\n                      let newName = this.state.selectedShapeName;\r\n\r\n                      this.setState(\r\n                        prevState => ({\r\n                          arrows: [...prevState.arrows, toPush]\r\n                        }),\r\n                        () => {\r\n                          this.setState({\r\n                            selectedShapeName:\r\n                              \"arrow\" + this.state.arrows.length\r\n                          });\r\n                        }\r\n                      );\r\n                    }\r\n                  } else if (copiedElement.name.includes(\"ellipse\")) {\r\n                    length =\r\n                      this.state.ellipses.length +\r\n                      1 +\r\n                      this.state.ellipseDeleteCount;\r\n                    var toPush = {\r\n                      x: copiedElement.x + 10,\r\n                      y: copiedElement.y + 10,\r\n                      radiusX: copiedElement.radiusX,\r\n                      radiusY: copiedElement.radiusY,\r\n                      stroke: copiedElement.stroke,\r\n                      strokeWidth: copiedElement.strokeWidth,\r\n                      name:\r\n                        \"ellipse\" +\r\n                        (this.state.ellipses.length +\r\n                          1 +\r\n                          this.state.ellipseDeleteCount),\r\n                      ref:\r\n                        \"ellipse\" +\r\n                        (this.state.ellipses.length +\r\n                          1 +\r\n                          this.state.ellipseDeleteCount),\r\n                      fill: copiedElement.fill,\r\n                      link: copiedElement.link,\r\n                      useImage: copiedElement.useImage,\r\n                      rotation: copiedElement.rotation\r\n                    };\r\n                    let newName = this.state.selectedShapeName;\r\n\r\n                    this.setState(\r\n                      prevState => ({\r\n                        ellipses: [...prevState.ellipses, toPush]\r\n                      }),\r\n                      () => {\r\n                        this.setState({\r\n                          selectedShapeName:\r\n                            \"ellipse\" + this.state.ellipses.length\r\n                        });\r\n                      }\r\n                    );\r\n                  } else if (copiedElement.name.includes(\"star\")) {\r\n                    length =\r\n                      this.state.stars.length + 1 + this.state.starDeleteCount;\r\n                    var toPush = {\r\n                      x: copiedElement.x + 10,\r\n                      y: copiedElement.y + 10,\r\n                      link: copiedElement.link,\r\n                      innerRadius: copiedElement.innerRadius,\r\n                      outerRadius: copiedElement.outerRadius,\r\n                      stroke: copiedElement.stroke,\r\n                      strokeWidth: copiedElement.strokeWidth,\r\n                      name:\r\n                        \"star\" +\r\n                        (this.state.stars.length +\r\n                          1 +\r\n                          this.state.starDeleteCount),\r\n                      ref:\r\n                        \"star\" +\r\n                        (this.state.stars.length +\r\n                          1 +\r\n                          this.state.starDeleteCount),\r\n                      fill: copiedElement.fill,\r\n                      useImage: copiedElement.useImage,\r\n                      rotation: copiedElement.rotation\r\n                    };\r\n                    let newName = this.state.selectedShapeName;\r\n\r\n                    this.setState(\r\n                      prevState => ({\r\n                        stars: [...prevState.stars, toPush]\r\n                      }),\r\n                      () => {\r\n                        this.setState({\r\n                          selectedShapeName: \"star\" + this.state.stars.length\r\n                        });\r\n                      }\r\n                    );\r\n                  } else if (copiedElement.name.includes(\"text\")) {\r\n                    length =\r\n                      this.state.texts.length + 1 + this.state.textDeleteCount;\r\n                    var toPush = {\r\n                      x: copiedElement.x + 10,\r\n                      y: copiedElement.y + 10,\r\n                      link: copiedElement.link,\r\n\r\n                      name:\r\n                        \"text\" +\r\n                        (this.state.texts.length +\r\n                          1 +\r\n                          this.state.textDeleteCount),\r\n                      ref:\r\n                        \"text\" +\r\n                        (this.state.texts.length +\r\n                          1 +\r\n                          this.state.textDeleteCount),\r\n                      fill: copiedElement.fill,\r\n                      fontSize: copiedElement.fontSize,\r\n                      fontFamily: copiedElement.fontFamily,\r\n                      useImage: copiedElement.useImage,\r\n                      text: copiedElement.text,\r\n                      width: copiedElement.width,\r\n                      rotation: copiedElement.rotation\r\n                    };\r\n                    let newName = this.state.selectedShapeName;\r\n\r\n                    this.setState(\r\n                      prevState => ({\r\n                        texts: [...prevState.texts, toPush]\r\n                      }),\r\n                      () => {\r\n                        this.setState(\r\n                          {\r\n                            selectedShapeName:\r\n                              \"text\" +\r\n                              (this.state.texts.length +\r\n                                this.state.textDeleteCount)\r\n                          },\r\n                          () => {\r\n                            console.log(this.state.selectedShapeName);\r\n                          }\r\n                        );\r\n                      }\r\n                    );\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }}\r\n          tabIndex=\"0\"\r\n          style={{ outline: \"none\" }}\r\n        >\r\n          <Stage\r\n            onClick={this.handleStageClick}\r\n            onMouseMove={this.handleMouseOver}\r\n            onWheel={event => this.handleWheel(event)}\r\n            height={window.innerHeight}\r\n            width={window.innerWidth}\r\n            ref=\"graphicStage\"\r\n          >\r\n            <Layer\r\n              scaleX={this.state.layerScale}\r\n              scaleY={this.state.layerScale}\r\n              x={this.state.layerX}\r\n              y={this.state.layerY}\r\n              height={window.innerHeight}\r\n              width={window.innerWidth}\r\n              draggable\r\n              onDragEnd={() => {\r\n                this.setState({\r\n                  layerX: this.refs.layer2.x(),\r\n                  layerY: this.refs.layer2.y()\r\n                });\r\n              }}\r\n              ref=\"layer2\"\r\n            >\r\n              <Rect\r\n                x={-5 * window.innerWidth}\r\n                y={-5 * window.innerHeight}\r\n                height={window.innerHeight * 10}\r\n                width={window.innerWidth * 10}\r\n                name=\"\"\r\n                id=\"ContainerRect\"\r\n              />\r\n\r\n              {this.state.rectangles.map(eachRect => {\r\n                return (\r\n                  <Rect\r\n                    onClick={() => {\r\n                      var that = this;\r\n                      if (eachRect.link !== undefined && eachRect.link !== \"\") {\r\n                        this.setState(\r\n                          {\r\n                            errMsg: \"Links will not be opened in create mode\"\r\n                          },\r\n                          () => {\r\n                            setTimeout(function() {\r\n                              that.setState({\r\n                                errMsg: \"\"\r\n                              });\r\n                            }, 1000);\r\n                          }\r\n                        );\r\n                      }\r\n                    }}\r\n                    onTransformStart={() => {\r\n                      this.setState({\r\n                        isTransforming: true\r\n                      });\r\n                      let rect = this.refs[eachRect.ref];\r\n                      rect.setAttr(\"lastRotation\", rect.rotation());\r\n                    }}\r\n                    onTransform={() => {\r\n                      let rect = this.refs[eachRect.ref];\r\n\r\n                      if (rect.attrs.lastRotation !== rect.rotation()) {\r\n                        this.state.arrows.map(eachArrow => {\r\n                          if (\r\n                            eachArrow.to &&\r\n                            eachArrow.to.name() === rect.name()\r\n                          ) {\r\n                            this.setState({\r\n                              errMsg:\r\n                                \"Rotating rects with connectors might skew things up!\"\r\n                            });\r\n                          }\r\n                          if (\r\n                            eachArrow.from &&\r\n                            eachArrow.from.name() === rect.name()\r\n                          ) {\r\n                            this.setState({\r\n                              errMsg:\r\n                                \"Rotating rects with connectors might skew things up!\"\r\n                            });\r\n                          }\r\n                        });\r\n                      }\r\n\r\n                      rect.setAttr(\"lastRotation\", rect.rotation());\r\n                    }}\r\n                    onTransformEnd={() => {\r\n                      this.setState({\r\n                        isTransforming: false\r\n                      });\r\n                      let rect = this.refs[eachRect.ref];\r\n                      this.setState(\r\n                        prevState => ({\r\n                          errMsg: \"\",\r\n                          rectangles: prevState.rectangles.map(eachRect =>\r\n                            eachRect.name === rect.attrs.name\r\n                              ? {\r\n                                  ...eachRect,\r\n                                  width: rect.width() * rect.scaleX(),\r\n                                  height: rect.height() * rect.scaleY(),\r\n                                  rotation: rect.rotation(),\r\n                                  x: rect.x(),\r\n                                  y: rect.y()\r\n                                }\r\n                              : eachRect\r\n                          )\r\n                        }),\r\n                        () => {\r\n                          this.forceUpdate();\r\n                        }\r\n                      );\r\n\r\n                      rect.setAttr(\"scaleX\", 1);\r\n                      rect.setAttr(\"scaleY\", 1);\r\n                    }}\r\n                    rotation={eachRect.rotation}\r\n                    ref={eachRect.ref}\r\n                    fill={eachRect.fill}\r\n                    name={eachRect.name}\r\n                    x={eachRect.x}\r\n                    y={eachRect.y}\r\n                    width={eachRect.width}\r\n                    height={eachRect.height}\r\n                    stroke={eachRect.stroke}\r\n                    strokeWidth={eachRect.strokeWidth}\r\n                    strokeScaleEnabled={false}\r\n                    draggable\r\n                    onDragMove={() => {\r\n                      this.state.arrows.map(eachArrow => {\r\n                        if (eachArrow.from !== undefined) {\r\n                          if (eachRect.name === eachArrow.from.attrs.name) {\r\n                            eachArrow.points = [\r\n                              eachRect.x,\r\n                              eachRect.y,\r\n                              eachArrow.points[2],\r\n                              eachArrow.points[3]\r\n                            ];\r\n                            this.forceUpdate();\r\n                          }\r\n                        }\r\n\r\n                        if (eachArrow.to !== undefined) {\r\n                          if (eachRect.name == eachArrow.to.attrs.name) {\r\n                            eachArrow.points = [\r\n                              eachArrow.points[0],\r\n                              eachArrow.points[1],\r\n                              eachRect.x,\r\n                              eachRect.y\r\n                            ];\r\n                            this.forceUpdate();\r\n                          }\r\n                        }\r\n                      });\r\n                    }}\r\n                    onDragEnd={event => {\r\n                      //cannot compare by name because currentSelected might not be the same\r\n                      //have to use ref, which appears to be overcomplicated\r\n                      var shape = this.refs[eachRect.ref];\r\n                      /*    this.state.rectangles.map(eachRect => {\r\n                          if (eachRect.name === shape.attrs.name) {\r\n                            shape.position({\r\n                              x: event.target.x(),\r\n                              y: event.target.y()\r\n                            });\r\n                          }\r\n                        });*/\r\n\r\n                      this.setState(prevState => ({\r\n                        rectangles: prevState.rectangles.map(eachRect =>\r\n                          eachRect.name === shape.attrs.name\r\n                            ? {\r\n                                ...eachRect,\r\n                                x: event.target.x(),\r\n                                y: event.target.y()\r\n                              }\r\n                            : eachRect\r\n                        )\r\n                      }));\r\n                    }}\r\n                  />\r\n                );\r\n              })}\r\n              {this.state.ellipses.map(eachEllipse => (\r\n                <Ellipse\r\n                  ref={eachEllipse.ref}\r\n                  name={eachEllipse.name}\r\n                  x={eachEllipse.x}\r\n                  y={eachEllipse.y}\r\n                  rotation={eachEllipse.rotation}\r\n                  radiusX={eachEllipse.radiusX}\r\n                  radiusY={eachEllipse.radiusY}\r\n                  fill={eachEllipse.fill}\r\n                  stroke={eachEllipse.stroke}\r\n                  strokeWidth={eachEllipse.strokeWidth}\r\n                  strokeScaleEnabled={false}\r\n                  onClick={() => {\r\n                    var that = this;\r\n                    if (\r\n                      eachEllipse.link !== undefined &&\r\n                      eachEllipse.link !== \"\"\r\n                    ) {\r\n                      this.setState(\r\n                        {\r\n                          errMsg: \"Links will not be opened in create mode\"\r\n                        },\r\n                        () => {\r\n                          setTimeout(function() {\r\n                            that.setState({\r\n                              errMsg: \"\"\r\n                            });\r\n                          }, 1000);\r\n                        }\r\n                      );\r\n                    }\r\n                  }}\r\n                  onTransformStart={() => {\r\n                    this.setState({ isTransforming: true });\r\n                    let ellipse = this.refs[eachEllipse.ref];\r\n                    ellipse.setAttr(\"lastRotation\", ellipse.rotation());\r\n                  }}\r\n                  onTransform={() => {\r\n                    let ellipse = this.refs[eachEllipse.ref];\r\n\r\n                    if (ellipse.attrs.lastRotation !== ellipse.rotation()) {\r\n                      this.state.arrows.map(eachArrow => {\r\n                        if (\r\n                          eachArrow.to &&\r\n                          eachArrow.to.name() === ellipse.name()\r\n                        ) {\r\n                          this.setState({\r\n                            errMsg:\r\n                              \"Rotating ellipses with connectors might skew things up!\"\r\n                          });\r\n                        }\r\n                        if (\r\n                          eachArrow.from &&\r\n                          eachArrow.from.name() === ellipse.name()\r\n                        ) {\r\n                          this.setState({\r\n                            errMsg:\r\n                              \"Rotating ellipses with connectors might skew things up!\"\r\n                          });\r\n                        }\r\n                      });\r\n                    }\r\n\r\n                    ellipse.setAttr(\"lastRotation\", ellipse.rotation());\r\n                  }}\r\n                  onTransformEnd={() => {\r\n                    this.setState({ isTransforming: false });\r\n                    let ellipse = this.refs[eachEllipse.ref];\r\n                    let scaleX = ellipse.scaleX(),\r\n                      scaleY = ellipse.scaleY();\r\n\r\n                    this.setState(prevState => ({\r\n                      errMsg: \"\",\r\n                      ellipses: prevState.ellipses.map(eachEllipse =>\r\n                        eachEllipse.name === ellipse.attrs.name\r\n                          ? {\r\n                              ...eachEllipse,\r\n\r\n                              radiusX: ellipse.radiusX() * ellipse.scaleX(),\r\n                              radiusY: ellipse.radiusY() * ellipse.scaleY(),\r\n                              rotation: ellipse.rotation(),\r\n                              x: ellipse.x(),\r\n                              y: ellipse.y()\r\n                            }\r\n                          : eachEllipse\r\n                      )\r\n                    }));\r\n\r\n                    ellipse.setAttr(\"scaleX\", 1);\r\n                    ellipse.setAttr(\"scaleY\", 1);\r\n                    this.forceUpdate();\r\n                  }}\r\n                  draggable\r\n                  onDragMove={() => {\r\n                    console.log(\r\n                      \"name of ellipse moving: \",\r\n                      eachEllipse.name,\r\n                      \"new x y\",\r\n                      eachEllipse.x,\r\n                      eachEllipse.y\r\n                    );\r\n                    this.state.arrows.map(eachArrow => {\r\n                      if (eachArrow.from !== undefined) {\r\n                        console.log(\"prevArrow: \", eachArrow.points);\r\n                        if (eachEllipse.name == eachArrow.from.attrs.name) {\r\n                          eachArrow.points = [\r\n                            eachEllipse.x,\r\n                            eachEllipse.y,\r\n                            eachArrow.points[2],\r\n                            eachArrow.points[3]\r\n                          ];\r\n                          this.forceUpdate();\r\n                          this.refs.graphicStage.draw();\r\n                        }\r\n                        console.log(\"new arrows:\", eachArrow.points);\r\n                      }\r\n\r\n                      if (eachArrow.to !== undefined) {\r\n                        if (eachEllipse.name === eachArrow.to.attrs.name) {\r\n                          eachArrow.points = [\r\n                            eachArrow.points[0],\r\n                            eachArrow.points[1],\r\n                            eachEllipse.x,\r\n                            eachEllipse.y\r\n                          ];\r\n                          this.forceUpdate();\r\n                          this.refs.graphicStage.draw();\r\n                        }\r\n                      }\r\n                    });\r\n                  }}\r\n                  onDragEnd={event => {\r\n                    //cannot compare by name because currentSelected might not be the same\r\n                    //have to use ref, which appears to be overcomplicated\r\n                    var shape = this.refs[eachEllipse.ref];\r\n\r\n                    this.setState(prevState => ({\r\n                      ellipses: prevState.ellipses.map(eachEllipse =>\r\n                        eachEllipse.name === shape.attrs.name\r\n                          ? {\r\n                              ...eachEllipse,\r\n                              x: event.target.x(),\r\n                              y: event.target.y()\r\n                            }\r\n                          : eachEllipse\r\n                      )\r\n                    }));\r\n\r\n                    this.refs.graphicStage.draw();\r\n                  }}\r\n                />\r\n              ))}\r\n              {this.state.stars.map(eachStar => (\r\n                <Star\r\n                  ref={eachStar.ref}\r\n                  name={eachStar.name}\r\n                  x={eachStar.x}\r\n                  y={eachStar.y}\r\n                  innerRadius={eachStar.innerRadius}\r\n                  outerRadius={eachStar.outerRadius}\r\n                  numPoints={eachStar.numPoints}\r\n                  stroke={eachStar.stroke}\r\n                  strokeWidth={eachStar.strokeWidth}\r\n                  fill={eachStar.fill}\r\n                  strokeScaleEnabled={false}\r\n                  rotation={eachStar.rotation}\r\n                  onClick={() => {\r\n                    var that = this;\r\n                    if (eachStar.link !== undefined && eachStar.link !== \"\") {\r\n                      this.setState(\r\n                        {\r\n                          errMsg: \"Links will not be opened in create mode\"\r\n                        },\r\n                        () => {\r\n                          setTimeout(function() {\r\n                            that.setState({\r\n                              errMsg: \"\"\r\n                            });\r\n                          }, 1000);\r\n                        }\r\n                      );\r\n                    }\r\n                  }}\r\n                  onTransformStart={() => {\r\n                    this.setState({ isTransforming: true });\r\n                  }}\r\n                  onTransformEnd={() => {\r\n                    this.setState({ isTransforming: false });\r\n                    let star = this.refs[eachStar.ref];\r\n                    let scaleX = star.scaleX(),\r\n                      scaleY = star.scaleY();\r\n\r\n                    this.setState(prevState => ({\r\n                      stars: prevState.stars.map(eachStar =>\r\n                        eachStar.name === star.attrs.name\r\n                          ? {\r\n                              ...eachStar,\r\n                              innerRadius: star.innerRadius() * star.scaleX(),\r\n                              outerRadius: star.outerRadius() * star.scaleX(),\r\n                              rotation: star.rotation(),\r\n                              x: star.x(),\r\n                              y: star.y()\r\n                            }\r\n                          : eachStar\r\n                      )\r\n                    }));\r\n                    star.setAttr(\"scaleX\", 1);\r\n                    star.setAttr(\"scaleY\", 1);\r\n                    this.forceUpdate();\r\n                  }}\r\n                  draggable\r\n                  onDragMove={() => {\r\n                    this.state.arrows.map(eachArrow => {\r\n                      if (eachArrow.from !== undefined) {\r\n                        if (eachStar.name == eachArrow.from.attrs.name) {\r\n                          eachArrow.points = [\r\n                            eachStar.x,\r\n                            eachStar.y,\r\n                            eachArrow.points[2],\r\n                            eachArrow.points[3]\r\n                          ];\r\n                          this.forceUpdate();\r\n                        }\r\n                      }\r\n\r\n                      if (eachArrow.to !== undefined) {\r\n                        if (eachStar.name === eachArrow.to.attrs.name) {\r\n                          eachArrow.points = [\r\n                            eachArrow.points[0],\r\n                            eachArrow.points[1],\r\n                            eachStar.x,\r\n                            eachStar.y\r\n                          ];\r\n                          this.forceUpdate();\r\n                        }\r\n                      }\r\n                    });\r\n                  }}\r\n                  onDragEnd={event => {\r\n                    //cannot compare by name because currentSelected might not be the same\r\n                    //have to use ref, which appears to be overcomplicated\r\n                    var shape = this.refs[eachStar.ref];\r\n\r\n                    this.setState(prevState => ({\r\n                      stars: prevState.stars.map(eachStar =>\r\n                        eachStar.name === shape.attrs.name\r\n                          ? {\r\n                              ...eachStar,\r\n                              x: event.target.x(),\r\n                              y: event.target.y()\r\n                            }\r\n                          : eachStar\r\n                      )\r\n                    }));\r\n                  }}\r\n                />\r\n              ))}\r\n              {this.state.texts.map(eachText => (\r\n                //perhaps this.state.texts only need to contain refs?\r\n                //so that we only need to store the refs to get more information\r\n                <Text\r\n                  textDecoration={eachText.link ? \"underline\" : \"\"}\r\n                  onTransformStart={() => {\r\n                    var currentText = this.refs[this.state.selectedShapeName];\r\n                    currentText.setAttr(\"lastRotation\", currentText.rotation());\r\n                  }}\r\n                  onTransform={() => {\r\n                    var currentText = this.refs[this.state.selectedShapeName];\r\n\r\n                    currentText.setAttr(\r\n                      \"width\",\r\n                      currentText.width() * currentText.scaleX()\r\n                    );\r\n                    currentText.setAttr(\"scaleX\", 1);\r\n\r\n                    currentText.draw();\r\n\r\n                    if (\r\n                      currentText.attrs.lastRotation !== currentText.rotation()\r\n                    ) {\r\n                      this.state.arrows.map(eachArrow => {\r\n                        if (\r\n                          eachArrow.to &&\r\n                          eachArrow.to.name() === currentText.name()\r\n                        ) {\r\n                          this.setState({\r\n                            errMsg:\r\n                              \"Rotating texts with connectors might skew things up!\"\r\n                          });\r\n                        }\r\n                        if (\r\n                          eachArrow.from &&\r\n                          eachArrow.from.name() === currentText.name()\r\n                        ) {\r\n                          this.setState({\r\n                            errMsg:\r\n                              \"Rotating texts with connectors might skew things up!\"\r\n                          });\r\n                        }\r\n                      });\r\n                    }\r\n\r\n                    currentText.setAttr(\"lastRotation\", currentText.rotation());\r\n                  }}\r\n                  onTransformEnd={() => {\r\n                    var currentText = this.refs[this.state.selectedShapeName];\r\n\r\n                    this.setState(prevState => ({\r\n                      errMsg: \"\",\r\n                      texts: prevState.texts.map(eachText =>\r\n                        eachText.name === this.state.selectedShapeName\r\n                          ? {\r\n                              ...eachText,\r\n                              width: currentText.width(),\r\n                              rotation: currentText.rotation(),\r\n                              textWidth: currentText.textWidth,\r\n                              textHeight: currentText.textHeight,\r\n                              x: currentText.x(),\r\n                              y: currentText.y()\r\n                            }\r\n                          : eachText\r\n                      )\r\n                    }));\r\n                    currentText.setAttr(\"scaleX\", 1);\r\n                    currentText.draw();\r\n                  }}\r\n                  link={eachText.link}\r\n                  width={eachText.width}\r\n                  fill={eachText.fill}\r\n                  name={eachText.name}\r\n                  ref={eachText.ref}\r\n                  rotation={eachText.rotation}\r\n                  fontFamily={eachText.fontFamily}\r\n                  fontSize={eachText.fontSize}\r\n                  x={eachText.x}\r\n                  y={eachText.y}\r\n                  text={eachText.text}\r\n                  draggable\r\n                  onDragMove={() => {\r\n                    this.state.arrows.map(eachArrow => {\r\n                      if (eachArrow.from !== undefined) {\r\n                        if (eachText.name === eachArrow.from.attrs.name) {\r\n                          eachArrow.points = [\r\n                            eachText.x,\r\n                            eachText.y,\r\n                            eachArrow.points[2],\r\n                            eachArrow.points[3]\r\n                          ];\r\n                          this.forceUpdate();\r\n                        }\r\n                      }\r\n\r\n                      if (eachArrow.to !== undefined) {\r\n                        if (eachText.name === eachArrow.to.attrs.name) {\r\n                          eachArrow.points = [\r\n                            eachArrow.points[0],\r\n                            eachArrow.points[1],\r\n                            eachText.x,\r\n                            eachText.y\r\n                          ];\r\n                          this.forceUpdate();\r\n                        }\r\n                      }\r\n                    });\r\n                  }}\r\n                  onDragEnd={event => {\r\n                    //cannot compare by name because currentSelected might not be the same\r\n                    //have to use ref, which appears to be overcomplicated\r\n                    var shape = this.refs[eachText.ref];\r\n\r\n                    this.setState(prevState => ({\r\n                      texts: prevState.texts.map(eachtext =>\r\n                        eachtext.name === shape.attrs.name\r\n                          ? {\r\n                              ...eachtext,\r\n                              x: event.target.x(),\r\n                              y: event.target.y()\r\n                            }\r\n                          : eachtext\r\n                      )\r\n                    }));\r\n                  }}\r\n                  onClick={() => {\r\n                    var that = this;\r\n                    if (eachText.link !== undefined && eachText.link !== \"\") {\r\n                      this.setState(\r\n                        {\r\n                          errMsg: \"Links will not be opened in create mode\"\r\n                        },\r\n                        () => {\r\n                          setTimeout(function() {\r\n                            that.setState({\r\n                              errMsg: \"\"\r\n                            });\r\n                          }, 1000);\r\n                        }\r\n                      );\r\n\r\n                      //var win = window.open(eachText.link, \"_blank\");\r\n                      //win.focus();\r\n                    }\r\n                  }}\r\n                  onDblClick={() => {\r\n                    // turn into textarea\r\n                    var stage = this.refs.graphicStage;\r\n                    var text = stage.findOne(\".\" + eachText.name);\r\n\r\n                    this.setState({\r\n                      textX: text.absolutePosition().x,\r\n                      textY: text.absolutePosition().y,\r\n                      textEditVisible: !this.state.textEditVisible,\r\n                      text: eachText.text,\r\n                      textNode: eachText,\r\n                      currentTextRef: eachText.ref,\r\n                      textareaWidth: text.textWidth,\r\n                      textareaHeight: text.textHeight,\r\n                      textareaFill: text.attrs.fill,\r\n                      textareaFontFamily: text.attrs.fontFamily,\r\n                      textareaFontSize: text.attrs.fontSize\r\n                    });\r\n                    let textarea = this.refs.textarea;\r\n                    textarea.focus();\r\n                    text.hide();\r\n                    var transformer = stage.findOne(\".transformer\");\r\n                    transformer.hide();\r\n                    this.refs.layer2.draw();\r\n                  }}\r\n                />\r\n              ))}\r\n              {this.state.arrows.map(eachArrow => {\r\n                if (!eachArrow.from && !eachArrow.to) {\r\n                  return (\r\n                    <Arrow\r\n                      ref={eachArrow.ref}\r\n                      name={eachArrow.name}\r\n                      points={[\r\n                        eachArrow.points[0],\r\n                        eachArrow.points[1],\r\n                        eachArrow.points[2],\r\n                        eachArrow.points[3]\r\n                      ]}\r\n                      stroke={eachArrow.stroke}\r\n                      fill={eachArrow.fill}\r\n                      draggable\r\n                      onDragEnd={event => {\r\n                        //set new points to current position\r\n\r\n                        //usually: state => star => x & y\r\n                        //now: state => arrow => attr => x & y\r\n\r\n                        let oldPoints = [\r\n                          eachArrow.points[0],\r\n                          eachArrow.points[1],\r\n                          eachArrow.points[2],\r\n                          eachArrow.points[3]\r\n                        ];\r\n\r\n                        let shiftX = this.refs[eachArrow.ref].attrs.x;\r\n                        let shiftY = this.refs[eachArrow.ref].attrs.y;\r\n\r\n                        let newPoints = [\r\n                          oldPoints[0] + shiftX,\r\n                          oldPoints[1] + shiftY,\r\n                          oldPoints[2] + shiftX,\r\n                          oldPoints[3] + shiftY\r\n                        ];\r\n\r\n                        this.refs[eachArrow.ref].position({ x: 0, y: 0 });\r\n                        this.refs.layer2.draw();\r\n\r\n                        this.setState(prevState => ({\r\n                          arrows: prevState.arrows.map(eachArr =>\r\n                            eachArr.name === eachArrow.name\r\n                              ? {\r\n                                  ...eachArr,\r\n                                  points: newPoints\r\n                                }\r\n                              : eachArr\r\n                          )\r\n                        }));\r\n                      }}\r\n                    />\r\n                  );\r\n                } else if (\r\n                  eachArrow.name === this.state.newArrowRef &&\r\n                  (eachArrow.from || eachArrow.to)\r\n                ) {\r\n                  return (\r\n                    <Connector\r\n                      name={eachArrow.name}\r\n                      from={eachArrow.from}\r\n                      to={eachArrow.to}\r\n                      arrowEndX={this.state.arrowEndX}\r\n                      arrowEndY={this.state.arrowEndY}\r\n                      current={true}\r\n                      stroke={eachArrow.stroke}\r\n                      fill={eachArrow.fill}\r\n                    />\r\n                  );\r\n                } else if (eachArrow.from || eachArrow.to) {\r\n                  //if arrow construction is completed\r\n                  return (\r\n                    <Connector\r\n                      name={eachArrow.name}\r\n                      from={eachArrow.from}\r\n                      to={eachArrow.to}\r\n                      points={eachArrow.points}\r\n                      current={false}\r\n                      stroke={eachArrow.stroke}\r\n                      fill={eachArrow.fill}\r\n                    />\r\n                  );\r\n                }\r\n              })}\r\n\r\n              {this.state.selectedShapeName.includes(\"text\") ? (\r\n                <TransformerComponent\r\n                  selectedShapeName={this.state.selectedShapeName}\r\n                />\r\n              ) : (\r\n                <TransformerComponent\r\n                  selectedShapeName={this.state.selectedShapeName}\r\n                />\r\n              )}\r\n            </Layer>\r\n\r\n            <Layer\r\n              height={window.innerHeight}\r\n              width={window.innerWidth}\r\n              ref=\"layer\"\r\n            >\r\n              <Toolbar\r\n                layer={this.refs.layer2}\r\n                rectName={\r\n                  this.state.rectangles.length + 1 + this.state.rectDeleteCount\r\n                }\r\n                ellipseName={\r\n                  this.state.ellipses.length + 1 + this.state.ellipseDeleteCount\r\n                }\r\n                starName={\r\n                  this.state.stars.length + 1 + this.state.starDeleteCount\r\n                }\r\n                textName={\r\n                  this.state.texts.length + 1 + this.state.textDeleteCount\r\n                }\r\n                newArrowOnDragEnd={toPush => {\r\n                  if (toPush.from !== undefined) {\r\n                    //  console.log(\"we are making a connector\");\r\n\r\n                    var transform = this.refs.layer2\r\n                      .getAbsoluteTransform()\r\n                      .copy();\r\n                    transform.invert();\r\n                    let uh = transform.point({\r\n                      x: toPush.x,\r\n                      y: toPush.y\r\n                    });\r\n                    toPush.x = uh.x;\r\n                    toPush.y = uh.y;\r\n\r\n                    var newArrow = {\r\n                      points: toPush.points,\r\n                      ref:\r\n                        \"arrow\" +\r\n                        (this.state.arrows.length +\r\n                          1 +\r\n                          this.state.arrowDeleteCount),\r\n                      name:\r\n                        \"arrow\" +\r\n                        (this.state.arrows.length +\r\n                          1 +\r\n                          this.state.arrowDeleteCount),\r\n                      from: toPush.from,\r\n                      stroke: toPush.stroke,\r\n                      strokeWidth: toPush.strokeWidth,\r\n                      fill: toPush.fill\r\n                    };\r\n\r\n                    //  console.log(newArrow);\r\n                    this.setState(prevState => ({\r\n                      arrows: [...prevState.arrows, newArrow],\r\n                      newArrowDropped: true,\r\n                      newArrowRef: newArrow.name,\r\n                      arrowEndX: toPush.x,\r\n                      arrowEndY: toPush.y\r\n                    }));\r\n                  } else {\r\n                    //  console.log(\"we are making just an aarrow\");\r\n                    var transform = this.refs.layer2\r\n                      .getAbsoluteTransform()\r\n                      .copy();\r\n                    transform.invert();\r\n                    let uh = transform.point({\r\n                      x: toPush.x,\r\n                      y: toPush.y\r\n                    });\r\n                    toPush.x = uh.x;\r\n                    toPush.y = uh.y;\r\n                    var newArrow = {\r\n                      points: [toPush.x, toPush.y, toPush.x, toPush.y],\r\n                      ref:\r\n                        \"arrow\" +\r\n                        (this.state.arrows.length +\r\n                          1 +\r\n                          this.state.arrowDeleteCount),\r\n                      name:\r\n                        \"arrow\" +\r\n                        (this.state.arrows.length +\r\n                          1 +\r\n                          this.state.arrowDeleteCount),\r\n                      from: toPush.from,\r\n                      stroke: toPush.stroke,\r\n                      strokeWidth: toPush.strokeWidth,\r\n                      fill: toPush.fill\r\n                    };\r\n\r\n                    this.setState(prevState => ({\r\n                      arrows: [...prevState.arrows, newArrow],\r\n                      newArrowDropped: true,\r\n                      newArrowRef: newArrow.name,\r\n                      arrowEndX: toPush.x,\r\n                      arrowEndY: toPush.y\r\n                    }));\r\n                  }\r\n\r\n                  //this.refs updates after forceUpdate (because arrow gets instantiated), might be risky in the future\r\n                  //only this.state.arrows.length because it was pushed earlier, cancelling the +1\r\n                }}\r\n                appendToRectangles={stuff => {\r\n                  var layer = this.refs.layer2;\r\n                  var toPush = stuff;\r\n                  var stage = this.refs.graphicStage;\r\n                  var transform = this.refs.layer2\r\n                    .getAbsoluteTransform()\r\n                    .copy();\r\n                  transform.invert();\r\n\r\n                  var pos = transform.point({\r\n                    x: toPush.x,\r\n                    y: toPush.y\r\n                  });\r\n\r\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\r\n                    toPush.x = pos.x;\r\n                    toPush.y = pos.y;\r\n                  }\r\n\r\n                  this.setState(prevState => ({\r\n                    rectangles: [...prevState.rectangles, toPush],\r\n                    selectedShapeName: toPush.name\r\n                  }));\r\n                }}\r\n                appendToEllipses={stuff => {\r\n                  var layer = this.refs.layer2;\r\n                  var toPush = stuff;\r\n                  var stage = this.refs.graphicStage;\r\n                  var transform = this.refs.layer2\r\n                    .getAbsoluteTransform()\r\n                    .copy();\r\n                  transform.invert();\r\n\r\n                  var pos = transform.point({\r\n                    x: toPush.x,\r\n                    y: toPush.y\r\n                  });\r\n\r\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\r\n                    toPush.x = pos.x;\r\n                    toPush.y = pos.y;\r\n                  }\r\n\r\n                  this.setState(prevState => ({\r\n                    ellipses: [...prevState.ellipses, toPush],\r\n                    selectedShapeName: toPush.name\r\n                  }));\r\n                }}\r\n                appendToStars={stuff => {\r\n                  var layer = this.refs.layer2;\r\n                  var toPush = stuff;\r\n                  var stage = this.refs.graphicStage;\r\n                  var transform = this.refs.layer2\r\n                    .getAbsoluteTransform()\r\n                    .copy();\r\n                  transform.invert();\r\n\r\n                  var pos = transform.point({\r\n                    x: toPush.x,\r\n                    y: toPush.y\r\n                  });\r\n\r\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\r\n                    toPush.x = pos.x;\r\n                    toPush.y = pos.y;\r\n                  }\r\n                  this.setState(prevState => ({\r\n                    stars: [...prevState.stars, toPush],\r\n                    selectedShapeName: toPush.name\r\n                  }));\r\n                }}\r\n                appendToTexts={stuff => {\r\n                  var layer = this.refs.layer2;\r\n                  var toPush = stuff;\r\n                  var stage = this.refs.graphicStage;\r\n                  var transform = this.refs.layer2\r\n                    .getAbsoluteTransform()\r\n                    .copy();\r\n                  transform.invert();\r\n\r\n                  var pos = transform.point({\r\n                    x: toPush.x,\r\n                    y: toPush.y\r\n                  });\r\n\r\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\r\n                    toPush.x = pos.x;\r\n                    toPush.y = pos.y;\r\n                  }\r\n\r\n                  this.setState(prevState => ({\r\n                    texts: [...prevState.texts, toPush]\r\n                  }));\r\n\r\n                  //we can also just get element by this.refs.toPush.ref\r\n\r\n                  //  let text = stage.findOne(\".\" + toPush.name);\r\n                  let text = this.refs[toPush.ref];\r\n                  //this.setState({firstTimeTextEditing: true});\r\n                  text.fire(\"dblclick\");\r\n                }}\r\n              />\r\n            </Layer>\r\n          </Stage>\r\n\r\n          <textarea\r\n            ref=\"textarea\"\r\n            id=\"textarea\"\r\n            value={this.state.text}\r\n            onChange={e => {\r\n              this.setState({\r\n                text: e.target.value,\r\n                shouldTextUpdate: false\r\n              });\r\n            }}\r\n            onKeyDown={e => {\r\n              if (e.keyCode === 13) {\r\n                this.setState({\r\n                  textEditVisible: false,\r\n                  shouldTextUpdate: true\r\n                });\r\n\r\n                // get the current textNode we are editing, get the name from there\r\n                //match name with elements in this.state.texts,\r\n                let node = this.refs[this.state.currentTextRef];\r\n                console.log(\"node width before set\", node.textWidth);\r\n                let name = node.attrs.name;\r\n                this.setState(\r\n                  prevState => ({\r\n                    selectedShapeName: name,\r\n                    texts: prevState.texts.map(eachText =>\r\n                      eachText.name === name\r\n                        ? {\r\n                            ...eachText,\r\n                            text: this.state.text\r\n                          }\r\n                        : eachText\r\n                    )\r\n                  }),\r\n                  () => {\r\n                    this.setState(prevState => ({\r\n                      texts: prevState.texts.map(eachText =>\r\n                        eachText.name === name\r\n                          ? {\r\n                              ...eachText,\r\n                              textWidth: node.textWidth,\r\n                              textHeight: node.textHeight\r\n                            }\r\n                          : eachText\r\n                      )\r\n                    }));\r\n                  }\r\n                );\r\n\r\n                node.show();\r\n                this.refs.graphicStage.findOne(\".transformer\").show();\r\n              }\r\n            }}\r\n            onBlur={() => {\r\n              this.setState({\r\n                textEditVisible: false,\r\n                shouldTextUpdate: true\r\n              });\r\n\r\n              // get the current textNode we are editing, get the name from there\r\n              //match name with elements in this.state.texts,\r\n\r\n              let node = this.refs.graphicStage.findOne(\r\n                \".\" + this.state.currentTextRef\r\n              );\r\n              let name = node.attrs.name;\r\n\r\n              this.setState(\r\n                prevState => ({\r\n                  selectedShapeName: name,\r\n                  texts: prevState.texts.map(eachText =>\r\n                    eachText.name === name\r\n                      ? {\r\n                          ...eachText,\r\n                          text: this.state.text\r\n                        }\r\n                      : eachText\r\n                  )\r\n                }),\r\n                () => {\r\n                  this.setState(prevState => ({\r\n                    texts: prevState.texts.map(eachText =>\r\n                      eachText.name === name\r\n                        ? {\r\n                            ...eachText,\r\n                            textWidth: node.textWidth,\r\n                            textHeight: node.textHeight\r\n                          }\r\n                        : eachText\r\n                    )\r\n                  }));\r\n                }\r\n              );\r\n              node.show();\r\n              this.refs.graphicStage.findOne(\".transformer\").show();\r\n              this.refs.graphicStage.draw();\r\n            }}\r\n            style={{\r\n              //set position, width, height, fontSize, overflow, lineHeight, color\r\n              display: this.state.textEditVisible ? \"block\" : \"none\",\r\n              position: \"absolute\",\r\n              top: this.state.textY + 80 + \"px\",\r\n              left: this.state.textX + \"px\",\r\n              width: \"300px\",\r\n              height: \"300px\",\r\n              overflow: \"hidden\",\r\n              fontSize: this.state.textareaFontSize,\r\n              fontFamily: this.state.textareaFontFamily,\r\n              color: this.state.textareaFill,\r\n              border: \"none\",\r\n              padding: \"0px\",\r\n              margin: \"0px\",\r\n              outline: \"none\",\r\n              resize: \"none\",\r\n              background: \"none\"\r\n            }}\r\n          />\r\n          <div className=\"errMsg\">{errDisplay}</div>\r\n        </div>\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}\r\nconst mapStateToProps = state => ({\r\n  auth: state.auth\r\n});\r\n\r\nexport default Graphics;\r\n"]},"metadata":{},"sourceType":"module"}