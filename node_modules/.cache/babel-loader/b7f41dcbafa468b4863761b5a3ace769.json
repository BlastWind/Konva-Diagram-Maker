{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _classCallCheck from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"C:\\\\Users\\\\andre\\\\Desktop\\\\Great React Projects\\\\livesearch\\\\src\\\\App.js\";\n//todo: allow for picture inside of rect/ellipse/stfar\n//todo: connect using arrow\n//todo: for rightToolBar, show fontSize,fontFamily for text for the rest allow to add pictures\n//todo: zoomable\nimport React, { Component } from 'react';\nimport { Stage, Layer, Rect, Transformer, Ellipse, Star, Text, Arrow } from 'react-konva';\nimport Connector from './Connector.jsx';\nimport Toolbar from './Toolbar.js';\nimport './Graphics.css';\n\nvar TransformerComponent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(TransformerComponent, _React$Component);\n\n  function TransformerComponent() {\n    _classCallCheck(this, TransformerComponent);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TransformerComponent).apply(this, arguments));\n  }\n\n  _createClass(TransformerComponent, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.checkNode();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.checkNode();\n    }\n  }, {\n    key: \"checkNode\",\n    value: function checkNode() {\n      var stage = this.transformer.getStage();\n      var selectedShapeName = this.props.selectedShapeName;\n\n      if (selectedShapeName === '') {\n        this.transformer.detach();\n        return;\n      }\n\n      var selectedNode = stage.findOne('.' + selectedShapeName);\n\n      if (selectedNode === this.transformer.node()) {\n        return;\n      }\n\n      if (selectedNode) {\n        this.transformer.attachTo(selectedNode);\n      } else {\n        this.transformer.detach();\n      }\n\n      this.transformer.getLayer().batchDraw();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n\n      if (this.props.selectedShapeName.includes('text')) {\n        var stuff = React.createElement(Transformer, {\n          ref: function ref(node) {\n            _this.transformer = node;\n          },\n          name: \"transformer\",\n          boundBoxFunc: function boundBoxFunc(oldBox, newBox) {\n            newBox.width = Math.max(30, newBox.width);\n            return newBox;\n          },\n          enabledAnchors: ['middle-left', 'middle-right'],\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 55\n          },\n          __self: this\n        });\n      } else if (this.props.selectedShapeName.includes('star')) {\n        var stuff = React.createElement(Transformer, {\n          ref: function ref(node) {\n            _this.transformer = node;\n          },\n          name: \"transformer\",\n          enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 69\n          },\n          __self: this\n        });\n      } else if (this.props.selectedShapeName.includes('arrow')) {\n        var stuff = React.createElement(Transformer, {\n          ref: function ref(node) {\n            _this.transformer = node;\n          },\n          name: \"transformer\",\n          resizeEnabled: false,\n          rotateEnabled: false,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 84\n          },\n          __self: this\n        });\n      } else {\n        var stuff = React.createElement(Transformer, {\n          ref: function ref(node) {\n            _this.transformer = node;\n          },\n          name: \"transformer\",\n          keepRatio: true,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 95\n          },\n          __self: this\n        });\n      }\n\n      return stuff;\n    }\n  }]);\n\n  return TransformerComponent;\n}(React.Component);\n\nvar history = [];\nvar historyStep = 0;\n\nvar Graphics =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Graphics, _Component);\n\n  function Graphics(props) {\n    var _this2;\n\n    _classCallCheck(this, Graphics);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Graphics).call(this, props));\n\n    _this2.handleSave = function () {\n      var rects = _this2.state.rectangles,\n          ellipses = _this2.state.ellipses,\n          stars = _this2.state.stars,\n          texts = _this2.state.texts,\n          arrows = _this2.state.arrows;\n\n      if (JSON.stringify(_this2.state.saved) !== JSON.stringify([rects, ellipses, stars, texts, arrows])) {\n        _this2.setState({\n          saved: [rects, ellipses, stars, texts, arrows]\n        });\n\n        var arrows1 = _this2.state.arrows;\n        arrows1.forEach(function (eachArrow) {\n          //for \"from & to of each arrow\"\n          if (eachArrow.from && eachArrow.from.attrs) {\n            if (eachArrow.from.attrs.name.includes('text')) {\n              eachArrow.from.textWidth = eachArrow.from.textWidth;\n              eachArrow.from.textHeight = eachArrow.from.textHeight;\n            }\n          }\n\n          if (eachArrow.to && eachArrow.to.attrs) {\n            if (eachArrow.to.attrs.name.includes('text')) {\n              eachArrow.to.attrs.textWidth = eachArrow.to.textWidth;\n              eachArrow.to.attrs.textHeight = eachArrow.to.textHeight;\n            }\n          }\n        });\n\n        if (_this2.state.roadmapId) {\n          //if draft already exists\n          _this2.setState({\n            saving: true\n          });\n\n          fetch('/api/roadmap/modifyDraftDB', {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n              roadmapId: _this2.state.roadmapId,\n              data: {\n                rects: rects,\n                ellipses: ellipses,\n                stars: stars,\n                texts: texts,\n                arrows: arrows1\n              }\n            })\n          }).then(function (res) {\n            _this2.setState({\n              saving: false\n            });\n          });\n        } else {\n          //if first time pressing sav\n          _this2.setState({\n            saving: true\n          });\n\n          fetch('/api/roadmap/saveRoadmapToDB', {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n              userId: _this2.props.auth.user.id,\n              roadmapType: 'draft',\n              data: {\n                rects: rects,\n                ellipses: ellipses,\n                stars: stars,\n                texts: texts,\n                arrows: arrows\n              }\n            })\n          }).then(function (res) {\n            return res.json().then(function (data) {\n              _this2.setState({\n                saving: false\n              });\n\n              _this2.setState({\n                roadmapId: data.roadmapId\n              });\n            });\n          });\n        }\n      }\n    };\n\n    _this2.handleStageClick = function (e) {\n      var pos = _this2.refs.layer2.getStage().getPointerPosition();\n\n      var shape = _this2.refs.layer2.getIntersection(pos);\n\n      console.log('texts', _this2.state.texts);\n\n      if (shape !== null && shape.name() !== undefined && shape !== undefined && shape.name() !== undefined) {\n        _this2.setState({\n          selectedShapeName: shape.name()\n        }, function () {\n          _this2.refs.graphicStage.draw();\n        });\n      } //arrow logic\n\n\n      if (_this2.state.newArrowRef !== '') {\n        if (_this2.state.previousShape) {\n          if (_this2.state.previousShape.attrs.id !== 'ContainerRect') {\n            //console.log(this.refs.graphicStage.findOne(\".\" + this.state.newArrowRef));\n            //\n            _this2.state.arrows.map(function (eachArrow) {\n              if (eachArrow.name === _this2.state.newArrowRef) {\n                eachArrow.to = _this2.state.previousShape;\n              }\n            }); //console.log(newConnector, this.state.newArrowRef);\n            //newConnector.setAttr(\"to\", this.state.previousShape);\n            //console.log(newConnector);\n\n          }\n        } //handle connector more\n        //if the currentArrow ref has a from, and that e.target.attrs.id isn't containerRect,\n        //then find the current shape with stage find name and then yeah\n\n\n        _this2.state.arrows.map(function (eachArrow) {\n          if (eachArrow.name === _this2.state.newArrowRef) {\n            eachArrow.fill = 'black';\n            eachArrow.stroke = 'black';\n          }\n        }); //arrow logic, there's e.evt.pageX, pageY\n\n\n        _this2.setState({\n          arrowDraggable: false,\n          newArrowRef: ''\n        });\n      }\n    };\n\n    _this2.handleMouseOver = function (event) {\n      //get the currennt arrow ref and modify its position by filtering & pushing again\n      //console.log(\"lastFill: \", this.state.lastFill);\n      var pos = _this2.refs.graphicStage.getPointerPosition();\n\n      var shape = _this2.refs.graphicStage.getIntersection(pos);\n\n      if (shape && shape.attrs.link) {\n        document.body.style.cursor = 'pointer';\n      } else {\n        document.body.style.cursor = 'default';\n      } //if we are moving an arrow\n\n\n      if (_this2.state.newArrowRef !== '') {\n        //filling color logic:\n        var transform = _this2.refs.layer2.getAbsoluteTransform().copy();\n\n        transform.invert();\n        pos = transform.point(pos);\n\n        _this2.setState({\n          arrowEndX: pos.x,\n          arrowEndY: pos.y\n        }); //last non arrow object\n\n\n        if (shape && shape.attrs && shape.attrs.name != undefined) {\n          //  console.log(shape);\n          if (!shape.attrs.name.includes('arrow')) {\n            //after first frame\n            if (_this2.state.previousShape) if (_this2.state.previousShape !== shape) {\n              //arrow entered a new shape\n              //set current arrow to blue\n              if (_this2.state.previousShape.attrs.id !== 'ContainerRect') {\n                _this2.state.arrows.map(function (eachArrow) {\n                  if (eachArrow.name === _this2.state.newArrowRef) {\n                    eachArrow.fill = 'black';\n                    eachArrow.stroke = 'black';\n                  }\n                });\n\n                _this2.forceUpdate();\n              } else {\n                _this2.state.arrows.map(function (eachArrow) {\n                  if (eachArrow.name === _this2.state.newArrowRef) {\n                    eachArrow.fill = '#ccf5ff';\n                    eachArrow.stroke = '#ccf5ff';\n                  }\n                });\n\n                _this2.forceUpdate();\n              }\n            } //if arrow is moving in a single shape\n          }\n\n          if (!shape.attrs.name.includes('arrow')) {\n            _this2.setState({\n              previousShape: shape\n            });\n          }\n        }\n      }\n\n      var arrows = _this2.state.arrows;\n      arrows.map(function (eachArrow) {\n        if (eachArrow.name === _this2.state.newArrowRef) {\n          var index = arrows.indexOf(eachArrow);\n          var currentArrow = eachArrow;\n          currentArrow.points = [currentArrow.points[0], currentArrow.points[1], pos.x, pos.y\n          /*  event.evt.pageY -\r\n          document.getElementById(\"NavBar\").getBoundingClientRect().height */\n          ];\n          _this2.state.arrows[index] = currentArrow;\n        }\n      });\n    };\n\n    _this2.handleUndo = function () {\n      if (!_this2.state.isTransforming) {\n        if (!_this2.state.textEditVisible) {\n          if (historyStep === 0) {\n            return;\n          }\n\n          historyStep -= 1;\n\n          _this2.setState({\n            rectangles: history[historyStep].rectangles,\n            arrows: history[historyStep].arrows,\n            ellipses: history[historyStep].ellipses,\n            stars: history[historyStep].stars,\n            texts: history[historyStep].texts,\n            connectors: history[historyStep].connectors,\n            redoing: true,\n            selectedShapeName: _this2.shapeIsGone(history[historyStep]) ? '' : _this2.state.selectedShapeName\n          }, function () {\n            _this2.refs.graphicStage.draw();\n          });\n        }\n      }\n    };\n\n    _this2.handleRedo = function () {\n      if (historyStep === history.length - 1) {\n        return;\n      }\n\n      historyStep += 1;\n      var next = history[historyStep];\n\n      _this2.setState({\n        rectangles: next.rectangles,\n        arrows: next.arrows,\n        ellipses: next.ellipses,\n        stars: next.stars,\n        texts: next.texts,\n        redoing: true,\n        selectedShapeName: _this2.shapeIsGone(history[historyStep]) ? '' : _this2.state.selectedShapeName\n      }, function () {\n        _this2.forceUpdate();\n      });\n    };\n\n    _this2.shapeIsGone = function (returnTo) {\n      var toReturn = true;\n      var currentShapeName = _this2.state.selectedShapeName;\n      var _ref = [returnTo.rectangles, returnTo.ellipses, returnTo.stars, returnTo.arrows, returnTo.texts],\n          rectangles = _ref[0],\n          ellipses = _ref[1],\n          stars = _ref[2],\n          arrows = _ref[3],\n          texts = _ref[4];\n      rectangles.map(function (eachRect) {\n        if (eachRect.name === currentShapeName) {\n          toReturn = false;\n        }\n      });\n      ellipses.map(function (eachEllipse) {\n        if (eachEllipse.name === currentShapeName) {\n          toReturn = false;\n        }\n      });\n      stars.map(function (eachStar) {\n        if (eachStar.name === currentShapeName) {\n          toReturn = false;\n        }\n      });\n      arrows.map(function (eachArrow) {\n        if (eachArrow.name === currentShapeName) {\n          toReturn = false;\n        }\n      });\n      texts.map(function (eachText) {\n        if (eachText.name === currentShapeName) {\n          toReturn = false;\n        }\n      });\n      return toReturn;\n    };\n\n    _this2.IsJsonString = function (str) {\n      try {\n        JSON.parse(str);\n      } catch (e) {\n        return false;\n      }\n\n      return true;\n    };\n\n    _this2.state = {\n      layerX: 0,\n      layerY: 0,\n      layerScale: 1,\n      selectedShapeName: '',\n      errMsg: '',\n      rectangles: [],\n      ellipses: [],\n      stars: [],\n      texts: [],\n      arrows: [],\n      connectors: [],\n      currentTextRef: '',\n      shouldTextUpdate: true,\n      textX: 0,\n      textY: 0,\n      textEditVisible: false,\n      arrowDraggable: false,\n      newArrowRef: '',\n      count: 0,\n      newArrowDropped: false,\n      newConnectorDropped: false,\n      arrowEndX: 0,\n      arrowEndY: 0,\n      isTransforming: false,\n      lastFill: null,\n      saving: null,\n      saved: [],\n      roadmapId: null,\n      alreadyCreated: false,\n      publishing: false,\n      title: '',\n      category: '',\n      description: '',\n      thumbnail: '',\n      isPasteDisabled: false,\n      ellipseDeleteCount: 0,\n      starDeleteCount: 0,\n      arrowDeleteCount: 0,\n      textDeleteCount: 0,\n      rectDeleteCount: 0\n    };\n    _this2.handleWheel = _this2.handleWheel.bind(_assertThisInitialized(_assertThisInitialized(_this2)));\n    _this2.handleRoadmapPublish = _this2.handleRoadmapPublish.bind(_assertThisInitialized(_assertThisInitialized(_this2)));\n    return _this2;\n  }\n\n  _createClass(Graphics, [{\n    key: \"handleWheel\",\n    value: function handleWheel(event) {\n      if (this.state.rectangles.length === 0 && this.state.ellipses.length === 0 && this.state.stars.length === 0 && this.state.texts.length === 0 && this.state.arrows.length === 0) {} else {\n        event.evt.preventDefault();\n        var scaleBy = 1.2;\n        var stage = this.refs.graphicStage;\n        var layer = this.refs.layer2;\n        var oldScale = layer.scaleX();\n        var mousePointTo = {\n          x: stage.getPointerPosition().x / oldScale - this.state.layerX / oldScale,\n          y: stage.getPointerPosition().y / oldScale - this.state.layerY / oldScale\n        };\n        var newScale = event.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy;\n        layer.scale({\n          x: newScale,\n          y: newScale\n        });\n        /*  console.log(\r\n        oldScale,\r\n        mousePointTo,\r\n        stage.getPointerPosition().x,\r\n        stage.getPointerPosition().y\r\n        );\r\n        */\n\n        this.setState({\n          layerScale: newScale,\n          layerX: -(mousePointTo.x - stage.getPointerPosition().x / newScale) * newScale,\n          layerY: -(mousePointTo.y - stage.getPointerPosition().y / newScale) * newScale\n        });\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var prevMainShapes = [prevState.rectangles, prevState.ellipses, prevState.stars, prevState.arrows, prevState.connectors, prevState.texts];\n      var currentMainShapes = [this.state.rectangles, this.state.ellipses, this.state.stars, this.state.arrows, this.state.connectors, this.state.texts];\n      if (!this.state.redoing && !this.state.isTransforming) if (JSON.stringify(this.state) !== JSON.stringify(prevState)) {\n        if (JSON.stringify(prevMainShapes) !== JSON.stringify(currentMainShapes)) {\n          //if text shouldn't update, don't append to  history\n          if (this.state.shouldTextUpdate) {\n            var uh = history;\n            history = uh.slice(0, historyStep + 1); //console.log(\"sliced\", history);\n\n            var toAppend = this.state;\n            history = history.concat(toAppend); //console.log(\"new\", history);\n\n            historyStep += 1; //console.log(history, historyStep, history[historyStep]);\n          }\n        }\n      } else {//console.log(\"compoenntDidUpdate but attrs didn't change\");\n        }\n      this.state.redoing = false;\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function () {\n      var _componentDidMount = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _this3 = this;\n\n        var path;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                history.push(this.state);\n                this.setState({\n                  selectedShapeName: ''\n                });\n                path = this.props.history.location.pathname; //if draft\n\n                if (!path.includes('draft')) {\n                  _context.next = 7;\n                  break;\n                }\n\n                path = path.slice(14);\n                _context.next = 7;\n                return fetch('/api/roadmap/getRoadmapById', {\n                  method: 'POST',\n                  headers: {\n                    'Content-Type': 'application/json'\n                  },\n                  body: JSON.stringify({\n                    roadmapId: path,\n                    userId: this.props.auth.user.id\n                  })\n                }).then(function (res) {\n                  res.json().then(function (roadmap) {\n                    //if no permission\n                    if (roadmap && roadmap.message) {\n                      alert(roadmap.message);\n\n                      _this3.props.history.push('/');\n                    } else if (!_this3.props.auth.isAuthenticated || roadmap.author_id !== _this3.props.auth.user.id) {\n                      //also if no permission\n                      alert('You do not have permission!');\n\n                      _this3.props.history.push('/');\n                    } else {\n                      var data = roadmap.data;\n                      var isDraft = roadmap.is_draft; //if saved was draft instead of alreadyCreated\n\n                      if (isDraft) {\n                        var roadmapData = JSON.parse(data);\n                        roadmapData.arrows.forEach(function (eachArrow) {\n                          if (eachArrow.from && _this3.IsJsonString(eachArrow.from)) eachArrow.from = JSON.parse(eachArrow.from);\n                          if (eachArrow.to && _this3.IsJsonString(eachArrow.to)) eachArrow.to = JSON.parse(eachArrow.to);\n                        });\n\n                        _this3.setState({\n                          rectangles: roadmapData.rects,\n                          ellipses: roadmapData.ellipses,\n                          stars: roadmapData.stars,\n                          arrows: roadmapData.arrows,\n                          texts: roadmapData.texts,\n                          roadmapId: roadmap._id,\n                          is_draft: roadmap.is_draft\n                        }, function () {});\n                      } else {\n                        //accessing already created through /create/edit\n                        _this3.setState({\n                          alreadyCreated: true\n                        });\n\n                        roadmapData = JSON.parse(data);\n\n                        while (_this3.IsJsonString(roadmapData)) {\n                          roadmapData = JSON.parse(roadmapData);\n                        }\n\n                        roadmapData.arrows.forEach(function (eachArrow) {\n                          if (eachArrow.from && _this3.IsJsonString(eachArrow.from)) eachArrow.from = JSON.parse(eachArrow.from);\n                          if (eachArrow.to && _this3.IsJsonString(eachArrow.to)) eachArrow.to = JSON.parse(eachArrow.to);\n                        });\n\n                        _this3.setState({\n                          rectangles: roadmapData.rects,\n                          ellipses: roadmapData.ellipses,\n                          stars: roadmapData.stars,\n                          arrows: roadmapData.arrows,\n                          texts: roadmapData.texts,\n                          roadmapId: roadmap._id,\n                          is_draft: roadmap.is_draft\n                        });\n                      }\n\n                      console.log('ellipse', _this3.state.ellipses[0]);\n                      console.log('arrow', _this3.state.arrows[0]);\n                      console.log('texts', _this3.state.texts[0]);\n                    }\n                  });\n                });\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function componentDidMount() {\n        return _componentDidMount.apply(this, arguments);\n      }\n\n      return componentDidMount;\n    }()\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      var saveText;\n      var saveButton;\n      var saving = this.state.saving;\n\n      if (saving !== null) {\n        if (saving) {\n          saveText = React.createElement(\"div\", {\n            style: {\n              color: 'white'\n            },\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 685\n            },\n            __self: this\n          }, \"Saving\");\n        } else {\n          saveText = React.createElement(\"div\", {\n            style: {\n              color: 'white'\n            },\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 687\n            },\n            __self: this\n          }, \"Saved\");\n        }\n      }\n\n      if (!saving || saving === null) {\n        saveButton = React.createElement(Button, {\n          style: {\n            backgroundColor: '#5a10b9',\n            color: 'white'\n          },\n          onClick: this.handleSave,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 692\n          },\n          __self: this\n        }, \"Save\");\n      } else {\n        saveButton = React.createElement(Button, {\n          style: {\n            backgroundColor: 'grey',\n            color: 'white'\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 701\n          },\n          __self: this\n        }, \"Saving\");\n      }\n\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d');\n      var gradient = ctx.createLinearGradient(0, 0, 100, 100);\n      gradient.addColorStop(0.0, 'red');\n      gradient.addColorStop(1 / 6, 'orange');\n      gradient.addColorStop(2 / 6, 'yellow');\n      gradient.addColorStop(3 / 6, 'green');\n      gradient.addColorStop(4 / 6, 'aqua');\n      gradient.addColorStop(5 / 6, 'blue');\n      gradient.addColorStop(1.0, 'purple');\n      var errMsg = this.state.errMsg;\n      var errDisplay;\n\n      if (errMsg !== '') {\n        errDisplay = React.createElement(\"div\", {\n          className: \"errMsginner\",\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 723\n          },\n          __self: this\n        }, React.createElement(\"span\", {\n          style: {\n            color: 'white'\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 724\n          },\n          __self: this\n        }, errMsg !== '' ? errMsg : null));\n      } else {}\n\n      var countryOptions = [{\n        key: '1',\n        value: 'Machine Learning',\n        text: 'Machine Learning'\n      }, {\n        key: '2',\n        value: 'Computer Science',\n        text: 'Computer Science'\n      }, {\n        key: '3',\n        value: 'Software Engineering',\n        text: 'Software Engineering'\n      }, {\n        key: '12',\n        value: 'Technology',\n        text: 'Technology'\n      }, {\n        key: '4',\n        value: 'Engineering',\n        text: 'Engineering'\n      }, {\n        key: '6',\n        value: 'Sciences and Mathematics',\n        text: 'Sciences and Mathematics'\n      }, {\n        key: '7',\n        value: 'Law, Economics and Social Sciences',\n        text: 'Law, Economics and Social Sciences'\n      }, {\n        key: '8',\n        value: 'Humanities',\n        text: 'Humanities'\n      }, {\n        key: '9',\n        value: 'Linguistics and Cultural Studies',\n        text: 'Linguistics and Cultural Studies'\n      }, {\n        key: '10',\n        value: 'Art and Music',\n        text: 'Art and Music'\n      }, {\n        key: '11',\n        value: 'Lifestyle',\n        text: 'Lifestyle'\n      }, {\n        key: '13',\n        value: 'Others',\n        text: 'Others'\n      }];\n      return React.createElement(React.Fragment, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 769\n        },\n        __self: this\n      }, React.createElement(\"div\", {\n        onKeyDown: function onKeyDown(event) {\n          var x = 88,\n              deleteKey = 46,\n              copy = 67,\n              paste = 86,\n              z = 90,\n              y = 89;\n\n          if ((event.ctrlKey && event.keyCode === x || event.keyCode === deleteKey) && !_this4.state.isPasteDisabled) {\n            if (_this4.state.selectedShapeName !== '') {\n              var that = _this4; //delete it from the state too\n\n              var name = _this4.state.selectedShapeName;\n              var rectDeleted = false,\n                  ellipseDeleted = false,\n                  starDeleted = false,\n                  arrowDeleted = false,\n                  textDeleted = false;\n\n              var rects = _this4.state.rectangles.filter(function (eachRect) {\n                if (eachRect.name === name) {\n                  that.setState({\n                    rectDeleteCount: that.state.rectDeleteCount + 1\n                  });\n                }\n\n                return eachRect.name !== name;\n              });\n\n              var ellipses = _this4.state.ellipses.filter(function (eachRect) {\n                if (eachRect.name === name) {\n                  that.setState({\n                    ellipseDeleteCount: that.state.ellipseDeleteCount + 1\n                  });\n                }\n\n                return eachRect.name !== name;\n              });\n\n              var stars = _this4.state.stars.filter(function (eachRect) {\n                if (eachRect.name === name) {\n                  that.setState({\n                    starDeleteCount: that.state.starDeleteCount + 1\n                  });\n                }\n\n                return eachRect.name !== name;\n              });\n\n              var arrows = _this4.state.arrows.filter(function (eachRect) {\n                if (eachRect.name === name) {\n                  that.setState({\n                    arrowDeleteCount: that.state.arrowDeleteCount + 1\n                  });\n                }\n\n                return eachRect.name !== name;\n              });\n\n              var texts = _this4.state.texts.filter(function (eachRect) {\n                if (eachRect.name === name) {\n                  that.setState({\n                    textDeleteCount: that.state.textDeleteCount + 1\n                  });\n                }\n\n                return eachRect.name !== name;\n              });\n\n              _this4.setState({\n                rectangles: rects,\n                ellipses: ellipses,\n                stars: stars,\n                arrows: arrows,\n                texts: texts,\n                selectedShapeName: ''\n              });\n            }\n          } else if (event.shiftKey && event.ctrlKey && event.keyCode === z) {\n            _this4.handleRedo();\n          } else if (event.ctrlKey && event.keyCode === z) {\n            _this4.handleUndo();\n          } else if (event.ctrlKey && event.keyCode === y) {\n            _this4.handleRedo();\n          } else if (event.ctrlKey && event.keyCode === copy) {\n            if (_this4.state.selectedShapeName !== '') {\n              //find it\n              var _name = _this4.state.selectedShapeName;\n              var copiedElement = null;\n\n              if (_name.includes('rect')) {\n                copiedElement = _this4.state.rectangles.filter(function (eachRect) {\n                  return eachRect.name === _name;\n                });\n              } else if (_name.includes('ellipse')) {\n                copiedElement = _this4.state.ellipses.filter(function (eachRect) {\n                  return eachRect.name === _name;\n                });\n              } else if (_name.includes('star')) {\n                copiedElement = _this4.state.stars.filter(function (eachRect) {\n                  return eachRect.name === _name;\n                });\n              } else if (_name.includes('text')) {\n                copiedElement = _this4.state.texts.filter(function (eachRect) {\n                  return eachRect.name === _name;\n                });\n              } else if (_name.includes('arrow')) {\n                copiedElement = _this4.state.arrows.filter(function (eachRect) {\n                  return eachRect.name === _name;\n                });\n              }\n\n              _this4.setState({\n                copiedElement: copiedElement\n              }, function () {\n                console.log('copied ele', _this4.state.copiedElement);\n              });\n            }\n          } else if (event.ctrlKey && event.keyCode === paste && !_this4.state.isPasteDisabled) {\n            var _copiedElement = _this4.state.copiedElement[0];\n            console.log(_copiedElement);\n            var length;\n\n            if (_copiedElement) {\n              if (_copiedElement.attrs) {} else {\n                if (_copiedElement.name.includes('rectangle')) {\n                  length = _this4.state.rectangles.length + 1 + _this4.state.rectDeleteCount;\n                  var toPush = {\n                    x: _copiedElement.x + 10,\n                    y: _copiedElement.y + 10,\n                    width: _copiedElement.width,\n                    height: _copiedElement.height,\n                    stroke: _copiedElement.stroke,\n                    strokeWidth: _copiedElement.strokeWidth,\n                    name: 'rectangle' + (_this4.state.rectangles.length + _this4.state.rectDeleteCount + 1),\n                    ref: 'rectangle' + (_this4.state.rectangles.length + _this4.state.rectDeleteCount + 1),\n                    fill: _copiedElement.fill,\n                    useImage: _copiedElement.useImage,\n                    link: _copiedElement.link,\n                    rotation: _copiedElement.rotation\n                  };\n                  var newName = _this4.state.selectedShapeName;\n\n                  _this4.setState(function (prevState) {\n                    return {\n                      rectangles: [].concat(_toConsumableArray(prevState.rectangles), [toPush])\n                    };\n                  }, function () {\n                    _this4.setState({\n                      selectedShapeName: 'rectangle' + _this4.state.rectangles.length\n                    });\n                  });\n                } else if (_copiedElement.name.includes('arrow')) {\n                  length = _this4.state.arrows.length + 1 + _this4.state.arrowDeleteCount;\n\n                  if (_copiedElement.to || _copiedElement.from) {\n                    _this4.setState({\n                      errMsg: 'Connectors cannot be pasted'\n                    }, function () {\n                      var that = _this4;\n                      setTimeout(function () {\n                        that.setState({\n                          errMsg: ''\n                        });\n                      }, 1000);\n                    });\n                  } else {\n                    var toPush = {\n                      points: [_copiedElement.points[0] + 30, _copiedElement.points[1] + 30, _copiedElement.points[2] + 30, _copiedElement.points[3] + 30],\n                      fill: _copiedElement.fill,\n                      link: _copiedElement.link,\n                      stroke: _copiedElement.stroke,\n                      strokeWidth: _copiedElement.strokeWidth,\n                      name: 'arrow' + (_this4.state.arrows.length + 1 + _this4.state.arrowDeleteCount),\n                      ref: 'arrow' + (_this4.state.arrows.length + 1 + _this4.state.arrowDeleteCount),\n                      rotation: _copiedElement.rotation\n                    };\n                    var _newName = _this4.state.selectedShapeName;\n\n                    _this4.setState(function (prevState) {\n                      return {\n                        arrows: [].concat(_toConsumableArray(prevState.arrows), [toPush])\n                      };\n                    }, function () {\n                      _this4.setState({\n                        selectedShapeName: 'arrow' + _this4.state.arrows.length\n                      });\n                    });\n                  }\n                } else if (_copiedElement.name.includes('ellipse')) {\n                  length = _this4.state.ellipses.length + 1 + _this4.state.ellipseDeleteCount;\n                  var toPush = {\n                    x: _copiedElement.x + 10,\n                    y: _copiedElement.y + 10,\n                    radiusX: _copiedElement.radiusX,\n                    radiusY: _copiedElement.radiusY,\n                    stroke: _copiedElement.stroke,\n                    strokeWidth: _copiedElement.strokeWidth,\n                    name: 'ellipse' + (_this4.state.ellipses.length + 1 + _this4.state.ellipseDeleteCount),\n                    ref: 'ellipse' + (_this4.state.ellipses.length + 1 + _this4.state.ellipseDeleteCount),\n                    fill: _copiedElement.fill,\n                    link: _copiedElement.link,\n                    useImage: _copiedElement.useImage,\n                    rotation: _copiedElement.rotation\n                  };\n                  var _newName2 = _this4.state.selectedShapeName;\n\n                  _this4.setState(function (prevState) {\n                    return {\n                      ellipses: [].concat(_toConsumableArray(prevState.ellipses), [toPush])\n                    };\n                  }, function () {\n                    _this4.setState({\n                      selectedShapeName: 'ellipse' + _this4.state.ellipses.length\n                    });\n                  });\n                } else if (_copiedElement.name.includes('star')) {\n                  length = _this4.state.stars.length + 1 + _this4.state.starDeleteCount;\n                  var toPush = {\n                    x: _copiedElement.x + 10,\n                    y: _copiedElement.y + 10,\n                    link: _copiedElement.link,\n                    innerRadius: _copiedElement.innerRadius,\n                    outerRadius: _copiedElement.outerRadius,\n                    stroke: _copiedElement.stroke,\n                    strokeWidth: _copiedElement.strokeWidth,\n                    name: 'star' + (_this4.state.stars.length + 1 + _this4.state.starDeleteCount),\n                    ref: 'star' + (_this4.state.stars.length + 1 + _this4.state.starDeleteCount),\n                    fill: _copiedElement.fill,\n                    useImage: _copiedElement.useImage,\n                    rotation: _copiedElement.rotation\n                  };\n                  var _newName3 = _this4.state.selectedShapeName;\n\n                  _this4.setState(function (prevState) {\n                    return {\n                      stars: [].concat(_toConsumableArray(prevState.stars), [toPush])\n                    };\n                  }, function () {\n                    _this4.setState({\n                      selectedShapeName: 'star' + _this4.state.stars.length\n                    });\n                  });\n                } else if (_copiedElement.name.includes('text')) {\n                  length = _this4.state.texts.length + 1 + _this4.state.textDeleteCount;\n                  var toPush = {\n                    x: _copiedElement.x + 10,\n                    y: _copiedElement.y + 10,\n                    link: _copiedElement.link,\n                    name: 'text' + (_this4.state.texts.length + 1 + _this4.state.textDeleteCount),\n                    ref: 'text' + (_this4.state.texts.length + 1 + _this4.state.textDeleteCount),\n                    fill: _copiedElement.fill,\n                    fontSize: _copiedElement.fontSize,\n                    fontFamily: _copiedElement.fontFamily,\n                    useImage: _copiedElement.useImage,\n                    text: _copiedElement.text,\n                    width: _copiedElement.width,\n                    rotation: _copiedElement.rotation\n                  };\n                  var _newName4 = _this4.state.selectedShapeName;\n\n                  _this4.setState(function (prevState) {\n                    return {\n                      texts: [].concat(_toConsumableArray(prevState.texts), [toPush])\n                    };\n                  }, function () {\n                    _this4.setState({\n                      selectedShapeName: 'text' + (_this4.state.texts.length + _this4.state.textDeleteCount)\n                    }, function () {\n                      console.log(_this4.state.selectedShapeName);\n                    });\n                  });\n                }\n              }\n            }\n          }\n        },\n        tabIndex: \"0\",\n        style: {\n          outline: 'none'\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 771\n        },\n        __self: this\n      }, React.createElement(Stage, {\n        onClick: this.handleStageClick,\n        onMouseMove: this.handleMouseOver,\n        onWheel: function onWheel(event) {\n          return _this4.handleWheel(event);\n        },\n        height: window.innerHeight,\n        width: window.innerWidth,\n        ref: \"graphicStage\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1229\n        },\n        __self: this\n      }, React.createElement(Layer, {\n        scaleX: this.state.layerScale,\n        scaleY: this.state.layerScale,\n        x: this.state.layerX,\n        y: this.state.layerY,\n        height: window.innerHeight,\n        width: window.innerWidth,\n        draggable: true,\n        onDragEnd: function onDragEnd() {\n          _this4.setState({\n            layerX: _this4.refs.layer2.x(),\n            layerY: _this4.refs.layer2.y()\n          });\n        },\n        ref: \"layer2\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1237\n        },\n        __self: this\n      }, React.createElement(Rect, {\n        x: -5 * window.innerWidth,\n        y: -5 * window.innerHeight,\n        height: window.innerHeight * 10,\n        width: window.innerWidth * 10,\n        name: \"\",\n        id: \"ContainerRect\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 1253\n        },\n        __self: this\n      }), this.state.rectangles.map(function (eachRect) {\n        return React.createElement(Rect, {\n          onClick: function onClick() {\n            var that = _this4;\n\n            if (eachRect.link !== undefined && eachRect.link !== '') {\n              _this4.setState({\n                errMsg: 'Links will not be opened in create mode'\n              }, function () {\n                setTimeout(function () {\n                  that.setState({\n                    errMsg: ''\n                  });\n                }, 1000);\n              });\n            }\n          },\n          onTransformStart: function onTransformStart() {\n            _this4.setState({\n              isTransforming: true\n            });\n\n            var rect = _this4.refs[eachRect.ref];\n            rect.setAttr('lastRotation', rect.rotation());\n          },\n          onTransform: function onTransform() {\n            var rect = _this4.refs[eachRect.ref];\n\n            if (rect.attrs.lastRotation !== rect.rotation()) {\n              _this4.state.arrows.map(function (eachArrow) {\n                if (eachArrow.to && eachArrow.to.name() === rect.name()) {\n                  _this4.setState({\n                    errMsg: 'Rotating rects with connectors might skew things up!'\n                  });\n                }\n\n                if (eachArrow.from && eachArrow.from.name() === rect.name()) {\n                  _this4.setState({\n                    errMsg: 'Rotating rects with connectors might skew things up!'\n                  });\n                }\n              });\n            }\n\n            rect.setAttr('lastRotation', rect.rotation());\n          },\n          onTransformEnd: function onTransformEnd() {\n            _this4.setState({\n              isTransforming: false\n            });\n\n            var rect = _this4.refs[eachRect.ref];\n\n            _this4.setState(function (prevState) {\n              return {\n                errMsg: '',\n                rectangles: prevState.rectangles.map(function (eachRect) {\n                  return eachRect.name === rect.attrs.name ? _objectSpread({}, eachRect, {\n                    width: rect.width() * rect.scaleX(),\n                    height: rect.height() * rect.scaleY(),\n                    rotation: rect.rotation(),\n                    x: rect.x(),\n                    y: rect.y()\n                  }) : eachRect;\n                })\n              };\n            }, function () {\n              _this4.forceUpdate();\n            });\n\n            rect.setAttr('scaleX', 1);\n            rect.setAttr('scaleY', 1);\n          },\n          rotation: eachRect.rotation,\n          ref: eachRect.ref,\n          fill: eachRect.fill,\n          name: eachRect.name,\n          x: eachRect.x,\n          y: eachRect.y,\n          width: eachRect.width,\n          height: eachRect.height,\n          stroke: eachRect.stroke,\n          strokeWidth: eachRect.strokeWidth,\n          strokeScaleEnabled: false,\n          draggable: true,\n          onDragMove: function onDragMove() {\n            _this4.state.arrows.map(function (eachArrow) {\n              if (eachArrow.from !== undefined) {\n                if (eachRect.name === eachArrow.from.attrs.name) {\n                  eachArrow.points = [eachRect.x, eachRect.y, eachArrow.points[2], eachArrow.points[3]];\n\n                  _this4.forceUpdate();\n                }\n              }\n\n              if (eachArrow.to !== undefined) {\n                if (eachRect.name == eachArrow.to.attrs.name) {\n                  eachArrow.points = [eachArrow.points[0], eachArrow.points[1], eachRect.x, eachRect.y];\n\n                  _this4.forceUpdate();\n                }\n              }\n            });\n          },\n          onDragEnd: function onDragEnd(event) {\n            //cannot compare by name because currentSelected might not be the same\n            //have to use ref, which appears to be overcomplicated\n            var shape = _this4.refs[eachRect.ref];\n            /*    this.state.rectangles.map(eachRect => {\r\n            if (eachRect.name === shape.attrs.name) {\r\n            shape.position({\r\n            x: event.target.x(),\r\n            y: event.target.y()\r\n            });\r\n            }\r\n            });*/\n\n            _this4.setState(function (prevState) {\n              return {\n                rectangles: prevState.rectangles.map(function (eachRect) {\n                  return eachRect.name === shape.attrs.name ? _objectSpread({}, eachRect, {\n                    x: event.target.x(),\n                    y: event.target.y()\n                  }) : eachRect;\n                })\n              };\n            });\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1264\n          },\n          __self: this\n        });\n      }), this.state.ellipses.map(function (eachEllipse) {\n        return React.createElement(Ellipse, {\n          ref: eachEllipse.ref,\n          name: eachEllipse.name,\n          x: eachEllipse.x,\n          y: eachEllipse.y,\n          rotation: eachEllipse.rotation,\n          radiusX: eachEllipse.radiusX,\n          radiusY: eachEllipse.radiusY,\n          fill: eachEllipse.fill,\n          stroke: eachEllipse.stroke,\n          strokeWidth: eachEllipse.strokeWidth,\n          strokeScaleEnabled: false,\n          onClick: function onClick() {\n            var that = _this4;\n\n            if (eachEllipse.link !== undefined && eachEllipse.link !== '') {\n              _this4.setState({\n                errMsg: 'Links will not be opened in create mode'\n              }, function () {\n                setTimeout(function () {\n                  that.setState({\n                    errMsg: ''\n                  });\n                }, 1000);\n              });\n            }\n          },\n          onTransformStart: function onTransformStart() {\n            _this4.setState({\n              isTransforming: true\n            });\n\n            var ellipse = _this4.refs[eachEllipse.ref];\n            ellipse.setAttr('lastRotation', ellipse.rotation());\n          },\n          onTransform: function onTransform() {\n            var ellipse = _this4.refs[eachEllipse.ref];\n\n            if (ellipse.attrs.lastRotation !== ellipse.rotation()) {\n              _this4.state.arrows.map(function (eachArrow) {\n                if (eachArrow.to && eachArrow.to.name() === ellipse.name()) {\n                  _this4.setState({\n                    errMsg: 'Rotating ellipses with connectors might skew things up!'\n                  });\n                }\n\n                if (eachArrow.from && eachArrow.from.name() === ellipse.name()) {\n                  _this4.setState({\n                    errMsg: 'Rotating ellipses with connectors might skew things up!'\n                  });\n                }\n              });\n            }\n\n            ellipse.setAttr('lastRotation', ellipse.rotation());\n          },\n          onTransformEnd: function onTransformEnd() {\n            _this4.setState({\n              isTransforming: false\n            });\n\n            var ellipse = _this4.refs[eachEllipse.ref];\n            var scaleX = ellipse.scaleX(),\n                scaleY = ellipse.scaleY();\n\n            _this4.setState(function (prevState) {\n              return {\n                errMsg: '',\n                ellipses: prevState.ellipses.map(function (eachEllipse) {\n                  return eachEllipse.name === ellipse.attrs.name ? _objectSpread({}, eachEllipse, {\n                    radiusX: ellipse.radiusX() * ellipse.scaleX(),\n                    radiusY: ellipse.radiusY() * ellipse.scaleY(),\n                    rotation: ellipse.rotation(),\n                    x: ellipse.x(),\n                    y: ellipse.y()\n                  }) : eachEllipse;\n                })\n              };\n            });\n\n            ellipse.setAttr('scaleX', 1);\n            ellipse.setAttr('scaleY', 1);\n\n            _this4.forceUpdate();\n          },\n          draggable: true,\n          onDragMove: function onDragMove() {\n            console.log('name of ellipse moving: ', eachEllipse.name, 'new x y', eachEllipse.x, eachEllipse.y);\n\n            _this4.state.arrows.map(function (eachArrow) {\n              if (eachArrow.from !== undefined) {\n                console.log('prevArrow: ', eachArrow.points);\n\n                if (eachEllipse.name == eachArrow.from.attrs.name) {\n                  eachArrow.points = [eachEllipse.x, eachEllipse.y, eachArrow.points[2], eachArrow.points[3]];\n\n                  _this4.forceUpdate();\n\n                  _this4.refs.graphicStage.draw();\n                }\n\n                console.log('new arrows:', eachArrow.points);\n              }\n\n              if (eachArrow.to !== undefined) {\n                if (eachEllipse.name === eachArrow.to.attrs.name) {\n                  eachArrow.points = [eachArrow.points[0], eachArrow.points[1], eachEllipse.x, eachEllipse.y];\n\n                  _this4.forceUpdate();\n\n                  _this4.refs.graphicStage.draw();\n                }\n              }\n            });\n          },\n          onDragEnd: function onDragEnd(event) {\n            //cannot compare by name because currentSelected might not be the same\n            //have to use ref, which appears to be overcomplicated\n            var shape = _this4.refs[eachEllipse.ref];\n\n            _this4.setState(function (prevState) {\n              return {\n                ellipses: prevState.ellipses.map(function (eachEllipse) {\n                  return eachEllipse.name === shape.attrs.name ? _objectSpread({}, eachEllipse, {\n                    x: event.target.x(),\n                    y: event.target.y()\n                  }) : eachEllipse;\n                })\n              };\n            });\n\n            _this4.refs.graphicStage.draw();\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1450\n          },\n          __self: this\n        });\n      }), this.state.stars.map(function (eachStar) {\n        return React.createElement(Star, {\n          ref: eachStar.ref,\n          name: eachStar.name,\n          x: eachStar.x,\n          y: eachStar.y,\n          innerRadius: eachStar.innerRadius,\n          outerRadius: eachStar.outerRadius,\n          numPoints: eachStar.numPoints,\n          stroke: eachStar.stroke,\n          strokeWidth: eachStar.strokeWidth,\n          fill: eachStar.fill,\n          strokeScaleEnabled: false,\n          rotation: eachStar.rotation,\n          onClick: function onClick() {\n            var that = _this4;\n\n            if (eachStar.link !== undefined && eachStar.link !== '') {\n              _this4.setState({\n                errMsg: 'Links will not be opened in create mode'\n              }, function () {\n                setTimeout(function () {\n                  that.setState({\n                    errMsg: ''\n                  });\n                }, 1000);\n              });\n            }\n          },\n          onTransformStart: function onTransformStart() {\n            _this4.setState({\n              isTransforming: true\n            });\n          },\n          onTransformEnd: function onTransformEnd() {\n            _this4.setState({\n              isTransforming: false\n            });\n\n            var star = _this4.refs[eachStar.ref];\n            var scaleX = star.scaleX(),\n                scaleY = star.scaleY();\n\n            _this4.setState(function (prevState) {\n              return {\n                stars: prevState.stars.map(function (eachStar) {\n                  return eachStar.name === star.attrs.name ? _objectSpread({}, eachStar, {\n                    innerRadius: star.innerRadius() * star.scaleX(),\n                    outerRadius: star.outerRadius() * star.scaleX(),\n                    rotation: star.rotation(),\n                    x: star.x(),\n                    y: star.y()\n                  }) : eachStar;\n                })\n              };\n            });\n\n            star.setAttr('scaleX', 1);\n            star.setAttr('scaleY', 1);\n\n            _this4.forceUpdate();\n          },\n          draggable: true,\n          onDragMove: function onDragMove() {\n            _this4.state.arrows.map(function (eachArrow) {\n              if (eachArrow.from !== undefined) {\n                if (eachStar.name == eachArrow.from.attrs.name) {\n                  eachArrow.points = [eachStar.x, eachStar.y, eachArrow.points[2], eachArrow.points[3]];\n\n                  _this4.forceUpdate();\n                }\n              }\n\n              if (eachArrow.to !== undefined) {\n                if (eachStar.name === eachArrow.to.attrs.name) {\n                  eachArrow.points = [eachArrow.points[0], eachArrow.points[1], eachStar.x, eachStar.y];\n\n                  _this4.forceUpdate();\n                }\n              }\n            });\n          },\n          onDragEnd: function onDragEnd(event) {\n            //cannot compare by name because currentSelected might not be the same\n            //have to use ref, which appears to be overcomplicated\n            var shape = _this4.refs[eachStar.ref];\n\n            _this4.setState(function (prevState) {\n              return {\n                stars: prevState.stars.map(function (eachStar) {\n                  return eachStar.name === shape.attrs.name ? _objectSpread({}, eachStar, {\n                    x: event.target.x(),\n                    y: event.target.y()\n                  }) : eachStar;\n                })\n              };\n            });\n          },\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 1635\n          },\n          __self: this\n        });\n      }), this.state.texts.map(function (eachText) {\n        return (//perhaps this.state.texts only need to contain refs?\n          //so that we only need to store the refs to get more information\n          React.createElement(Text, {\n            textDecoration: eachText.link ? 'underline' : '',\n            onTransformStart: function onTransformStart() {\n              var currentText = _this4.refs[_this4.state.selectedShapeName];\n              currentText.setAttr('lastRotation', currentText.rotation());\n            },\n            onTransform: function onTransform() {\n              var currentText = _this4.refs[_this4.state.selectedShapeName];\n              currentText.setAttr('width', currentText.width() * currentText.scaleX());\n              currentText.setAttr('scaleX', 1);\n              currentText.draw();\n\n              if (currentText.attrs.lastRotation !== currentText.rotation()) {\n                _this4.state.arrows.map(function (eachArrow) {\n                  if (eachArrow.to && eachArrow.to.name() === currentText.name()) {\n                    _this4.setState({\n                      errMsg: 'Rotating texts with connectors might skew things up!'\n                    });\n                  }\n\n                  if (eachArrow.from && eachArrow.from.name() === currentText.name()) {\n                    _this4.setState({\n                      errMsg: 'Rotating texts with connectors might skew things up!'\n                    });\n                  }\n                });\n              }\n\n              currentText.setAttr('lastRotation', currentText.rotation());\n            },\n            onTransformEnd: function onTransformEnd() {\n              var currentText = _this4.refs[_this4.state.selectedShapeName];\n\n              _this4.setState(function (prevState) {\n                return {\n                  errMsg: '',\n                  texts: prevState.texts.map(function (eachText) {\n                    return eachText.name === _this4.state.selectedShapeName ? _objectSpread({}, eachText, {\n                      width: currentText.width(),\n                      rotation: currentText.rotation(),\n                      textWidth: currentText.textWidth,\n                      textHeight: currentText.textHeight,\n                      x: currentText.x(),\n                      y: currentText.y()\n                    }) : eachText;\n                  })\n                };\n              });\n\n              currentText.setAttr('scaleX', 1);\n              currentText.draw();\n            },\n            link: eachText.link,\n            width: eachText.width,\n            fill: eachText.fill,\n            name: eachText.name,\n            ref: eachText.ref,\n            rotation: eachText.rotation,\n            fontFamily: eachText.fontFamily,\n            fontSize: eachText.fontSize,\n            x: eachText.x,\n            y: eachText.y,\n            text: eachText.text,\n            draggable: true,\n            onDragMove: function onDragMove() {\n              _this4.state.arrows.map(function (eachArrow) {\n                if (eachArrow.from !== undefined) {\n                  if (eachText.name === eachArrow.from.attrs.name) {\n                    eachArrow.points = [eachText.x, eachText.y, eachArrow.points[2], eachArrow.points[3]];\n\n                    _this4.forceUpdate();\n                  }\n                }\n\n                if (eachArrow.to !== undefined) {\n                  if (eachText.name === eachArrow.to.attrs.name) {\n                    eachArrow.points = [eachArrow.points[0], eachArrow.points[1], eachText.x, eachText.y];\n\n                    _this4.forceUpdate();\n                  }\n                }\n              });\n            },\n            onDragEnd: function onDragEnd(event) {\n              //cannot compare by name because currentSelected might not be the same\n              //have to use ref, which appears to be overcomplicated\n              var shape = _this4.refs[eachText.ref];\n\n              _this4.setState(function (prevState) {\n                return {\n                  texts: prevState.texts.map(function (eachtext) {\n                    return eachtext.name === shape.attrs.name ? _objectSpread({}, eachtext, {\n                      x: event.target.x(),\n                      y: event.target.y()\n                    }) : eachtext;\n                  })\n                };\n              });\n            },\n            onClick: function onClick() {\n              var that = _this4;\n\n              if (eachText.link !== undefined && eachText.link !== '') {\n                _this4.setState({\n                  errMsg: 'Links will not be opened in create mode'\n                }, function () {\n                  setTimeout(function () {\n                    that.setState({\n                      errMsg: ''\n                    });\n                  }, 1000);\n                }); //var win = window.open(eachText.link, \"_blank\");\n                //win.focus();\n\n              }\n            },\n            onDblClick: function onDblClick() {\n              // turn into textarea\n              var stage = _this4.refs.graphicStage;\n              var text = stage.findOne('.' + eachText.name);\n\n              _this4.setState({\n                textX: text.absolutePosition().x,\n                textY: text.absolutePosition().y,\n                textEditVisible: !_this4.state.textEditVisible,\n                text: eachText.text,\n                textNode: eachText,\n                currentTextRef: eachText.ref,\n                textareaWidth: text.textWidth,\n                textareaHeight: text.textHeight,\n                textareaFill: text.attrs.fill,\n                textareaFontFamily: text.attrs.fontFamily,\n                textareaFontSize: text.attrs.fontSize\n              });\n\n              var textarea = _this4.refs.textarea;\n              textarea.focus();\n              text.hide();\n              var transformer = stage.findOne('.transformer');\n              transformer.hide();\n\n              _this4.refs.layer2.draw();\n            },\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 1760\n            },\n            __self: this\n          })\n        );\n      }), this.state.arrows.map(function (eachArrow) {\n        if (!eachArrow.from && !eachArrow.to) {\n          return React.createElement(Arrow, {\n            ref: eachArrow.ref,\n            name: eachArrow.name,\n            points: [eachArrow.points[0], eachArrow.points[1], eachArrow.points[2], eachArrow.points[3]],\n            stroke: eachArrow.stroke,\n            fill: eachArrow.fill,\n            draggable: true,\n            onDragEnd: function onDragEnd(event) {\n              //set new points to current position\n              //usually: state => star => x & y\n              //now: state => arrow => attr => x & y\n              var oldPoints = [eachArrow.points[0], eachArrow.points[1], eachArrow.points[2], eachArrow.points[3]];\n              var shiftX = _this4.refs[eachArrow.ref].attrs.x;\n              var shiftY = _this4.refs[eachArrow.ref].attrs.y;\n              var newPoints = [oldPoints[0] + shiftX, oldPoints[1] + shiftY, oldPoints[2] + shiftX, oldPoints[3] + shiftY];\n\n              _this4.refs[eachArrow.ref].position({\n                x: 0,\n                y: 0\n              });\n\n              _this4.refs.layer2.draw();\n\n              _this4.setState(function (prevState) {\n                return {\n                  arrows: prevState.arrows.map(function (eachArr) {\n                    return eachArr.name === eachArrow.name ? _objectSpread({}, eachArr, {\n                      points: newPoints\n                    }) : eachArr;\n                  })\n                };\n              });\n            },\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 1973\n            },\n            __self: this\n          });\n        } else if (eachArrow.name === _this4.state.newArrowRef && (eachArrow.from || eachArrow.to)) {\n          return React.createElement(Connector, {\n            name: eachArrow.name,\n            from: eachArrow.from,\n            to: eachArrow.to,\n            arrowEndX: _this4.state.arrowEndX,\n            arrowEndY: _this4.state.arrowEndY,\n            current: true,\n            stroke: eachArrow.stroke,\n            fill: eachArrow.fill,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 2037\n            },\n            __self: this\n          });\n        } else if (eachArrow.from || eachArrow.to) {\n          //if arrow construction is completed\n          return React.createElement(Connector, {\n            name: eachArrow.name,\n            from: eachArrow.from,\n            to: eachArrow.to,\n            points: eachArrow.points,\n            current: false,\n            stroke: eachArrow.stroke,\n            fill: eachArrow.fill,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 2051\n            },\n            __self: this\n          });\n        }\n      }), this.state.selectedShapeName.includes('text') ? React.createElement(TransformerComponent, {\n        selectedShapeName: this.state.selectedShapeName,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 2065\n        },\n        __self: this\n      }) : React.createElement(TransformerComponent, {\n        selectedShapeName: this.state.selectedShapeName,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 2071\n        },\n        __self: this\n      })), React.createElement(Layer, {\n        height: window.innerHeight,\n        width: window.innerWidth,\n        ref: \"layer\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 2079\n        },\n        __self: this\n      }, React.createElement(Toolbar, {\n        layer: this.refs.layer2,\n        rectName: this.state.rectangles.length + 1 + this.state.rectDeleteCount,\n        ellipseName: this.state.ellipses.length + 1 + this.state.ellipseDeleteCount,\n        starName: this.state.stars.length + 1 + this.state.starDeleteCount,\n        textName: this.state.texts.length + 1 + this.state.textDeleteCount,\n        newArrowOnDragEnd: function newArrowOnDragEnd(toPush) {\n          if (toPush.from !== undefined) {\n            //  console.log(\"we are making a connector\");\n            var transform = _this4.refs.layer2.getAbsoluteTransform().copy();\n\n            transform.invert();\n            var uh = transform.point({\n              x: toPush.x,\n              y: toPush.y\n            });\n            toPush.x = uh.x;\n            toPush.y = uh.y;\n            var newArrow = {\n              points: toPush.points,\n              ref: 'arrow' + (_this4.state.arrows.length + 1 + _this4.state.arrowDeleteCount),\n              name: 'arrow' + (_this4.state.arrows.length + 1 + _this4.state.arrowDeleteCount),\n              from: toPush.from,\n              stroke: toPush.stroke,\n              strokeWidth: toPush.strokeWidth,\n              fill: toPush.fill //  console.log(newArrow);\n\n            };\n\n            _this4.setState(function (prevState) {\n              return {\n                arrows: [].concat(_toConsumableArray(prevState.arrows), [newArrow]),\n                newArrowDropped: true,\n                newArrowRef: newArrow.name,\n                arrowEndX: toPush.x,\n                arrowEndY: toPush.y\n              };\n            });\n          } else {\n            //  console.log(\"we are making just an aarrow\");\n            var transform = _this4.refs.layer2.getAbsoluteTransform().copy();\n\n            transform.invert();\n\n            var _uh = transform.point({\n              x: toPush.x,\n              y: toPush.y\n            });\n\n            toPush.x = _uh.x;\n            toPush.y = _uh.y;\n            var newArrow = {\n              points: [toPush.x, toPush.y, toPush.x, toPush.y],\n              ref: 'arrow' + (_this4.state.arrows.length + 1 + _this4.state.arrowDeleteCount),\n              name: 'arrow' + (_this4.state.arrows.length + 1 + _this4.state.arrowDeleteCount),\n              from: toPush.from,\n              stroke: toPush.stroke,\n              strokeWidth: toPush.strokeWidth,\n              fill: toPush.fill\n            };\n\n            _this4.setState(function (prevState) {\n              return {\n                arrows: [].concat(_toConsumableArray(prevState.arrows), [newArrow]),\n                newArrowDropped: true,\n                newArrowRef: newArrow.name,\n                arrowEndX: toPush.x,\n                arrowEndY: toPush.y\n              };\n            });\n          } //this.refs updates after forceUpdate (because arrow gets instantiated), might be risky in the future\n          //only this.state.arrows.length because it was pushed earlier, cancelling the +1\n\n        },\n        appendToRectangles: function appendToRectangles(stuff) {\n          var layer = _this4.refs.layer2;\n          var toPush = stuff;\n          var stage = _this4.refs.graphicStage;\n\n          var transform = _this4.refs.layer2.getAbsoluteTransform().copy();\n\n          transform.invert();\n          var pos = transform.point({\n            x: toPush.x,\n            y: toPush.y\n          });\n\n          if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\n            toPush.x = pos.x;\n            toPush.y = pos.y;\n          }\n\n          _this4.setState(function (prevState) {\n            return {\n              rectangles: [].concat(_toConsumableArray(prevState.rectangles), [toPush]),\n              selectedShapeName: toPush.name\n            };\n          });\n        },\n        appendToEllipses: function appendToEllipses(stuff) {\n          var layer = _this4.refs.layer2;\n          var toPush = stuff;\n          var stage = _this4.refs.graphicStage;\n\n          var transform = _this4.refs.layer2.getAbsoluteTransform().copy();\n\n          transform.invert();\n          var pos = transform.point({\n            x: toPush.x,\n            y: toPush.y\n          });\n\n          if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\n            toPush.x = pos.x;\n            toPush.y = pos.y;\n          }\n\n          _this4.setState(function (prevState) {\n            return {\n              ellipses: [].concat(_toConsumableArray(prevState.ellipses), [toPush]),\n              selectedShapeName: toPush.name\n            };\n          });\n        },\n        appendToStars: function appendToStars(stuff) {\n          var layer = _this4.refs.layer2;\n          var toPush = stuff;\n          var stage = _this4.refs.graphicStage;\n\n          var transform = _this4.refs.layer2.getAbsoluteTransform().copy();\n\n          transform.invert();\n          var pos = transform.point({\n            x: toPush.x,\n            y: toPush.y\n          });\n\n          if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\n            toPush.x = pos.x;\n            toPush.y = pos.y;\n          }\n\n          _this4.setState(function (prevState) {\n            return {\n              stars: [].concat(_toConsumableArray(prevState.stars), [toPush]),\n              selectedShapeName: toPush.name\n            };\n          });\n        },\n        appendToTexts: function appendToTexts(stuff) {\n          var layer = _this4.refs.layer2;\n          var toPush = stuff;\n          var stage = _this4.refs.graphicStage;\n\n          var transform = _this4.refs.layer2.getAbsoluteTransform().copy();\n\n          transform.invert();\n          var pos = transform.point({\n            x: toPush.x,\n            y: toPush.y\n          });\n\n          if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\n            toPush.x = pos.x;\n            toPush.y = pos.y;\n          }\n\n          _this4.setState(function (prevState) {\n            return {\n              texts: [].concat(_toConsumableArray(prevState.texts), [toPush])\n            };\n          }); //we can also just get element by this.refs.toPush.ref\n          //  let text = stage.findOne(\".\" + toPush.name);\n\n\n          var text = _this4.refs[toPush.ref]; //this.setState({firstTimeTextEditing: true});\n\n          text.fire('dblclick');\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 2084\n        },\n        __self: this\n      }))), React.createElement(\"textarea\", {\n        ref: \"textarea\",\n        id: \"textarea\",\n        value: this.state.text,\n        onChange: function onChange(e) {\n          _this4.setState({\n            text: e.target.value,\n            shouldTextUpdate: false\n          });\n        },\n        onKeyDown: function onKeyDown(e) {\n          if (e.keyCode === 13) {\n            _this4.setState({\n              textEditVisible: false,\n              shouldTextUpdate: true\n            }); // get the current textNode we are editing, get the name from there\n            //match name with elements in this.state.texts,\n\n\n            var node = _this4.refs[_this4.state.currentTextRef];\n            console.log('node width before set', node.textWidth);\n            var name = node.attrs.name;\n\n            _this4.setState(function (prevState) {\n              return {\n                selectedShapeName: name,\n                texts: prevState.texts.map(function (eachText) {\n                  return eachText.name === name ? _objectSpread({}, eachText, {\n                    text: _this4.state.text\n                  }) : eachText;\n                })\n              };\n            }, function () {\n              _this4.setState(function (prevState) {\n                return {\n                  texts: prevState.texts.map(function (eachText) {\n                    return eachText.name === name ? _objectSpread({}, eachText, {\n                      textWidth: node.textWidth,\n                      textHeight: node.textHeight\n                    }) : eachText;\n                  })\n                };\n              });\n            });\n\n            node.show();\n\n            _this4.refs.graphicStage.findOne('.transformer').show();\n          }\n        },\n        onBlur: function onBlur() {\n          _this4.setState({\n            textEditVisible: false,\n            shouldTextUpdate: true\n          }); // get the current textNode we are editing, get the name from there\n          //match name with elements in this.state.texts,\n\n\n          var node = _this4.refs.graphicStage.findOne('.' + _this4.state.currentTextRef);\n\n          var name = node.attrs.name;\n\n          _this4.setState(function (prevState) {\n            return {\n              selectedShapeName: name,\n              texts: prevState.texts.map(function (eachText) {\n                return eachText.name === name ? _objectSpread({}, eachText, {\n                  text: _this4.state.text\n                }) : eachText;\n              })\n            };\n          }, function () {\n            _this4.setState(function (prevState) {\n              return {\n                texts: prevState.texts.map(function (eachText) {\n                  return eachText.name === name ? _objectSpread({}, eachText, {\n                    textWidth: node.textWidth,\n                    textHeight: node.textHeight\n                  }) : eachText;\n                })\n              };\n            });\n          });\n\n          node.show();\n\n          _this4.refs.graphicStage.findOne('.transformer').show();\n\n          _this4.refs.graphicStage.draw();\n        },\n        style: {\n          //set position, width, height, fontSize, overflow, lineHeight, color\n          display: this.state.textEditVisible ? 'block' : 'none',\n          position: 'absolute',\n          top: this.state.textY + 80 + 'px',\n          left: this.state.textX + 'px',\n          width: '300px',\n          height: '300px',\n          overflow: 'hidden',\n          fontSize: this.state.textareaFontSize,\n          fontFamily: this.state.textareaFontFamily,\n          color: this.state.textareaFill,\n          border: 'none',\n          padding: '0px',\n          margin: '0px',\n          outline: 'none',\n          resize: 'none',\n          background: 'none'\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 2327\n        },\n        __self: this\n      }), React.createElement(\"div\", {\n        className: \"errMsg\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 2457\n        },\n        __self: this\n      }, errDisplay), React.createElement(RightToolBar, {\n        disablePaste: function disablePaste() {\n          _this4.setState({\n            isPasteDisabled: true\n          });\n        },\n        selectedName: this.state.selectedShapeName,\n        stage: this.refs.graphicStage,\n        newImage: function newImage(shape) {\n          _this4.state.rectangles.map(function (eachRect) {\n            if (eachRect.name === shape.attrs.name) {\n              var index = _this4.state.rectangles.indexOf(eachRect);\n\n              _this4.state.rectangles[index].fillPatternImage = shape.attrs.fillPatternImage;\n              _this4.state.rectangles[index].useImage = shape.attrs.useImage;\n\n              _this4.forceUpdate();\n            }\n          });\n        },\n        useFill: function useFill(stuff) {\n          var shapeName = stuff.shape.attrs.name;\n\n          if (shapeName.includes('rect')) {\n            if (stuff.type === 'shapeFill') {\n              _this4.setState(function (prevState) {\n                return {\n                  rectangles: prevState.rectangles.map(function (eachRect) {\n                    return eachRect.name === shapeName ? _objectSpread({}, eachRect, {\n                      fill: stuff.color\n                    }) : eachRect;\n                  })\n                };\n              });\n            } else if (stuff.type === 'strokeFill') {\n              _this4.setState(function (prevState) {\n                return {\n                  rectangles: prevState.rectangles.map(function (eachRect) {\n                    return eachRect.name === shapeName ? _objectSpread({}, eachRect, {\n                      stroke: stuff.color\n                    }) : eachRect;\n                  })\n                };\n              });\n            }\n          }\n\n          if (shapeName.includes('ellipse')) {\n            if (stuff.type === 'shapeFill') {\n              _this4.setState(function (prevState) {\n                return {\n                  ellipses: prevState.ellipses.map(function (eachEllipse) {\n                    return eachEllipse.name === shapeName ? _objectSpread({}, eachEllipse, {\n                      fill: stuff.color\n                    }) : eachEllipse;\n                  })\n                };\n              });\n            } else if (stuff.type === 'strokeFill') {\n              _this4.setState(function (prevState) {\n                return {\n                  ellipses: prevState.ellipses.map(function (eachEllipse) {\n                    return eachEllipse.name === shapeName ? _objectSpread({}, eachEllipse, {\n                      stroke: stuff.color\n                    }) : eachEllipse;\n                  })\n                };\n              });\n            }\n          }\n\n          if (shapeName.includes('star')) {\n            if (stuff.type === 'shapeFill') {\n              _this4.setState(function (prevState) {\n                return {\n                  stars: prevState.stars.map(function (eachStar) {\n                    return eachStar.name === shapeName ? _objectSpread({}, eachStar, {\n                      fill: stuff.color\n                    }) : eachStar;\n                  })\n                };\n              });\n            } else if (stuff.type === 'strokeFill') {\n              _this4.setState(function (prevState) {\n                return {\n                  stars: prevState.stars.map(function (eachStar) {\n                    return eachStar.name === shapeName ? _objectSpread({}, eachStar, {\n                      stroke: stuff.color\n                    }) : eachStar;\n                  })\n                };\n              });\n            }\n          }\n\n          if (shapeName.includes('text')) {\n            _this4.setState(function (prevState) {\n              return {\n                texts: prevState.texts.map(function (eachText) {\n                  return eachText.name === shapeName ? _objectSpread({}, eachText, {\n                    fill: stuff.color\n                  }) : eachText;\n                })\n              };\n            });\n          }\n\n          if (shapeName.includes('arrow')) {\n            if (stuff.type === 'shapeFill') {\n              _this4.setState(function (prevState) {\n                return {\n                  arrows: prevState.arrows.map(function (eachStar) {\n                    return eachStar.name === shapeName ? _objectSpread({}, eachStar, {\n                      fill: stuff.color\n                    }) : eachStar;\n                  })\n                };\n              });\n            } else if (stuff.type === 'strokeFill') {\n              _this4.setState(function (prevState) {\n                return {\n                  arrows: prevState.arrows.map(function (eachStar) {\n                    return eachStar.name === shapeName ? _objectSpread({}, eachStar, {\n                      stroke: stuff.color\n                    }) : eachStar;\n                  })\n                };\n              });\n            }\n          }\n        },\n        setObjectAttr: function setObjectAttr(passed) {\n          _this4.setState({\n            isPasteDisabled: false\n          });\n\n          var objectName = passed.target.name();\n\n          if (objectName.includes('rect')) {\n            if (passed.attribute === 'link' && passed.value !== '') {\n              _this4.setState(function (prevState) {\n                return {\n                  rectangles: prevState.rectangles.map(function (eachRect) {\n                    return eachRect.name === objectName ? _objectSpread({}, eachRect, {\n                      link: passed.value\n                    }) : eachRect;\n                  })\n                };\n              });\n            }\n          } else if (objectName.includes('ellipse')) {\n            if (passed.attribute === 'link' && passed.value !== '') {\n              _this4.setState(function (prevState) {\n                return {\n                  ellipses: prevState.ellipses.map(function (eachEllipse) {\n                    return eachEllipse.name === objectName ? _objectSpread({}, eachEllipse, {\n                      link: passed.value\n                    }) : eachEllipse;\n                  })\n                };\n              });\n            }\n          } else if (objectName.includes('star')) {\n            if (passed.attribute === 'link' && passed.value !== '') {\n              _this4.setState(function (prevState) {\n                return {\n                  stars: prevState.stars.map(function (eachStar) {\n                    return eachStar.name === objectName ? _objectSpread({}, eachStar, {\n                      link: passed.value\n                    }) : eachStar;\n                  })\n                };\n              });\n            }\n          }\n        },\n        setTextAttr: function setTextAttr(passed) {\n          //may change\n          console.log('paste abled....');\n\n          _this4.setState({\n            isPasteDisabled: false\n          });\n\n          var text = passed.target;\n\n          if (passed.attribute === 'link' && passed.value !== '') {\n            _this4.setState(function (prevState) {\n              return {\n                texts: prevState.texts.map(function (eachText) {\n                  return eachText.name === text.name() ? _objectSpread({}, eachText, {\n                    fill: '#5ce1e6'\n                  }) : eachText;\n                }),\n                isPasteDisabled: false\n              };\n            });\n          }\n\n          _this4.setState(function (prevState) {\n            return {\n              texts: prevState.texts.map(function (eachText) {\n                return eachText.name === text.name() ? _objectSpread({}, eachText, _defineProperty({}, passed.attribute, passed.value)) : eachText;\n              })\n            };\n          });\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 2458\n        },\n        __self: this\n      })));\n    }\n  }]);\n\n  return Graphics;\n}(Component);\n\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    auth: state.auth\n  };\n};\n\nexport default connect(mapStateToProps)(withRouter(Graphics));","map":{"version":3,"sources":["C:\\Users\\andre\\Desktop\\Great React Projects\\livesearch\\src\\App.js"],"names":["React","Component","Stage","Layer","Rect","Transformer","Ellipse","Star","Text","Arrow","Connector","Toolbar","TransformerComponent","checkNode","stage","transformer","getStage","selectedShapeName","props","detach","selectedNode","findOne","node","attachTo","getLayer","batchDraw","includes","stuff","oldBox","newBox","width","Math","max","history","historyStep","Graphics","handleSave","rects","state","rectangles","ellipses","stars","texts","arrows","JSON","stringify","saved","setState","arrows1","forEach","eachArrow","from","attrs","name","textWidth","textHeight","to","roadmapId","saving","fetch","method","headers","body","data","then","res","userId","auth","user","id","roadmapType","json","handleStageClick","e","pos","refs","layer2","getPointerPosition","shape","getIntersection","console","log","undefined","graphicStage","draw","newArrowRef","previousShape","map","fill","stroke","arrowDraggable","handleMouseOver","event","link","document","style","cursor","transform","getAbsoluteTransform","copy","invert","point","arrowEndX","x","arrowEndY","y","forceUpdate","index","indexOf","currentArrow","points","handleUndo","isTransforming","textEditVisible","connectors","redoing","shapeIsGone","handleRedo","length","next","returnTo","toReturn","currentShapeName","eachRect","eachEllipse","eachStar","eachText","IsJsonString","str","parse","layerX","layerY","layerScale","errMsg","currentTextRef","shouldTextUpdate","textX","textY","count","newArrowDropped","newConnectorDropped","lastFill","alreadyCreated","publishing","title","category","description","thumbnail","isPasteDisabled","ellipseDeleteCount","starDeleteCount","arrowDeleteCount","textDeleteCount","rectDeleteCount","handleWheel","bind","handleRoadmapPublish","evt","preventDefault","scaleBy","layer","oldScale","scaleX","mousePointTo","newScale","deltaY","scale","prevProps","prevState","prevMainShapes","currentMainShapes","uh","slice","toAppend","concat","push","path","location","pathname","roadmap","message","alert","isAuthenticated","author_id","isDraft","is_draft","roadmapData","_id","saveText","saveButton","color","backgroundColor","canvas","createElement","ctx","getContext","gradient","createLinearGradient","addColorStop","errDisplay","countryOptions","key","value","text","deleteKey","paste","z","ctrlKey","keyCode","that","rectDeleted","ellipseDeleted","starDeleted","arrowDeleted","textDeleted","filter","shiftKey","copiedElement","toPush","height","strokeWidth","ref","useImage","rotation","newName","setTimeout","radiusX","radiusY","innerRadius","outerRadius","fontSize","fontFamily","outline","window","innerHeight","innerWidth","rect","setAttr","lastRotation","scaleY","target","ellipse","numPoints","star","currentText","eachtext","absolutePosition","textNode","textareaWidth","textareaHeight","textareaFill","textareaFontFamily","textareaFontSize","textarea","focus","hide","oldPoints","shiftX","shiftY","newPoints","position","eachArr","newArrow","fire","show","display","top","left","overflow","border","padding","margin","resize","background","fillPatternImage","shapeName","type","passed","objectName","attribute","mapStateToProps","connect","withRouter"],"mappings":"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","sourcesContent":["//todo: allow for picture inside of rect/ellipse/stfar\r\n//todo: connect using arrow\r\n//todo: for rightToolBar, show fontSize,fontFamily for text for the rest allow to add pictures\r\n//todo: zoomable\r\nimport React, { Component } from 'react'\r\n\r\nimport {\r\n    Stage,\r\n    Layer,\r\n    Rect,\r\n    Transformer,\r\n    Ellipse,\r\n    Star,\r\n    Text,\r\n    Arrow\r\n} from 'react-konva'\r\nimport Connector from './Connector.jsx'\r\nimport Toolbar from './Toolbar.js'\r\n\r\n\r\nimport './Graphics.css'\r\n\r\n\r\n\r\nclass TransformerComponent extends React.Component {\r\n    componentDidMount() {\r\n        this.checkNode()\r\n    }\r\n    componentDidUpdate() {\r\n        this.checkNode()\r\n    }\r\n    checkNode() {\r\n        const stage = this.transformer.getStage()\r\n\r\n        const { selectedShapeName } = this.props\r\n        if (selectedShapeName === '') {\r\n            this.transformer.detach()\r\n            return\r\n        }\r\n        const selectedNode = stage.findOne('.' + selectedShapeName)\r\n        if (selectedNode === this.transformer.node()) {\r\n            return\r\n        }\r\n\r\n        if (selectedNode) {\r\n            this.transformer.attachTo(selectedNode)\r\n        } else {\r\n            this.transformer.detach()\r\n        }\r\n        this.transformer.getLayer().batchDraw()\r\n    }\r\n    render() {\r\n        if (this.props.selectedShapeName.includes('text')) {\r\n            var stuff = (\r\n                <Transformer\r\n                    ref={node => {\r\n                        this.transformer = node\r\n                    }}\r\n                    name=\"transformer\"\r\n                    boundBoxFunc={(oldBox, newBox) => {\r\n                        newBox.width = Math.max(30, newBox.width)\r\n                        return newBox\r\n                    }}\r\n                    enabledAnchors={['middle-left', 'middle-right']}\r\n                />\r\n            )\r\n        } else if (this.props.selectedShapeName.includes('star')) {\r\n            var stuff = (\r\n                <Transformer\r\n                    ref={node => {\r\n                        this.transformer = node\r\n                    }}\r\n                    name=\"transformer\"\r\n                    enabledAnchors={[\r\n                        'top-left',\r\n                        'top-right',\r\n                        'bottom-left',\r\n                        'bottom-right'\r\n                    ]}\r\n                />\r\n            )\r\n        } else if (this.props.selectedShapeName.includes('arrow')) {\r\n            var stuff = (\r\n                <Transformer\r\n                    ref={node => {\r\n                        this.transformer = node\r\n                    }}\r\n                    name=\"transformer\"\r\n                    resizeEnabled={false}\r\n                    rotateEnabled={false}\r\n                />\r\n            )\r\n        } else {\r\n            var stuff = (\r\n                <Transformer\r\n                    ref={node => {\r\n                        this.transformer = node\r\n                    }}\r\n                    name=\"transformer\"\r\n                    keepRatio={true}\r\n                />\r\n            )\r\n        }\r\n        return stuff\r\n    }\r\n}\r\n\r\nvar history = []\r\nvar historyStep = 0\r\n\r\nclass Graphics extends Component {\r\n    constructor(props) {\r\n        super(props)\r\n\r\n        this.state = {\r\n            layerX: 0,\r\n            layerY: 0,\r\n            layerScale: 1,\r\n            selectedShapeName: '',\r\n            errMsg: '',\r\n            rectangles: [],\r\n            ellipses: [],\r\n            stars: [],\r\n            texts: [],\r\n            arrows: [],\r\n            connectors: [],\r\n            currentTextRef: '',\r\n            shouldTextUpdate: true,\r\n            textX: 0,\r\n            textY: 0,\r\n            textEditVisible: false,\r\n            arrowDraggable: false,\r\n            newArrowRef: '',\r\n            count: 0,\r\n            newArrowDropped: false,\r\n            newConnectorDropped: false,\r\n            arrowEndX: 0,\r\n            arrowEndY: 0,\r\n            isTransforming: false,\r\n            lastFill: null,\r\n\r\n            saving: null,\r\n            saved: [],\r\n            roadmapId: null,\r\n            alreadyCreated: false,\r\n            publishing: false,\r\n            title: '',\r\n            category: '',\r\n            description: '',\r\n            thumbnail: '',\r\n            isPasteDisabled: false,\r\n            ellipseDeleteCount: 0,\r\n            starDeleteCount: 0,\r\n            arrowDeleteCount: 0,\r\n            textDeleteCount: 0,\r\n            rectDeleteCount: 0\r\n        }\r\n\r\n        this.handleWheel = this.handleWheel.bind(this)\r\n        this.handleRoadmapPublish = this.handleRoadmapPublish.bind(this)\r\n    }\r\n\r\n    handleSave = () => {\r\n        const rects = this.state.rectangles,\r\n            ellipses = this.state.ellipses,\r\n            stars = this.state.stars,\r\n            texts = this.state.texts,\r\n            arrows = this.state.arrows\r\n        if (\r\n            JSON.stringify(this.state.saved) !==\r\n            JSON.stringify([rects, ellipses, stars, texts, arrows])\r\n        ) {\r\n            this.setState({ saved: [rects, ellipses, stars, texts, arrows] })\r\n\r\n            let arrows1 = this.state.arrows\r\n            arrows1.forEach(eachArrow => {\r\n                //for \"from & to of each arrow\"\r\n                if (eachArrow.from && eachArrow.from.attrs) {\r\n                    if (eachArrow.from.attrs.name.includes('text')) {\r\n                        eachArrow.from.textWidth = eachArrow.from.textWidth\r\n\r\n                        eachArrow.from.textHeight = eachArrow.from.textHeight\r\n                    }\r\n                }\r\n                if (eachArrow.to && eachArrow.to.attrs) {\r\n                    if (eachArrow.to.attrs.name.includes('text')) {\r\n                        eachArrow.to.attrs.textWidth = eachArrow.to.textWidth\r\n                        eachArrow.to.attrs.textHeight = eachArrow.to.textHeight\r\n                    }\r\n                }\r\n            })\r\n\r\n            if (this.state.roadmapId) {\r\n                //if draft already exists\r\n                this.setState({ saving: true })\r\n                fetch('/api/roadmap/modifyDraftDB', {\r\n                    method: 'POST',\r\n                    headers: { 'Content-Type': 'application/json' },\r\n                    body: JSON.stringify({\r\n                        roadmapId: this.state.roadmapId,\r\n\r\n                        data: {\r\n                            rects: rects,\r\n                            ellipses: ellipses,\r\n                            stars: stars,\r\n                            texts: texts,\r\n                            arrows: arrows1\r\n                        }\r\n                    })\r\n                }).then(res => {\r\n                    this.setState({ saving: false })\r\n                })\r\n            } else {\r\n                //if first time pressing sav\r\n                this.setState({ saving: true })\r\n                fetch('/api/roadmap/saveRoadmapToDB', {\r\n                    method: 'POST',\r\n                    headers: { 'Content-Type': 'application/json' },\r\n                    body: JSON.stringify({\r\n                        userId: this.props.auth.user.id,\r\n                        roadmapType: 'draft',\r\n                        data: {\r\n                            rects: rects,\r\n                            ellipses: ellipses,\r\n                            stars: stars,\r\n                            texts: texts,\r\n                            arrows: arrows\r\n                        }\r\n                    })\r\n                }).then(res =>\r\n                    res.json().then(data => {\r\n                        this.setState({ saving: false })\r\n                        this.setState({ roadmapId: data.roadmapId })\r\n                    })\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    handleStageClick = e => {\r\n        var pos = this.refs.layer2.getStage().getPointerPosition()\r\n        var shape = this.refs.layer2.getIntersection(pos)\r\n\r\n        console.log('texts', this.state.texts)\r\n\r\n        if (\r\n            shape !== null &&\r\n            shape.name() !== undefined &&\r\n            shape !== undefined &&\r\n            shape.name() !== undefined\r\n        ) {\r\n            this.setState(\r\n                {\r\n                    selectedShapeName: shape.name()\r\n                },\r\n                () => {\r\n                    this.refs.graphicStage.draw()\r\n                }\r\n            )\r\n        }\r\n\r\n        //arrow logic\r\n        if (this.state.newArrowRef !== '') {\r\n            if (this.state.previousShape) {\r\n                if (this.state.previousShape.attrs.id !== 'ContainerRect') {\r\n                    //console.log(this.refs.graphicStage.findOne(\".\" + this.state.newArrowRef));\r\n                    //\r\n\r\n                    this.state.arrows.map(eachArrow => {\r\n                        if (eachArrow.name === this.state.newArrowRef) {\r\n                            eachArrow.to = this.state.previousShape\r\n                        }\r\n                    })\r\n\r\n                    //console.log(newConnector, this.state.newArrowRef);\r\n                    //newConnector.setAttr(\"to\", this.state.previousShape);\r\n                    //console.log(newConnector);\r\n                }\r\n            }\r\n\r\n            //handle connector more\r\n            //if the currentArrow ref has a from, and that e.target.attrs.id isn't containerRect,\r\n            //then find the current shape with stage find name and then yeah\r\n            this.state.arrows.map(eachArrow => {\r\n                if (eachArrow.name === this.state.newArrowRef) {\r\n                    eachArrow.fill = 'black'\r\n                    eachArrow.stroke = 'black'\r\n                }\r\n            })\r\n            //arrow logic, there's e.evt.pageX, pageY\r\n            this.setState({\r\n                arrowDraggable: false,\r\n                newArrowRef: ''\r\n            })\r\n        }\r\n    }\r\n    handleMouseOver = event => {\r\n        //get the currennt arrow ref and modify its position by filtering & pushing again\r\n        //console.log(\"lastFill: \", this.state.lastFill);\r\n        var pos = this.refs.graphicStage.getPointerPosition()\r\n        var shape = this.refs.graphicStage.getIntersection(pos)\r\n\r\n        if (shape && shape.attrs.link) {\r\n            document.body.style.cursor = 'pointer'\r\n        } else {\r\n            document.body.style.cursor = 'default'\r\n        }\r\n\r\n        //if we are moving an arrow\r\n        if (this.state.newArrowRef !== '') {\r\n            //filling color logic:\r\n\r\n            var transform = this.refs.layer2.getAbsoluteTransform().copy()\r\n            transform.invert()\r\n\r\n            pos = transform.point(pos)\r\n            this.setState({ arrowEndX: pos.x, arrowEndY: pos.y })\r\n            //last non arrow object\r\n            if (shape && shape.attrs && shape.attrs.name != undefined) {\r\n                //  console.log(shape);\r\n                if (!shape.attrs.name.includes('arrow')) {\r\n                    //after first frame\r\n                    if (this.state.previousShape)\r\n                        if (this.state.previousShape !== shape) {\r\n                            //arrow entered a new shape\r\n\r\n                            //set current arrow to blue\r\n                            if (\r\n                                this.state.previousShape.attrs.id !==\r\n                                'ContainerRect'\r\n                            ) {\r\n                                this.state.arrows.map(eachArrow => {\r\n                                    if (\r\n                                        eachArrow.name ===\r\n                                        this.state.newArrowRef\r\n                                    ) {\r\n                                        eachArrow.fill = 'black'\r\n                                        eachArrow.stroke = 'black'\r\n                                    }\r\n                                })\r\n                                this.forceUpdate()\r\n                            } else {\r\n                                this.state.arrows.map(eachArrow => {\r\n                                    if (\r\n                                        eachArrow.name ===\r\n                                        this.state.newArrowRef\r\n                                    ) {\r\n                                        eachArrow.fill = '#ccf5ff'\r\n                                        eachArrow.stroke = '#ccf5ff'\r\n                                    }\r\n                                })\r\n                                this.forceUpdate()\r\n                            }\r\n                        }\r\n                    //if arrow is moving in a single shape\r\n                }\r\n\r\n                if (!shape.attrs.name.includes('arrow')) {\r\n                    this.setState({ previousShape: shape })\r\n                }\r\n            }\r\n        }\r\n        var arrows = this.state.arrows\r\n\r\n        arrows.map(eachArrow => {\r\n            if (eachArrow.name === this.state.newArrowRef) {\r\n                var index = arrows.indexOf(eachArrow)\r\n                let currentArrow = eachArrow\r\n                currentArrow.points = [\r\n                    currentArrow.points[0],\r\n                    currentArrow.points[1],\r\n                    pos.x,\r\n                    pos.y\r\n                    /*  event.evt.pageY -\r\n            document.getElementById(\"NavBar\").getBoundingClientRect().height */\r\n                ]\r\n\r\n                this.state.arrows[index] = currentArrow\r\n            }\r\n        })\r\n    }\r\n    handleWheel(event) {\r\n        if (\r\n            this.state.rectangles.length === 0 &&\r\n            this.state.ellipses.length === 0 &&\r\n            this.state.stars.length === 0 &&\r\n            this.state.texts.length === 0 &&\r\n            this.state.arrows.length === 0\r\n        ) {\r\n        } else {\r\n            event.evt.preventDefault()\r\n            const scaleBy = 1.2\r\n            const stage = this.refs.graphicStage\r\n            const layer = this.refs.layer2\r\n            const oldScale = layer.scaleX()\r\n            const mousePointTo = {\r\n                x:\r\n                    stage.getPointerPosition().x / oldScale -\r\n                    this.state.layerX / oldScale,\r\n                y:\r\n                    stage.getPointerPosition().y / oldScale -\r\n                    this.state.layerY / oldScale\r\n            }\r\n\r\n            const newScale =\r\n                event.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy\r\n\r\n            layer.scale({ x: newScale, y: newScale })\r\n\r\n            /*  console.log(\r\n        oldScale,\r\n        mousePointTo,\r\n        stage.getPointerPosition().x,\r\n        stage.getPointerPosition().y\r\n      );\r\n    */\r\n            this.setState({\r\n                layerScale: newScale,\r\n                layerX:\r\n                    -(\r\n                        mousePointTo.x -\r\n                        stage.getPointerPosition().x / newScale\r\n                    ) * newScale,\r\n                layerY:\r\n                    -(\r\n                        mousePointTo.y -\r\n                        stage.getPointerPosition().y / newScale\r\n                    ) * newScale\r\n            })\r\n        }\r\n    }\r\n    componentDidUpdate(prevProps, prevState) {\r\n        let prevMainShapes = [\r\n            prevState.rectangles,\r\n            prevState.ellipses,\r\n            prevState.stars,\r\n            prevState.arrows,\r\n            prevState.connectors,\r\n            prevState.texts\r\n        ]\r\n        let currentMainShapes = [\r\n            this.state.rectangles,\r\n            this.state.ellipses,\r\n            this.state.stars,\r\n            this.state.arrows,\r\n            this.state.connectors,\r\n            this.state.texts\r\n        ]\r\n\r\n        if (!this.state.redoing && !this.state.isTransforming)\r\n            if (JSON.stringify(this.state) !== JSON.stringify(prevState)) {\r\n                if (\r\n                    JSON.stringify(prevMainShapes) !==\r\n                    JSON.stringify(currentMainShapes)\r\n                ) {\r\n                    //if text shouldn't update, don't append to  history\r\n                    if (this.state.shouldTextUpdate) {\r\n                        var uh = history\r\n                        history = uh.slice(0, historyStep + 1)\r\n                        //console.log(\"sliced\", history);\r\n                        var toAppend = this.state\r\n                        history = history.concat(toAppend)\r\n                        //console.log(\"new\", history);\r\n                        historyStep += 1\r\n                        //console.log(history, historyStep, history[historyStep]);\r\n                    }\r\n                }\r\n            } else {\r\n                //console.log(\"compoenntDidUpdate but attrs didn't change\");\r\n            }\r\n        this.state.redoing = false\r\n    }\r\n\r\n    handleUndo = () => {\r\n        if (!this.state.isTransforming) {\r\n            if (!this.state.textEditVisible) {\r\n                if (historyStep === 0) {\r\n                    return\r\n                }\r\n                historyStep -= 1\r\n\r\n                this.setState(\r\n                    {\r\n                        rectangles: history[historyStep].rectangles,\r\n                        arrows: history[historyStep].arrows,\r\n                        ellipses: history[historyStep].ellipses,\r\n                        stars: history[historyStep].stars,\r\n                        texts: history[historyStep].texts,\r\n                        connectors: history[historyStep].connectors,\r\n                        redoing: true,\r\n                        selectedShapeName: this.shapeIsGone(\r\n                            history[historyStep]\r\n                        )\r\n                            ? ''\r\n                            : this.state.selectedShapeName\r\n                    },\r\n                    () => {\r\n                        this.refs.graphicStage.draw()\r\n                    }\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    handleRedo = () => {\r\n        if (historyStep === history.length - 1) {\r\n            return\r\n        }\r\n        historyStep += 1\r\n        const next = history[historyStep]\r\n        this.setState(\r\n            {\r\n                rectangles: next.rectangles,\r\n                arrows: next.arrows,\r\n                ellipses: next.ellipses,\r\n                stars: next.stars,\r\n                texts: next.texts,\r\n                redoing: true,\r\n                selectedShapeName: this.shapeIsGone(history[historyStep])\r\n                    ? ''\r\n                    : this.state.selectedShapeName\r\n            },\r\n            () => {\r\n                this.forceUpdate()\r\n            }\r\n        )\r\n    }\r\n\r\n    shapeIsGone = returnTo => {\r\n        var toReturn = true\r\n        let currentShapeName = this.state.selectedShapeName\r\n        let [rectangles, ellipses, stars, arrows, texts] = [\r\n            returnTo.rectangles,\r\n            returnTo.ellipses,\r\n            returnTo.stars,\r\n            returnTo.arrows,\r\n\r\n            returnTo.texts\r\n        ]\r\n        rectangles.map(eachRect => {\r\n            if (eachRect.name === currentShapeName) {\r\n                toReturn = false\r\n            }\r\n        })\r\n        ellipses.map(eachEllipse => {\r\n            if (eachEllipse.name === currentShapeName) {\r\n                toReturn = false\r\n            }\r\n        })\r\n        stars.map(eachStar => {\r\n            if (eachStar.name === currentShapeName) {\r\n                toReturn = false\r\n            }\r\n        })\r\n        arrows.map(eachArrow => {\r\n            if (eachArrow.name === currentShapeName) {\r\n                toReturn = false\r\n            }\r\n        })\r\n\r\n        texts.map(eachText => {\r\n            if (eachText.name === currentShapeName) {\r\n                toReturn = false\r\n            }\r\n        })\r\n\r\n        return toReturn\r\n    }\r\n    IsJsonString = str => {\r\n        try {\r\n            JSON.parse(str)\r\n        } catch (e) {\r\n            return false\r\n        }\r\n        return true\r\n    }\r\n\r\n    async componentDidMount() {\r\n        history.push(this.state)\r\n        this.setState({ selectedShapeName: '' })\r\n\r\n        var path = this.props.history.location.pathname\r\n\r\n        //if draft\r\n        if (path.includes('draft')) {\r\n            path = path.slice(14)\r\n            await fetch('/api/roadmap/getRoadmapById', {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify({\r\n                    roadmapId: path,\r\n                    userId: this.props.auth.user.id\r\n                })\r\n            }).then(res => {\r\n                res.json().then(roadmap => {\r\n                    //if no permission\r\n                    if (roadmap && roadmap.message) {\r\n                        alert(roadmap.message)\r\n                        this.props.history.push('/')\r\n                    } else if (\r\n                        !this.props.auth.isAuthenticated ||\r\n                        roadmap.author_id !== this.props.auth.user.id\r\n                    ) {\r\n                        //also if no permission\r\n                        alert('You do not have permission!')\r\n                        this.props.history.push('/')\r\n                    } else {\r\n                        var data = roadmap.data\r\n                        var isDraft = roadmap.is_draft\r\n\r\n                        //if saved was draft instead of alreadyCreated\r\n                        if (isDraft) {\r\n                            var roadmapData = JSON.parse(data)\r\n\r\n                            roadmapData.arrows.forEach(eachArrow => {\r\n                                if (\r\n                                    eachArrow.from &&\r\n                                    this.IsJsonString(eachArrow.from)\r\n                                )\r\n                                    eachArrow.from = JSON.parse(eachArrow.from)\r\n                                if (\r\n                                    eachArrow.to &&\r\n                                    this.IsJsonString(eachArrow.to)\r\n                                )\r\n                                    eachArrow.to = JSON.parse(eachArrow.to)\r\n                            })\r\n                            this.setState(\r\n                                {\r\n                                    rectangles: roadmapData.rects,\r\n                                    ellipses: roadmapData.ellipses,\r\n                                    stars: roadmapData.stars,\r\n                                    arrows: roadmapData.arrows,\r\n                                    texts: roadmapData.texts,\r\n                                    roadmapId: roadmap._id,\r\n                                    is_draft: roadmap.is_draft\r\n                                },\r\n                                () => {}\r\n                            )\r\n                        } else {\r\n                            //accessing already created through /create/edit\r\n                            this.setState({ alreadyCreated: true })\r\n\r\n                            roadmapData = JSON.parse(data)\r\n                            while (this.IsJsonString(roadmapData)) {\r\n                                roadmapData = JSON.parse(roadmapData)\r\n                            }\r\n                            roadmapData.arrows.forEach(eachArrow => {\r\n                                if (\r\n                                    eachArrow.from &&\r\n                                    this.IsJsonString(eachArrow.from)\r\n                                )\r\n                                    eachArrow.from = JSON.parse(eachArrow.from)\r\n                                if (\r\n                                    eachArrow.to &&\r\n                                    this.IsJsonString(eachArrow.to)\r\n                                )\r\n                                    eachArrow.to = JSON.parse(eachArrow.to)\r\n                            })\r\n                            this.setState({\r\n                                rectangles: roadmapData.rects,\r\n                                ellipses: roadmapData.ellipses,\r\n                                stars: roadmapData.stars,\r\n                                arrows: roadmapData.arrows,\r\n                                texts: roadmapData.texts,\r\n                                roadmapId: roadmap._id,\r\n                                is_draft: roadmap.is_draft\r\n                            })\r\n                        }\r\n                        console.log('ellipse', this.state.ellipses[0])\r\n                        console.log('arrow', this.state.arrows[0])\r\n                        console.log('texts', this.state.texts[0])\r\n                    }\r\n                })\r\n            })\r\n        }\r\n    }\r\n\r\n\r\n    render() {\r\n        let saveText\r\n        let saveButton\r\n        let saving = this.state.saving\r\n        if (saving !== null) {\r\n            if (saving) {\r\n                saveText = <div style={{ color: 'white' }}>Saving</div>\r\n            } else {\r\n                saveText = <div style={{ color: 'white' }}>Saved</div>\r\n            }\r\n        }\r\n        if (!saving || saving === null) {\r\n            saveButton = (\r\n                <Button\r\n                    style={{ backgroundColor: '#5a10b9', color: 'white' }}\r\n                    onClick={this.handleSave}\r\n                >\r\n                    Save\r\n                </Button>\r\n            )\r\n        } else {\r\n            saveButton = (\r\n                <Button style={{ backgroundColor: 'grey', color: 'white' }}>\r\n                    Saving\r\n                </Button>\r\n            )\r\n        }\r\n\r\n        const canvas = document.createElement('canvas')\r\n        const ctx = canvas.getContext('2d')\r\n\r\n        var gradient = ctx.createLinearGradient(0, 0, 100, 100)\r\n        gradient.addColorStop(0.0, 'red')\r\n        gradient.addColorStop(1 / 6, 'orange')\r\n        gradient.addColorStop(2 / 6, 'yellow')\r\n        gradient.addColorStop(3 / 6, 'green')\r\n        gradient.addColorStop(4 / 6, 'aqua')\r\n        gradient.addColorStop(5 / 6, 'blue')\r\n        gradient.addColorStop(1.0, 'purple')\r\n\r\n        const errMsg = this.state.errMsg\r\n        let errDisplay\r\n        if (errMsg !== '') {\r\n            errDisplay = (\r\n                <div className=\"errMsginner\">\r\n                    <span style={{ color: 'white' }}>\r\n                        {errMsg !== '' ? errMsg : null}\r\n                    </span>\r\n                </div>\r\n            )\r\n        } else {\r\n        }\r\n\r\n        const countryOptions = [\r\n            { key: '1', value: 'Machine Learning', text: 'Machine Learning' },\r\n            { key: '2', value: 'Computer Science', text: 'Computer Science' },\r\n            {\r\n                key: '3',\r\n                value: 'Software Engineering',\r\n                text: 'Software Engineering'\r\n            },\r\n            { key: '12', value: 'Technology', text: 'Technology' },\r\n            { key: '4', value: 'Engineering', text: 'Engineering' },\r\n\r\n            {\r\n                key: '6',\r\n                value: 'Sciences and Mathematics',\r\n                text: 'Sciences and Mathematics'\r\n            },\r\n            {\r\n                key: '7',\r\n                value: 'Law, Economics and Social Sciences',\r\n                text: 'Law, Economics and Social Sciences'\r\n            },\r\n            { key: '8', value: 'Humanities', text: 'Humanities' },\r\n            {\r\n                key: '9',\r\n                value: 'Linguistics and Cultural Studies',\r\n                text: 'Linguistics and Cultural Studies'\r\n            },\r\n            { key: '10', value: 'Art and Music', text: 'Art and Music' },\r\n            { key: '11', value: 'Lifestyle', text: 'Lifestyle' },\r\n            {\r\n                key: '13',\r\n                value: 'Others',\r\n                text: 'Others'\r\n            }\r\n        ]\r\n\r\n        return (\r\n            <React.Fragment>\r\n          \r\n                <div\r\n                    onKeyDown={event => {\r\n                        const x = 88,\r\n                            deleteKey = 46,\r\n                            copy = 67,\r\n                            paste = 86,\r\n                            z = 90,\r\n                            y = 89\r\n\r\n                        if (\r\n                            ((event.ctrlKey && event.keyCode === x) ||\r\n                                event.keyCode === deleteKey) &&\r\n                            !this.state.isPasteDisabled\r\n                        ) {\r\n                            if (this.state.selectedShapeName !== '') {\r\n                                var that = this\r\n                                //delete it from the state too\r\n                                let name = this.state.selectedShapeName\r\n                                let rectDeleted = false,\r\n                                    ellipseDeleted = false,\r\n                                    starDeleted = false,\r\n                                    arrowDeleted = false,\r\n                                    textDeleted = false\r\n\r\n                                var rects = this.state.rectangles.filter(\r\n                                    function(eachRect) {\r\n                                        if (eachRect.name === name) {\r\n                                            that.setState({\r\n                                                rectDeleteCount:\r\n                                                    that.state.rectDeleteCount +\r\n                                                    1\r\n                                            })\r\n                                        }\r\n                                        return eachRect.name !== name\r\n                                    }\r\n                                )\r\n\r\n                                var ellipses = this.state.ellipses.filter(\r\n                                    function(eachRect) {\r\n                                        if (eachRect.name === name) {\r\n                                            that.setState({\r\n                                                ellipseDeleteCount:\r\n                                                    that.state\r\n                                                        .ellipseDeleteCount + 1\r\n                                            })\r\n                                        }\r\n                                        return eachRect.name !== name\r\n                                    }\r\n                                )\r\n\r\n                                var stars = this.state.stars.filter(function(\r\n                                    eachRect\r\n                                ) {\r\n                                    if (eachRect.name === name) {\r\n                                        that.setState({\r\n                                            starDeleteCount:\r\n                                                that.state.starDeleteCount + 1\r\n                                        })\r\n                                    }\r\n                                    return eachRect.name !== name\r\n                                })\r\n\r\n                                var arrows = this.state.arrows.filter(function(\r\n                                    eachRect\r\n                                ) {\r\n                                    if (eachRect.name === name) {\r\n                                        that.setState({\r\n                                            arrowDeleteCount:\r\n                                                that.state.arrowDeleteCount + 1\r\n                                        })\r\n                                    }\r\n                                    return eachRect.name !== name\r\n                                })\r\n\r\n                                var texts = this.state.texts.filter(function(\r\n                                    eachRect\r\n                                ) {\r\n                                    if (eachRect.name === name) {\r\n                                        that.setState({\r\n                                            textDeleteCount:\r\n                                                that.state.textDeleteCount + 1\r\n                                        })\r\n                                    }\r\n                                    return eachRect.name !== name\r\n                                })\r\n\r\n                                this.setState({\r\n                                    rectangles: rects,\r\n                                    ellipses: ellipses,\r\n                                    stars: stars,\r\n                                    arrows: arrows,\r\n                                    texts: texts,\r\n                                    selectedShapeName: ''\r\n                                })\r\n                            }\r\n                        } else if (\r\n                            event.shiftKey &&\r\n                            event.ctrlKey &&\r\n                            event.keyCode === z\r\n                        ) {\r\n                            this.handleRedo()\r\n                        } else if (event.ctrlKey && event.keyCode === z) {\r\n                            this.handleUndo()\r\n                        } else if (event.ctrlKey && event.keyCode === y) {\r\n                            this.handleRedo()\r\n                        } else if (event.ctrlKey && event.keyCode === copy) {\r\n                            if (this.state.selectedShapeName !== '') {\r\n                                //find it\r\n                                let name = this.state.selectedShapeName\r\n                                let copiedElement = null\r\n                                if (name.includes('rect')) {\r\n                                    copiedElement = this.state.rectangles.filter(\r\n                                        function(eachRect) {\r\n                                            return eachRect.name === name\r\n                                        }\r\n                                    )\r\n                                } else if (name.includes('ellipse')) {\r\n                                    copiedElement = this.state.ellipses.filter(\r\n                                        function(eachRect) {\r\n                                            return eachRect.name === name\r\n                                        }\r\n                                    )\r\n                                } else if (name.includes('star')) {\r\n                                    copiedElement = this.state.stars.filter(\r\n                                        function(eachRect) {\r\n                                            return eachRect.name === name\r\n                                        }\r\n                                    )\r\n                                } else if (name.includes('text')) {\r\n                                    copiedElement = this.state.texts.filter(\r\n                                        function(eachRect) {\r\n                                            return eachRect.name === name\r\n                                        }\r\n                                    )\r\n                                } else if (name.includes('arrow')) {\r\n                                    copiedElement = this.state.arrows.filter(\r\n                                        function(eachRect) {\r\n                                            return eachRect.name === name\r\n                                        }\r\n                                    )\r\n                                }\r\n\r\n                                this.setState(\r\n                                    { copiedElement: copiedElement },\r\n                                    () => {\r\n                                        console.log(\r\n                                            'copied ele',\r\n                                            this.state.copiedElement\r\n                                        )\r\n                                    }\r\n                                )\r\n                            }\r\n                        } else if (\r\n                            event.ctrlKey &&\r\n                            event.keyCode === paste &&\r\n                            !this.state.isPasteDisabled\r\n                        ) {\r\n                            let copiedElement = this.state.copiedElement[0]\r\n                            console.log(copiedElement)\r\n                            var length\r\n                            if (copiedElement) {\r\n                                if (copiedElement.attrs) {\r\n                                } else {\r\n                                    if (\r\n                                        copiedElement.name.includes('rectangle')\r\n                                    ) {\r\n                                        length =\r\n                                            this.state.rectangles.length +\r\n                                            1 +\r\n                                            this.state.rectDeleteCount\r\n                                        var toPush = {\r\n                                            x: copiedElement.x + 10,\r\n                                            y: copiedElement.y + 10,\r\n                                            width: copiedElement.width,\r\n                                            height: copiedElement.height,\r\n                                            stroke: copiedElement.stroke,\r\n                                            strokeWidth:\r\n                                                copiedElement.strokeWidth,\r\n                                            name:\r\n                                                'rectangle' +\r\n                                                (this.state.rectangles.length +\r\n                                                    this.state.rectDeleteCount +\r\n                                                    1),\r\n                                            ref:\r\n                                                'rectangle' +\r\n                                                (this.state.rectangles.length +\r\n                                                    this.state.rectDeleteCount +\r\n                                                    1),\r\n                                            fill: copiedElement.fill,\r\n                                            useImage: copiedElement.useImage,\r\n                                            link: copiedElement.link,\r\n                                            rotation: copiedElement.rotation\r\n                                        }\r\n                                        let newName = this.state\r\n                                            .selectedShapeName\r\n\r\n                                        this.setState(\r\n                                            prevState => ({\r\n                                                rectangles: [\r\n                                                    ...prevState.rectangles,\r\n                                                    toPush\r\n                                                ]\r\n                                            }),\r\n                                            () => {\r\n                                                this.setState({\r\n                                                    selectedShapeName:\r\n                                                        'rectangle' +\r\n                                                        this.state.rectangles\r\n                                                            .length\r\n                                                })\r\n                                            }\r\n                                        )\r\n                                    } else if (\r\n                                        copiedElement.name.includes('arrow')\r\n                                    ) {\r\n                                        length =\r\n                                            this.state.arrows.length +\r\n                                            1 +\r\n                                            this.state.arrowDeleteCount\r\n\r\n                                        if (\r\n                                            copiedElement.to ||\r\n                                            copiedElement.from\r\n                                        ) {\r\n                                            this.setState(\r\n                                                {\r\n                                                    errMsg:\r\n                                                        'Connectors cannot be pasted'\r\n                                                },\r\n                                                () => {\r\n                                                    var that = this\r\n                                                    setTimeout(function() {\r\n                                                        that.setState({\r\n                                                            errMsg: ''\r\n                                                        })\r\n                                                    }, 1000)\r\n                                                }\r\n                                            )\r\n                                        } else {\r\n                                            var toPush = {\r\n                                                points: [\r\n                                                    copiedElement.points[0] +\r\n                                                        30,\r\n                                                    copiedElement.points[1] +\r\n                                                        30,\r\n                                                    copiedElement.points[2] +\r\n                                                        30,\r\n                                                    copiedElement.points[3] + 30\r\n                                                ],\r\n                                                fill: copiedElement.fill,\r\n                                                link: copiedElement.link,\r\n                                                stroke: copiedElement.stroke,\r\n                                                strokeWidth:\r\n                                                    copiedElement.strokeWidth,\r\n                                                name:\r\n                                                    'arrow' +\r\n                                                    (this.state.arrows.length +\r\n                                                        1 +\r\n                                                        this.state\r\n                                                            .arrowDeleteCount),\r\n                                                ref:\r\n                                                    'arrow' +\r\n                                                    (this.state.arrows.length +\r\n                                                        1 +\r\n                                                        this.state\r\n                                                            .arrowDeleteCount),\r\n                                                rotation: copiedElement.rotation\r\n                                            }\r\n\r\n                                            let newName = this.state\r\n                                                .selectedShapeName\r\n\r\n                                            this.setState(\r\n                                                prevState => ({\r\n                                                    arrows: [\r\n                                                        ...prevState.arrows,\r\n                                                        toPush\r\n                                                    ]\r\n                                                }),\r\n                                                () => {\r\n                                                    this.setState({\r\n                                                        selectedShapeName:\r\n                                                            'arrow' +\r\n                                                            this.state.arrows\r\n                                                                .length\r\n                                                    })\r\n                                                }\r\n                                            )\r\n                                        }\r\n                                    } else if (\r\n                                        copiedElement.name.includes('ellipse')\r\n                                    ) {\r\n                                        length =\r\n                                            this.state.ellipses.length +\r\n                                            1 +\r\n                                            this.state.ellipseDeleteCount\r\n                                        var toPush = {\r\n                                            x: copiedElement.x + 10,\r\n                                            y: copiedElement.y + 10,\r\n                                            radiusX: copiedElement.radiusX,\r\n                                            radiusY: copiedElement.radiusY,\r\n                                            stroke: copiedElement.stroke,\r\n                                            strokeWidth:\r\n                                                copiedElement.strokeWidth,\r\n                                            name:\r\n                                                'ellipse' +\r\n                                                (this.state.ellipses.length +\r\n                                                    1 +\r\n                                                    this.state\r\n                                                        .ellipseDeleteCount),\r\n                                            ref:\r\n                                                'ellipse' +\r\n                                                (this.state.ellipses.length +\r\n                                                    1 +\r\n                                                    this.state\r\n                                                        .ellipseDeleteCount),\r\n                                            fill: copiedElement.fill,\r\n                                            link: copiedElement.link,\r\n                                            useImage: copiedElement.useImage,\r\n                                            rotation: copiedElement.rotation\r\n                                        }\r\n                                        let newName = this.state\r\n                                            .selectedShapeName\r\n\r\n                                        this.setState(\r\n                                            prevState => ({\r\n                                                ellipses: [\r\n                                                    ...prevState.ellipses,\r\n                                                    toPush\r\n                                                ]\r\n                                            }),\r\n                                            () => {\r\n                                                this.setState({\r\n                                                    selectedShapeName:\r\n                                                        'ellipse' +\r\n                                                        this.state.ellipses\r\n                                                            .length\r\n                                                })\r\n                                            }\r\n                                        )\r\n                                    } else if (\r\n                                        copiedElement.name.includes('star')\r\n                                    ) {\r\n                                        length =\r\n                                            this.state.stars.length +\r\n                                            1 +\r\n                                            this.state.starDeleteCount\r\n                                        var toPush = {\r\n                                            x: copiedElement.x + 10,\r\n                                            y: copiedElement.y + 10,\r\n                                            link: copiedElement.link,\r\n                                            innerRadius:\r\n                                                copiedElement.innerRadius,\r\n                                            outerRadius:\r\n                                                copiedElement.outerRadius,\r\n                                            stroke: copiedElement.stroke,\r\n                                            strokeWidth:\r\n                                                copiedElement.strokeWidth,\r\n                                            name:\r\n                                                'star' +\r\n                                                (this.state.stars.length +\r\n                                                    1 +\r\n                                                    this.state.starDeleteCount),\r\n                                            ref:\r\n                                                'star' +\r\n                                                (this.state.stars.length +\r\n                                                    1 +\r\n                                                    this.state.starDeleteCount),\r\n                                            fill: copiedElement.fill,\r\n                                            useImage: copiedElement.useImage,\r\n                                            rotation: copiedElement.rotation\r\n                                        }\r\n                                        let newName = this.state\r\n                                            .selectedShapeName\r\n\r\n                                        this.setState(\r\n                                            prevState => ({\r\n                                                stars: [\r\n                                                    ...prevState.stars,\r\n                                                    toPush\r\n                                                ]\r\n                                            }),\r\n                                            () => {\r\n                                                this.setState({\r\n                                                    selectedShapeName:\r\n                                                        'star' +\r\n                                                        this.state.stars.length\r\n                                                })\r\n                                            }\r\n                                        )\r\n                                    } else if (\r\n                                        copiedElement.name.includes('text')\r\n                                    ) {\r\n                                        length =\r\n                                            this.state.texts.length +\r\n                                            1 +\r\n                                            this.state.textDeleteCount\r\n                                        var toPush = {\r\n                                            x: copiedElement.x + 10,\r\n                                            y: copiedElement.y + 10,\r\n                                            link: copiedElement.link,\r\n\r\n                                            name:\r\n                                                'text' +\r\n                                                (this.state.texts.length +\r\n                                                    1 +\r\n                                                    this.state.textDeleteCount),\r\n                                            ref:\r\n                                                'text' +\r\n                                                (this.state.texts.length +\r\n                                                    1 +\r\n                                                    this.state.textDeleteCount),\r\n                                            fill: copiedElement.fill,\r\n                                            fontSize: copiedElement.fontSize,\r\n                                            fontFamily:\r\n                                                copiedElement.fontFamily,\r\n                                            useImage: copiedElement.useImage,\r\n                                            text: copiedElement.text,\r\n                                            width: copiedElement.width,\r\n                                            rotation: copiedElement.rotation\r\n                                        }\r\n                                        let newName = this.state\r\n                                            .selectedShapeName\r\n\r\n                                        this.setState(\r\n                                            prevState => ({\r\n                                                texts: [\r\n                                                    ...prevState.texts,\r\n                                                    toPush\r\n                                                ]\r\n                                            }),\r\n                                            () => {\r\n                                                this.setState(\r\n                                                    {\r\n                                                        selectedShapeName:\r\n                                                            'text' +\r\n                                                            (this.state.texts\r\n                                                                .length +\r\n                                                                this.state\r\n                                                                    .textDeleteCount)\r\n                                                    },\r\n                                                    () => {\r\n                                                        console.log(\r\n                                                            this.state\r\n                                                                .selectedShapeName\r\n                                                        )\r\n                                                    }\r\n                                                )\r\n                                            }\r\n                                        )\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }}\r\n                    tabIndex=\"0\"\r\n                    style={{ outline: 'none' }}\r\n                >\r\n                    <Stage\r\n                        onClick={this.handleStageClick}\r\n                        onMouseMove={this.handleMouseOver}\r\n                        onWheel={event => this.handleWheel(event)}\r\n                        height={window.innerHeight}\r\n                        width={window.innerWidth}\r\n                        ref=\"graphicStage\"\r\n                    >\r\n                        <Layer\r\n                            scaleX={this.state.layerScale}\r\n                            scaleY={this.state.layerScale}\r\n                            x={this.state.layerX}\r\n                            y={this.state.layerY}\r\n                            height={window.innerHeight}\r\n                            width={window.innerWidth}\r\n                            draggable\r\n                            onDragEnd={() => {\r\n                                this.setState({\r\n                                    layerX: this.refs.layer2.x(),\r\n                                    layerY: this.refs.layer2.y()\r\n                                })\r\n                            }}\r\n                            ref=\"layer2\"\r\n                        >\r\n                            <Rect\r\n                                x={-5 * window.innerWidth}\r\n                                y={-5 * window.innerHeight}\r\n                                height={window.innerHeight * 10}\r\n                                width={window.innerWidth * 10}\r\n                                name=\"\"\r\n                                id=\"ContainerRect\"\r\n                            />\r\n\r\n                            {this.state.rectangles.map(eachRect => {\r\n                                return (\r\n                                    <Rect\r\n                                        onClick={() => {\r\n                                            var that = this\r\n                                            if (\r\n                                                eachRect.link !== undefined &&\r\n                                                eachRect.link !== ''\r\n                                            ) {\r\n                                                this.setState(\r\n                                                    {\r\n                                                        errMsg:\r\n                                                            'Links will not be opened in create mode'\r\n                                                    },\r\n                                                    () => {\r\n                                                        setTimeout(function() {\r\n                                                            that.setState({\r\n                                                                errMsg: ''\r\n                                                            })\r\n                                                        }, 1000)\r\n                                                    }\r\n                                                )\r\n                                            }\r\n                                        }}\r\n                                        onTransformStart={() => {\r\n                                            this.setState({\r\n                                                isTransforming: true\r\n                                            })\r\n                                            let rect = this.refs[eachRect.ref]\r\n                                            rect.setAttr(\r\n                                                'lastRotation',\r\n                                                rect.rotation()\r\n                                            )\r\n                                        }}\r\n                                        onTransform={() => {\r\n                                            let rect = this.refs[eachRect.ref]\r\n\r\n                                            if (\r\n                                                rect.attrs.lastRotation !==\r\n                                                rect.rotation()\r\n                                            ) {\r\n                                                this.state.arrows.map(\r\n                                                    eachArrow => {\r\n                                                        if (\r\n                                                            eachArrow.to &&\r\n                                                            eachArrow.to.name() ===\r\n                                                                rect.name()\r\n                                                        ) {\r\n                                                            this.setState({\r\n                                                                errMsg:\r\n                                                                    'Rotating rects with connectors might skew things up!'\r\n                                                            })\r\n                                                        }\r\n                                                        if (\r\n                                                            eachArrow.from &&\r\n                                                            eachArrow.from.name() ===\r\n                                                                rect.name()\r\n                                                        ) {\r\n                                                            this.setState({\r\n                                                                errMsg:\r\n                                                                    'Rotating rects with connectors might skew things up!'\r\n                                                            })\r\n                                                        }\r\n                                                    }\r\n                                                )\r\n                                            }\r\n\r\n                                            rect.setAttr(\r\n                                                'lastRotation',\r\n                                                rect.rotation()\r\n                                            )\r\n                                        }}\r\n                                        onTransformEnd={() => {\r\n                                            this.setState({\r\n                                                isTransforming: false\r\n                                            })\r\n                                            let rect = this.refs[eachRect.ref]\r\n                                            this.setState(\r\n                                                prevState => ({\r\n                                                    errMsg: '',\r\n                                                    rectangles: prevState.rectangles.map(\r\n                                                        eachRect =>\r\n                                                            eachRect.name ===\r\n                                                            rect.attrs.name\r\n                                                                ? {\r\n                                                                      ...eachRect,\r\n                                                                      width:\r\n                                                                          rect.width() *\r\n                                                                          rect.scaleX(),\r\n                                                                      height:\r\n                                                                          rect.height() *\r\n                                                                          rect.scaleY(),\r\n                                                                      rotation: rect.rotation(),\r\n                                                                      x: rect.x(),\r\n                                                                      y: rect.y()\r\n                                                                  }\r\n                                                                : eachRect\r\n                                                    )\r\n                                                }),\r\n                                                () => {\r\n                                                    this.forceUpdate()\r\n                                                }\r\n                                            )\r\n\r\n                                            rect.setAttr('scaleX', 1)\r\n                                            rect.setAttr('scaleY', 1)\r\n                                        }}\r\n                                        rotation={eachRect.rotation}\r\n                                        ref={eachRect.ref}\r\n                                        fill={eachRect.fill}\r\n                                        name={eachRect.name}\r\n                                        x={eachRect.x}\r\n                                        y={eachRect.y}\r\n                                        width={eachRect.width}\r\n                                        height={eachRect.height}\r\n                                        stroke={eachRect.stroke}\r\n                                        strokeWidth={eachRect.strokeWidth}\r\n                                        strokeScaleEnabled={false}\r\n                                        draggable\r\n                                        onDragMove={() => {\r\n                                            this.state.arrows.map(eachArrow => {\r\n                                                if (\r\n                                                    eachArrow.from !== undefined\r\n                                                ) {\r\n                                                    if (\r\n                                                        eachRect.name ===\r\n                                                        eachArrow.from.attrs\r\n                                                            .name\r\n                                                    ) {\r\n                                                        eachArrow.points = [\r\n                                                            eachRect.x,\r\n                                                            eachRect.y,\r\n                                                            eachArrow.points[2],\r\n                                                            eachArrow.points[3]\r\n                                                        ]\r\n                                                        this.forceUpdate()\r\n                                                    }\r\n                                                }\r\n\r\n                                                if (\r\n                                                    eachArrow.to !== undefined\r\n                                                ) {\r\n                                                    if (\r\n                                                        eachRect.name ==\r\n                                                        eachArrow.to.attrs.name\r\n                                                    ) {\r\n                                                        eachArrow.points = [\r\n                                                            eachArrow.points[0],\r\n                                                            eachArrow.points[1],\r\n                                                            eachRect.x,\r\n                                                            eachRect.y\r\n                                                        ]\r\n                                                        this.forceUpdate()\r\n                                                    }\r\n                                                }\r\n                                            })\r\n                                        }}\r\n                                        onDragEnd={event => {\r\n                                            //cannot compare by name because currentSelected might not be the same\r\n                                            //have to use ref, which appears to be overcomplicated\r\n                                            var shape = this.refs[eachRect.ref]\r\n                                            /*    this.state.rectangles.map(eachRect => {\r\n                          if (eachRect.name === shape.attrs.name) {\r\n                            shape.position({\r\n                              x: event.target.x(),\r\n                              y: event.target.y()\r\n                            });\r\n                          }\r\n                        });*/\r\n\r\n                                            this.setState(prevState => ({\r\n                                                rectangles: prevState.rectangles.map(\r\n                                                    eachRect =>\r\n                                                        eachRect.name ===\r\n                                                        shape.attrs.name\r\n                                                            ? {\r\n                                                                  ...eachRect,\r\n                                                                  x: event.target.x(),\r\n                                                                  y: event.target.y()\r\n                                                              }\r\n                                                            : eachRect\r\n                                                )\r\n                                            }))\r\n                                        }}\r\n                                    />\r\n                                )\r\n                            })}\r\n                            {this.state.ellipses.map(eachEllipse => (\r\n                                <Ellipse\r\n                                    ref={eachEllipse.ref}\r\n                                    name={eachEllipse.name}\r\n                                    x={eachEllipse.x}\r\n                                    y={eachEllipse.y}\r\n                                    rotation={eachEllipse.rotation}\r\n                                    radiusX={eachEllipse.radiusX}\r\n                                    radiusY={eachEllipse.radiusY}\r\n                                    fill={eachEllipse.fill}\r\n                                    stroke={eachEllipse.stroke}\r\n                                    strokeWidth={eachEllipse.strokeWidth}\r\n                                    strokeScaleEnabled={false}\r\n                                    onClick={() => {\r\n                                        var that = this\r\n                                        if (\r\n                                            eachEllipse.link !== undefined &&\r\n                                            eachEllipse.link !== ''\r\n                                        ) {\r\n                                            this.setState(\r\n                                                {\r\n                                                    errMsg:\r\n                                                        'Links will not be opened in create mode'\r\n                                                },\r\n                                                () => {\r\n                                                    setTimeout(function() {\r\n                                                        that.setState({\r\n                                                            errMsg: ''\r\n                                                        })\r\n                                                    }, 1000)\r\n                                                }\r\n                                            )\r\n                                        }\r\n                                    }}\r\n                                    onTransformStart={() => {\r\n                                        this.setState({ isTransforming: true })\r\n                                        let ellipse = this.refs[eachEllipse.ref]\r\n                                        ellipse.setAttr(\r\n                                            'lastRotation',\r\n                                            ellipse.rotation()\r\n                                        )\r\n                                    }}\r\n                                    onTransform={() => {\r\n                                        let ellipse = this.refs[eachEllipse.ref]\r\n\r\n                                        if (\r\n                                            ellipse.attrs.lastRotation !==\r\n                                            ellipse.rotation()\r\n                                        ) {\r\n                                            this.state.arrows.map(eachArrow => {\r\n                                                if (\r\n                                                    eachArrow.to &&\r\n                                                    eachArrow.to.name() ===\r\n                                                        ellipse.name()\r\n                                                ) {\r\n                                                    this.setState({\r\n                                                        errMsg:\r\n                                                            'Rotating ellipses with connectors might skew things up!'\r\n                                                    })\r\n                                                }\r\n                                                if (\r\n                                                    eachArrow.from &&\r\n                                                    eachArrow.from.name() ===\r\n                                                        ellipse.name()\r\n                                                ) {\r\n                                                    this.setState({\r\n                                                        errMsg:\r\n                                                            'Rotating ellipses with connectors might skew things up!'\r\n                                                    })\r\n                                                }\r\n                                            })\r\n                                        }\r\n\r\n                                        ellipse.setAttr(\r\n                                            'lastRotation',\r\n                                            ellipse.rotation()\r\n                                        )\r\n                                    }}\r\n                                    onTransformEnd={() => {\r\n                                        this.setState({ isTransforming: false })\r\n                                        let ellipse = this.refs[eachEllipse.ref]\r\n                                        let scaleX = ellipse.scaleX(),\r\n                                            scaleY = ellipse.scaleY()\r\n\r\n                                        this.setState(prevState => ({\r\n                                            errMsg: '',\r\n                                            ellipses: prevState.ellipses.map(\r\n                                                eachEllipse =>\r\n                                                    eachEllipse.name ===\r\n                                                    ellipse.attrs.name\r\n                                                        ? {\r\n                                                              ...eachEllipse,\r\n\r\n                                                              radiusX:\r\n                                                                  ellipse.radiusX() *\r\n                                                                  ellipse.scaleX(),\r\n                                                              radiusY:\r\n                                                                  ellipse.radiusY() *\r\n                                                                  ellipse.scaleY(),\r\n                                                              rotation: ellipse.rotation(),\r\n                                                              x: ellipse.x(),\r\n                                                              y: ellipse.y()\r\n                                                          }\r\n                                                        : eachEllipse\r\n                                            )\r\n                                        }))\r\n\r\n                                        ellipse.setAttr('scaleX', 1)\r\n                                        ellipse.setAttr('scaleY', 1)\r\n                                        this.forceUpdate()\r\n                                    }}\r\n                                    draggable\r\n                                    onDragMove={() => {\r\n                                        console.log(\r\n                                            'name of ellipse moving: ',\r\n                                            eachEllipse.name,\r\n                                            'new x y',\r\n                                            eachEllipse.x,\r\n                                            eachEllipse.y\r\n                                        )\r\n                                        this.state.arrows.map(eachArrow => {\r\n                                            if (eachArrow.from !== undefined) {\r\n                                                console.log(\r\n                                                    'prevArrow: ',\r\n                                                    eachArrow.points\r\n                                                )\r\n                                                if (\r\n                                                    eachEllipse.name ==\r\n                                                    eachArrow.from.attrs.name\r\n                                                ) {\r\n                                                    eachArrow.points = [\r\n                                                        eachEllipse.x,\r\n                                                        eachEllipse.y,\r\n                                                        eachArrow.points[2],\r\n                                                        eachArrow.points[3]\r\n                                                    ]\r\n                                                    this.forceUpdate()\r\n                                                    this.refs.graphicStage.draw()\r\n                                                }\r\n                                                console.log(\r\n                                                    'new arrows:',\r\n                                                    eachArrow.points\r\n                                                )\r\n                                            }\r\n\r\n                                            if (eachArrow.to !== undefined) {\r\n                                                if (\r\n                                                    eachEllipse.name ===\r\n                                                    eachArrow.to.attrs.name\r\n                                                ) {\r\n                                                    eachArrow.points = [\r\n                                                        eachArrow.points[0],\r\n                                                        eachArrow.points[1],\r\n                                                        eachEllipse.x,\r\n                                                        eachEllipse.y\r\n                                                    ]\r\n                                                    this.forceUpdate()\r\n                                                    this.refs.graphicStage.draw()\r\n                                                }\r\n                                            }\r\n                                        })\r\n                                    }}\r\n                                    onDragEnd={event => {\r\n                                        //cannot compare by name because currentSelected might not be the same\r\n                                        //have to use ref, which appears to be overcomplicated\r\n                                        var shape = this.refs[eachEllipse.ref]\r\n\r\n                                        this.setState(prevState => ({\r\n                                            ellipses: prevState.ellipses.map(\r\n                                                eachEllipse =>\r\n                                                    eachEllipse.name ===\r\n                                                    shape.attrs.name\r\n                                                        ? {\r\n                                                              ...eachEllipse,\r\n                                                              x: event.target.x(),\r\n                                                              y: event.target.y()\r\n                                                          }\r\n                                                        : eachEllipse\r\n                                            )\r\n                                        }))\r\n\r\n                                        this.refs.graphicStage.draw()\r\n                                    }}\r\n                                />\r\n                            ))}\r\n                            {this.state.stars.map(eachStar => (\r\n                                <Star\r\n                                    ref={eachStar.ref}\r\n                                    name={eachStar.name}\r\n                                    x={eachStar.x}\r\n                                    y={eachStar.y}\r\n                                    innerRadius={eachStar.innerRadius}\r\n                                    outerRadius={eachStar.outerRadius}\r\n                                    numPoints={eachStar.numPoints}\r\n                                    stroke={eachStar.stroke}\r\n                                    strokeWidth={eachStar.strokeWidth}\r\n                                    fill={eachStar.fill}\r\n                                    strokeScaleEnabled={false}\r\n                                    rotation={eachStar.rotation}\r\n                                    onClick={() => {\r\n                                        var that = this\r\n                                        if (\r\n                                            eachStar.link !== undefined &&\r\n                                            eachStar.link !== ''\r\n                                        ) {\r\n                                            this.setState(\r\n                                                {\r\n                                                    errMsg:\r\n                                                        'Links will not be opened in create mode'\r\n                                                },\r\n                                                () => {\r\n                                                    setTimeout(function() {\r\n                                                        that.setState({\r\n                                                            errMsg: ''\r\n                                                        })\r\n                                                    }, 1000)\r\n                                                }\r\n                                            )\r\n                                        }\r\n                                    }}\r\n                                    onTransformStart={() => {\r\n                                        this.setState({ isTransforming: true })\r\n                                    }}\r\n                                    onTransformEnd={() => {\r\n                                        this.setState({ isTransforming: false })\r\n                                        let star = this.refs[eachStar.ref]\r\n                                        let scaleX = star.scaleX(),\r\n                                            scaleY = star.scaleY()\r\n\r\n                                        this.setState(prevState => ({\r\n                                            stars: prevState.stars.map(\r\n                                                eachStar =>\r\n                                                    eachStar.name ===\r\n                                                    star.attrs.name\r\n                                                        ? {\r\n                                                              ...eachStar,\r\n                                                              innerRadius:\r\n                                                                  star.innerRadius() *\r\n                                                                  star.scaleX(),\r\n                                                              outerRadius:\r\n                                                                  star.outerRadius() *\r\n                                                                  star.scaleX(),\r\n                                                              rotation: star.rotation(),\r\n                                                              x: star.x(),\r\n                                                              y: star.y()\r\n                                                          }\r\n                                                        : eachStar\r\n                                            )\r\n                                        }))\r\n                                        star.setAttr('scaleX', 1)\r\n                                        star.setAttr('scaleY', 1)\r\n                                        this.forceUpdate()\r\n                                    }}\r\n                                    draggable\r\n                                    onDragMove={() => {\r\n                                        this.state.arrows.map(eachArrow => {\r\n                                            if (eachArrow.from !== undefined) {\r\n                                                if (\r\n                                                    eachStar.name ==\r\n                                                    eachArrow.from.attrs.name\r\n                                                ) {\r\n                                                    eachArrow.points = [\r\n                                                        eachStar.x,\r\n                                                        eachStar.y,\r\n                                                        eachArrow.points[2],\r\n                                                        eachArrow.points[3]\r\n                                                    ]\r\n                                                    this.forceUpdate()\r\n                                                }\r\n                                            }\r\n\r\n                                            if (eachArrow.to !== undefined) {\r\n                                                if (\r\n                                                    eachStar.name ===\r\n                                                    eachArrow.to.attrs.name\r\n                                                ) {\r\n                                                    eachArrow.points = [\r\n                                                        eachArrow.points[0],\r\n                                                        eachArrow.points[1],\r\n                                                        eachStar.x,\r\n                                                        eachStar.y\r\n                                                    ]\r\n                                                    this.forceUpdate()\r\n                                                }\r\n                                            }\r\n                                        })\r\n                                    }}\r\n                                    onDragEnd={event => {\r\n                                        //cannot compare by name because currentSelected might not be the same\r\n                                        //have to use ref, which appears to be overcomplicated\r\n                                        var shape = this.refs[eachStar.ref]\r\n\r\n                                        this.setState(prevState => ({\r\n                                            stars: prevState.stars.map(\r\n                                                eachStar =>\r\n                                                    eachStar.name ===\r\n                                                    shape.attrs.name\r\n                                                        ? {\r\n                                                              ...eachStar,\r\n                                                              x: event.target.x(),\r\n                                                              y: event.target.y()\r\n                                                          }\r\n                                                        : eachStar\r\n                                            )\r\n                                        }))\r\n                                    }}\r\n                                />\r\n                            ))}\r\n                            {this.state.texts.map(eachText => (\r\n                                //perhaps this.state.texts only need to contain refs?\r\n                                //so that we only need to store the refs to get more information\r\n                                <Text\r\n                                    textDecoration={\r\n                                        eachText.link ? 'underline' : ''\r\n                                    }\r\n                                    onTransformStart={() => {\r\n                                        var currentText = this.refs[\r\n                                            this.state.selectedShapeName\r\n                                        ]\r\n                                        currentText.setAttr(\r\n                                            'lastRotation',\r\n                                            currentText.rotation()\r\n                                        )\r\n                                    }}\r\n                                    onTransform={() => {\r\n                                        var currentText = this.refs[\r\n                                            this.state.selectedShapeName\r\n                                        ]\r\n\r\n                                        currentText.setAttr(\r\n                                            'width',\r\n                                            currentText.width() *\r\n                                                currentText.scaleX()\r\n                                        )\r\n                                        currentText.setAttr('scaleX', 1)\r\n\r\n                                        currentText.draw()\r\n\r\n                                        if (\r\n                                            currentText.attrs.lastRotation !==\r\n                                            currentText.rotation()\r\n                                        ) {\r\n                                            this.state.arrows.map(eachArrow => {\r\n                                                if (\r\n                                                    eachArrow.to &&\r\n                                                    eachArrow.to.name() ===\r\n                                                        currentText.name()\r\n                                                ) {\r\n                                                    this.setState({\r\n                                                        errMsg:\r\n                                                            'Rotating texts with connectors might skew things up!'\r\n                                                    })\r\n                                                }\r\n                                                if (\r\n                                                    eachArrow.from &&\r\n                                                    eachArrow.from.name() ===\r\n                                                        currentText.name()\r\n                                                ) {\r\n                                                    this.setState({\r\n                                                        errMsg:\r\n                                                            'Rotating texts with connectors might skew things up!'\r\n                                                    })\r\n                                                }\r\n                                            })\r\n                                        }\r\n\r\n                                        currentText.setAttr(\r\n                                            'lastRotation',\r\n                                            currentText.rotation()\r\n                                        )\r\n                                    }}\r\n                                    onTransformEnd={() => {\r\n                                        var currentText = this.refs[\r\n                                            this.state.selectedShapeName\r\n                                        ]\r\n\r\n                                        this.setState(prevState => ({\r\n                                            errMsg: '',\r\n                                            texts: prevState.texts.map(\r\n                                                eachText =>\r\n                                                    eachText.name ===\r\n                                                    this.state.selectedShapeName\r\n                                                        ? {\r\n                                                              ...eachText,\r\n                                                              width: currentText.width(),\r\n                                                              rotation: currentText.rotation(),\r\n                                                              textWidth:\r\n                                                                  currentText.textWidth,\r\n                                                              textHeight:\r\n                                                                  currentText.textHeight,\r\n                                                              x: currentText.x(),\r\n                                                              y: currentText.y()\r\n                                                          }\r\n                                                        : eachText\r\n                                            )\r\n                                        }))\r\n                                        currentText.setAttr('scaleX', 1)\r\n                                        currentText.draw()\r\n                                    }}\r\n                                    link={eachText.link}\r\n                                    width={eachText.width}\r\n                                    fill={eachText.fill}\r\n                                    name={eachText.name}\r\n                                    ref={eachText.ref}\r\n                                    rotation={eachText.rotation}\r\n                                    fontFamily={eachText.fontFamily}\r\n                                    fontSize={eachText.fontSize}\r\n                                    x={eachText.x}\r\n                                    y={eachText.y}\r\n                                    text={eachText.text}\r\n                                    draggable\r\n                                    onDragMove={() => {\r\n                                        this.state.arrows.map(eachArrow => {\r\n                                            if (eachArrow.from !== undefined) {\r\n                                                if (\r\n                                                    eachText.name ===\r\n                                                    eachArrow.from.attrs.name\r\n                                                ) {\r\n                                                    eachArrow.points = [\r\n                                                        eachText.x,\r\n                                                        eachText.y,\r\n                                                        eachArrow.points[2],\r\n                                                        eachArrow.points[3]\r\n                                                    ]\r\n                                                    this.forceUpdate()\r\n                                                }\r\n                                            }\r\n\r\n                                            if (eachArrow.to !== undefined) {\r\n                                                if (\r\n                                                    eachText.name ===\r\n                                                    eachArrow.to.attrs.name\r\n                                                ) {\r\n                                                    eachArrow.points = [\r\n                                                        eachArrow.points[0],\r\n                                                        eachArrow.points[1],\r\n                                                        eachText.x,\r\n                                                        eachText.y\r\n                                                    ]\r\n                                                    this.forceUpdate()\r\n                                                }\r\n                                            }\r\n                                        })\r\n                                    }}\r\n                                    onDragEnd={event => {\r\n                                        //cannot compare by name because currentSelected might not be the same\r\n                                        //have to use ref, which appears to be overcomplicated\r\n                                        var shape = this.refs[eachText.ref]\r\n\r\n                                        this.setState(prevState => ({\r\n                                            texts: prevState.texts.map(\r\n                                                eachtext =>\r\n                                                    eachtext.name ===\r\n                                                    shape.attrs.name\r\n                                                        ? {\r\n                                                              ...eachtext,\r\n                                                              x: event.target.x(),\r\n                                                              y: event.target.y()\r\n                                                          }\r\n                                                        : eachtext\r\n                                            )\r\n                                        }))\r\n                                    }}\r\n                                    onClick={() => {\r\n                                        var that = this\r\n                                        if (\r\n                                            eachText.link !== undefined &&\r\n                                            eachText.link !== ''\r\n                                        ) {\r\n                                            this.setState(\r\n                                                {\r\n                                                    errMsg:\r\n                                                        'Links will not be opened in create mode'\r\n                                                },\r\n                                                () => {\r\n                                                    setTimeout(function() {\r\n                                                        that.setState({\r\n                                                            errMsg: ''\r\n                                                        })\r\n                                                    }, 1000)\r\n                                                }\r\n                                            )\r\n\r\n                                            //var win = window.open(eachText.link, \"_blank\");\r\n                                            //win.focus();\r\n                                        }\r\n                                    }}\r\n                                    onDblClick={() => {\r\n                                        // turn into textarea\r\n                                        var stage = this.refs.graphicStage\r\n                                        var text = stage.findOne(\r\n                                            '.' + eachText.name\r\n                                        )\r\n\r\n                                        this.setState({\r\n                                            textX: text.absolutePosition().x,\r\n                                            textY: text.absolutePosition().y,\r\n                                            textEditVisible: !this.state\r\n                                                .textEditVisible,\r\n                                            text: eachText.text,\r\n                                            textNode: eachText,\r\n                                            currentTextRef: eachText.ref,\r\n                                            textareaWidth: text.textWidth,\r\n                                            textareaHeight: text.textHeight,\r\n                                            textareaFill: text.attrs.fill,\r\n                                            textareaFontFamily:\r\n                                                text.attrs.fontFamily,\r\n                                            textareaFontSize:\r\n                                                text.attrs.fontSize\r\n                                        })\r\n                                        let textarea = this.refs.textarea\r\n                                        textarea.focus()\r\n                                        text.hide()\r\n                                        var transformer = stage.findOne(\r\n                                            '.transformer'\r\n                                        )\r\n                                        transformer.hide()\r\n                                        this.refs.layer2.draw()\r\n                                    }}\r\n                                />\r\n                            ))}\r\n                            {this.state.arrows.map(eachArrow => {\r\n                                if (!eachArrow.from && !eachArrow.to) {\r\n                                    return (\r\n                                        <Arrow\r\n                                            ref={eachArrow.ref}\r\n                                            name={eachArrow.name}\r\n                                            points={[\r\n                                                eachArrow.points[0],\r\n                                                eachArrow.points[1],\r\n                                                eachArrow.points[2],\r\n                                                eachArrow.points[3]\r\n                                            ]}\r\n                                            stroke={eachArrow.stroke}\r\n                                            fill={eachArrow.fill}\r\n                                            draggable\r\n                                            onDragEnd={event => {\r\n                                                //set new points to current position\r\n\r\n                                                //usually: state => star => x & y\r\n                                                //now: state => arrow => attr => x & y\r\n\r\n                                                let oldPoints = [\r\n                                                    eachArrow.points[0],\r\n                                                    eachArrow.points[1],\r\n                                                    eachArrow.points[2],\r\n                                                    eachArrow.points[3]\r\n                                                ]\r\n\r\n                                                let shiftX = this.refs[\r\n                                                    eachArrow.ref\r\n                                                ].attrs.x\r\n                                                let shiftY = this.refs[\r\n                                                    eachArrow.ref\r\n                                                ].attrs.y\r\n\r\n                                                let newPoints = [\r\n                                                    oldPoints[0] + shiftX,\r\n                                                    oldPoints[1] + shiftY,\r\n                                                    oldPoints[2] + shiftX,\r\n                                                    oldPoints[3] + shiftY\r\n                                                ]\r\n\r\n                                                this.refs[\r\n                                                    eachArrow.ref\r\n                                                ].position({ x: 0, y: 0 })\r\n                                                this.refs.layer2.draw()\r\n\r\n                                                this.setState(prevState => ({\r\n                                                    arrows: prevState.arrows.map(\r\n                                                        eachArr =>\r\n                                                            eachArr.name ===\r\n                                                            eachArrow.name\r\n                                                                ? {\r\n                                                                      ...eachArr,\r\n                                                                      points: newPoints\r\n                                                                  }\r\n                                                                : eachArr\r\n                                                    )\r\n                                                }))\r\n                                            }}\r\n                                        />\r\n                                    )\r\n                                } else if (\r\n                                    eachArrow.name === this.state.newArrowRef &&\r\n                                    (eachArrow.from || eachArrow.to)\r\n                                ) {\r\n                                    return (\r\n                                        <Connector\r\n                                            name={eachArrow.name}\r\n                                            from={eachArrow.from}\r\n                                            to={eachArrow.to}\r\n                                            arrowEndX={this.state.arrowEndX}\r\n                                            arrowEndY={this.state.arrowEndY}\r\n                                            current={true}\r\n                                            stroke={eachArrow.stroke}\r\n                                            fill={eachArrow.fill}\r\n                                        />\r\n                                    )\r\n                                } else if (eachArrow.from || eachArrow.to) {\r\n                                    //if arrow construction is completed\r\n                                    return (\r\n                                        <Connector\r\n                                            name={eachArrow.name}\r\n                                            from={eachArrow.from}\r\n                                            to={eachArrow.to}\r\n                                            points={eachArrow.points}\r\n                                            current={false}\r\n                                            stroke={eachArrow.stroke}\r\n                                            fill={eachArrow.fill}\r\n                                        />\r\n                                    )\r\n                                }\r\n                            })}\r\n\r\n                            {this.state.selectedShapeName.includes('text') ? (\r\n                                <TransformerComponent\r\n                                    selectedShapeName={\r\n                                        this.state.selectedShapeName\r\n                                    }\r\n                                />\r\n                            ) : (\r\n                                <TransformerComponent\r\n                                    selectedShapeName={\r\n                                        this.state.selectedShapeName\r\n                                    }\r\n                                />\r\n                            )}\r\n                        </Layer>\r\n\r\n                        <Layer\r\n                            height={window.innerHeight}\r\n                            width={window.innerWidth}\r\n                            ref=\"layer\"\r\n                        >\r\n                            <Toolbar\r\n                                layer={this.refs.layer2}\r\n                                rectName={\r\n                                    this.state.rectangles.length +\r\n                                    1 +\r\n                                    this.state.rectDeleteCount\r\n                                }\r\n                                ellipseName={\r\n                                    this.state.ellipses.length +\r\n                                    1 +\r\n                                    this.state.ellipseDeleteCount\r\n                                }\r\n                                starName={\r\n                                    this.state.stars.length +\r\n                                    1 +\r\n                                    this.state.starDeleteCount\r\n                                }\r\n                                textName={\r\n                                    this.state.texts.length +\r\n                                    1 +\r\n                                    this.state.textDeleteCount\r\n                                }\r\n                                newArrowOnDragEnd={toPush => {\r\n                                    if (toPush.from !== undefined) {\r\n                                        //  console.log(\"we are making a connector\");\r\n\r\n                                        var transform = this.refs.layer2\r\n                                            .getAbsoluteTransform()\r\n                                            .copy()\r\n                                        transform.invert()\r\n                                        let uh = transform.point({\r\n                                            x: toPush.x,\r\n                                            y: toPush.y\r\n                                        })\r\n                                        toPush.x = uh.x\r\n                                        toPush.y = uh.y\r\n\r\n                                        var newArrow = {\r\n                                            points: toPush.points,\r\n                                            ref:\r\n                                                'arrow' +\r\n                                                (this.state.arrows.length +\r\n                                                    1 +\r\n                                                    this.state\r\n                                                        .arrowDeleteCount),\r\n                                            name:\r\n                                                'arrow' +\r\n                                                (this.state.arrows.length +\r\n                                                    1 +\r\n                                                    this.state\r\n                                                        .arrowDeleteCount),\r\n                                            from: toPush.from,\r\n                                            stroke: toPush.stroke,\r\n                                            strokeWidth: toPush.strokeWidth,\r\n                                            fill: toPush.fill\r\n                                        }\r\n\r\n                                        //  console.log(newArrow);\r\n                                        this.setState(prevState => ({\r\n                                            arrows: [\r\n                                                ...prevState.arrows,\r\n                                                newArrow\r\n                                            ],\r\n                                            newArrowDropped: true,\r\n                                            newArrowRef: newArrow.name,\r\n                                            arrowEndX: toPush.x,\r\n                                            arrowEndY: toPush.y\r\n                                        }))\r\n                                    } else {\r\n                                        //  console.log(\"we are making just an aarrow\");\r\n                                        var transform = this.refs.layer2\r\n                                            .getAbsoluteTransform()\r\n                                            .copy()\r\n                                        transform.invert()\r\n                                        let uh = transform.point({\r\n                                            x: toPush.x,\r\n                                            y: toPush.y\r\n                                        })\r\n                                        toPush.x = uh.x\r\n                                        toPush.y = uh.y\r\n                                        var newArrow = {\r\n                                            points: [\r\n                                                toPush.x,\r\n                                                toPush.y,\r\n                                                toPush.x,\r\n                                                toPush.y\r\n                                            ],\r\n                                            ref:\r\n                                                'arrow' +\r\n                                                (this.state.arrows.length +\r\n                                                    1 +\r\n                                                    this.state\r\n                                                        .arrowDeleteCount),\r\n                                            name:\r\n                                                'arrow' +\r\n                                                (this.state.arrows.length +\r\n                                                    1 +\r\n                                                    this.state\r\n                                                        .arrowDeleteCount),\r\n                                            from: toPush.from,\r\n                                            stroke: toPush.stroke,\r\n                                            strokeWidth: toPush.strokeWidth,\r\n                                            fill: toPush.fill\r\n                                        }\r\n\r\n                                        this.setState(prevState => ({\r\n                                            arrows: [\r\n                                                ...prevState.arrows,\r\n                                                newArrow\r\n                                            ],\r\n                                            newArrowDropped: true,\r\n                                            newArrowRef: newArrow.name,\r\n                                            arrowEndX: toPush.x,\r\n                                            arrowEndY: toPush.y\r\n                                        }))\r\n                                    }\r\n\r\n                                    //this.refs updates after forceUpdate (because arrow gets instantiated), might be risky in the future\r\n                                    //only this.state.arrows.length because it was pushed earlier, cancelling the +1\r\n                                }}\r\n                                appendToRectangles={stuff => {\r\n                                    var layer = this.refs.layer2\r\n                                    var toPush = stuff\r\n                                    var stage = this.refs.graphicStage\r\n                                    var transform = this.refs.layer2\r\n                                        .getAbsoluteTransform()\r\n                                        .copy()\r\n                                    transform.invert()\r\n\r\n                                    var pos = transform.point({\r\n                                        x: toPush.x,\r\n                                        y: toPush.y\r\n                                    })\r\n\r\n                                    if (\r\n                                        layer.attrs.x !== null ||\r\n                                        layer.attrs.x !== undefined\r\n                                    ) {\r\n                                        toPush.x = pos.x\r\n                                        toPush.y = pos.y\r\n                                    }\r\n\r\n                                    this.setState(prevState => ({\r\n                                        rectangles: [\r\n                                            ...prevState.rectangles,\r\n                                            toPush\r\n                                        ],\r\n                                        selectedShapeName: toPush.name\r\n                                    }))\r\n                                }}\r\n                                appendToEllipses={stuff => {\r\n                                    var layer = this.refs.layer2\r\n                                    var toPush = stuff\r\n                                    var stage = this.refs.graphicStage\r\n                                    var transform = this.refs.layer2\r\n                                        .getAbsoluteTransform()\r\n                                        .copy()\r\n                                    transform.invert()\r\n\r\n                                    var pos = transform.point({\r\n                                        x: toPush.x,\r\n                                        y: toPush.y\r\n                                    })\r\n\r\n                                    if (\r\n                                        layer.attrs.x !== null ||\r\n                                        layer.attrs.x !== undefined\r\n                                    ) {\r\n                                        toPush.x = pos.x\r\n                                        toPush.y = pos.y\r\n                                    }\r\n\r\n                                    this.setState(prevState => ({\r\n                                        ellipses: [\r\n                                            ...prevState.ellipses,\r\n                                            toPush\r\n                                        ],\r\n                                        selectedShapeName: toPush.name\r\n                                    }))\r\n                                }}\r\n                                appendToStars={stuff => {\r\n                                    var layer = this.refs.layer2\r\n                                    var toPush = stuff\r\n                                    var stage = this.refs.graphicStage\r\n                                    var transform = this.refs.layer2\r\n                                        .getAbsoluteTransform()\r\n                                        .copy()\r\n                                    transform.invert()\r\n\r\n                                    var pos = transform.point({\r\n                                        x: toPush.x,\r\n                                        y: toPush.y\r\n                                    })\r\n\r\n                                    if (\r\n                                        layer.attrs.x !== null ||\r\n                                        layer.attrs.x !== undefined\r\n                                    ) {\r\n                                        toPush.x = pos.x\r\n                                        toPush.y = pos.y\r\n                                    }\r\n                                    this.setState(prevState => ({\r\n                                        stars: [...prevState.stars, toPush],\r\n                                        selectedShapeName: toPush.name\r\n                                    }))\r\n                                }}\r\n                                appendToTexts={stuff => {\r\n                                    var layer = this.refs.layer2\r\n                                    var toPush = stuff\r\n                                    var stage = this.refs.graphicStage\r\n                                    var transform = this.refs.layer2\r\n                                        .getAbsoluteTransform()\r\n                                        .copy()\r\n                                    transform.invert()\r\n\r\n                                    var pos = transform.point({\r\n                                        x: toPush.x,\r\n                                        y: toPush.y\r\n                                    })\r\n\r\n                                    if (\r\n                                        layer.attrs.x !== null ||\r\n                                        layer.attrs.x !== undefined\r\n                                    ) {\r\n                                        toPush.x = pos.x\r\n                                        toPush.y = pos.y\r\n                                    }\r\n\r\n                                    this.setState(prevState => ({\r\n                                        texts: [...prevState.texts, toPush]\r\n                                    }))\r\n\r\n                                    //we can also just get element by this.refs.toPush.ref\r\n\r\n                                    //  let text = stage.findOne(\".\" + toPush.name);\r\n                                    let text = this.refs[toPush.ref]\r\n                                    //this.setState({firstTimeTextEditing: true});\r\n                                    text.fire('dblclick')\r\n                                }}\r\n                            />\r\n                        </Layer>\r\n                    </Stage>\r\n\r\n                    <textarea\r\n                        ref=\"textarea\"\r\n                        id=\"textarea\"\r\n                        value={this.state.text}\r\n                        onChange={e => {\r\n                            this.setState({\r\n                                text: e.target.value,\r\n                                shouldTextUpdate: false\r\n                            })\r\n                        }}\r\n                        onKeyDown={e => {\r\n                            if (e.keyCode === 13) {\r\n                                this.setState({\r\n                                    textEditVisible: false,\r\n                                    shouldTextUpdate: true\r\n                                })\r\n\r\n                                // get the current textNode we are editing, get the name from there\r\n                                //match name with elements in this.state.texts,\r\n                                let node = this.refs[this.state.currentTextRef]\r\n                                console.log(\r\n                                    'node width before set',\r\n                                    node.textWidth\r\n                                )\r\n                                let name = node.attrs.name\r\n                                this.setState(\r\n                                    prevState => ({\r\n                                        selectedShapeName: name,\r\n                                        texts: prevState.texts.map(eachText =>\r\n                                            eachText.name === name\r\n                                                ? {\r\n                                                      ...eachText,\r\n                                                      text: this.state.text\r\n                                                  }\r\n                                                : eachText\r\n                                        )\r\n                                    }),\r\n                                    () => {\r\n                                        this.setState(prevState => ({\r\n                                            texts: prevState.texts.map(\r\n                                                eachText =>\r\n                                                    eachText.name === name\r\n                                                        ? {\r\n                                                              ...eachText,\r\n                                                              textWidth:\r\n                                                                  node.textWidth,\r\n                                                              textHeight:\r\n                                                                  node.textHeight\r\n                                                          }\r\n                                                        : eachText\r\n                                            )\r\n                                        }))\r\n                                    }\r\n                                )\r\n\r\n                                node.show()\r\n                                this.refs.graphicStage\r\n                                    .findOne('.transformer')\r\n                                    .show()\r\n                            }\r\n                        }}\r\n                        onBlur={() => {\r\n                            this.setState({\r\n                                textEditVisible: false,\r\n                                shouldTextUpdate: true\r\n                            })\r\n\r\n                            // get the current textNode we are editing, get the name from there\r\n                            //match name with elements in this.state.texts,\r\n\r\n                            let node = this.refs.graphicStage.findOne(\r\n                                '.' + this.state.currentTextRef\r\n                            )\r\n                            let name = node.attrs.name\r\n\r\n                            this.setState(\r\n                                prevState => ({\r\n                                    selectedShapeName: name,\r\n                                    texts: prevState.texts.map(eachText =>\r\n                                        eachText.name === name\r\n                                            ? {\r\n                                                  ...eachText,\r\n                                                  text: this.state.text\r\n                                              }\r\n                                            : eachText\r\n                                    )\r\n                                }),\r\n                                () => {\r\n                                    this.setState(prevState => ({\r\n                                        texts: prevState.texts.map(eachText =>\r\n                                            eachText.name === name\r\n                                                ? {\r\n                                                      ...eachText,\r\n                                                      textWidth: node.textWidth,\r\n                                                      textHeight:\r\n                                                          node.textHeight\r\n                                                  }\r\n                                                : eachText\r\n                                        )\r\n                                    }))\r\n                                }\r\n                            )\r\n                            node.show()\r\n                            this.refs.graphicStage\r\n                                .findOne('.transformer')\r\n                                .show()\r\n                            this.refs.graphicStage.draw()\r\n                        }}\r\n                        style={{\r\n                            //set position, width, height, fontSize, overflow, lineHeight, color\r\n                            display: this.state.textEditVisible\r\n                                ? 'block'\r\n                                : 'none',\r\n                            position: 'absolute',\r\n                            top: this.state.textY + 80 + 'px',\r\n                            left: this.state.textX + 'px',\r\n                            width: '300px',\r\n                            height: '300px',\r\n                            overflow: 'hidden',\r\n                            fontSize: this.state.textareaFontSize,\r\n                            fontFamily: this.state.textareaFontFamily,\r\n                            color: this.state.textareaFill,\r\n                            border: 'none',\r\n                            padding: '0px',\r\n                            margin: '0px',\r\n                            outline: 'none',\r\n                            resize: 'none',\r\n                            background: 'none'\r\n                        }}\r\n                    />\r\n                    <div className=\"errMsg\">{errDisplay}</div>\r\n                    <RightToolBar\r\n                        disablePaste={() => {\r\n                            this.setState({ isPasteDisabled: true })\r\n                        }}\r\n                        selectedName={this.state.selectedShapeName}\r\n                        stage={this.refs.graphicStage}\r\n                        newImage={shape => {\r\n                            this.state.rectangles.map(eachRect => {\r\n                                if (eachRect.name === shape.attrs.name) {\r\n                                    var index = this.state.rectangles.indexOf(\r\n                                        eachRect\r\n                                    )\r\n                                    this.state.rectangles[\r\n                                        index\r\n                                    ].fillPatternImage =\r\n                                        shape.attrs.fillPatternImage\r\n\r\n                                    this.state.rectangles[index].useImage =\r\n                                        shape.attrs.useImage\r\n                                    this.forceUpdate()\r\n                                }\r\n                            })\r\n                        }}\r\n                        useFill={stuff => {\r\n                            let shapeName = stuff.shape.attrs.name\r\n                            if (shapeName.includes('rect')) {\r\n                                if (stuff.type === 'shapeFill') {\r\n                                    this.setState(prevState => ({\r\n                                        rectangles: prevState.rectangles.map(\r\n                                            eachRect =>\r\n                                                eachRect.name === shapeName\r\n                                                    ? {\r\n                                                          ...eachRect,\r\n                                                          fill: stuff.color\r\n                                                      }\r\n                                                    : eachRect\r\n                                        )\r\n                                    }))\r\n                                } else if (stuff.type === 'strokeFill') {\r\n                                    this.setState(prevState => ({\r\n                                        rectangles: prevState.rectangles.map(\r\n                                            eachRect =>\r\n                                                eachRect.name === shapeName\r\n                                                    ? {\r\n                                                          ...eachRect,\r\n                                                          stroke: stuff.color\r\n                                                      }\r\n                                                    : eachRect\r\n                                        )\r\n                                    }))\r\n                                }\r\n                            }\r\n                            if (shapeName.includes('ellipse')) {\r\n                                if (stuff.type === 'shapeFill') {\r\n                                    this.setState(prevState => ({\r\n                                        ellipses: prevState.ellipses.map(\r\n                                            eachEllipse =>\r\n                                                eachEllipse.name === shapeName\r\n                                                    ? {\r\n                                                          ...eachEllipse,\r\n                                                          fill: stuff.color\r\n                                                      }\r\n                                                    : eachEllipse\r\n                                        )\r\n                                    }))\r\n                                } else if (stuff.type === 'strokeFill') {\r\n                                    this.setState(prevState => ({\r\n                                        ellipses: prevState.ellipses.map(\r\n                                            eachEllipse =>\r\n                                                eachEllipse.name === shapeName\r\n                                                    ? {\r\n                                                          ...eachEllipse,\r\n                                                          stroke: stuff.color\r\n                                                      }\r\n                                                    : eachEllipse\r\n                                        )\r\n                                    }))\r\n                                }\r\n                            }\r\n                            if (shapeName.includes('star')) {\r\n                                if (stuff.type === 'shapeFill') {\r\n                                    this.setState(prevState => ({\r\n                                        stars: prevState.stars.map(eachStar =>\r\n                                            eachStar.name === shapeName\r\n                                                ? {\r\n                                                      ...eachStar,\r\n                                                      fill: stuff.color\r\n                                                  }\r\n                                                : eachStar\r\n                                        )\r\n                                    }))\r\n                                } else if (stuff.type === 'strokeFill') {\r\n                                    this.setState(prevState => ({\r\n                                        stars: prevState.stars.map(eachStar =>\r\n                                            eachStar.name === shapeName\r\n                                                ? {\r\n                                                      ...eachStar,\r\n                                                      stroke: stuff.color\r\n                                                  }\r\n                                                : eachStar\r\n                                        )\r\n                                    }))\r\n                                }\r\n                            }\r\n                            if (shapeName.includes('text')) {\r\n                                this.setState(prevState => ({\r\n                                    texts: prevState.texts.map(eachText =>\r\n                                        eachText.name === shapeName\r\n                                            ? {\r\n                                                  ...eachText,\r\n                                                  fill: stuff.color\r\n                                              }\r\n                                            : eachText\r\n                                    )\r\n                                }))\r\n                            }\r\n                            if (shapeName.includes('arrow')) {\r\n                                if (stuff.type === 'shapeFill') {\r\n                                    this.setState(prevState => ({\r\n                                        arrows: prevState.arrows.map(eachStar =>\r\n                                            eachStar.name === shapeName\r\n                                                ? {\r\n                                                      ...eachStar,\r\n                                                      fill: stuff.color\r\n                                                  }\r\n                                                : eachStar\r\n                                        )\r\n                                    }))\r\n                                } else if (stuff.type === 'strokeFill') {\r\n                                    this.setState(prevState => ({\r\n                                        arrows: prevState.arrows.map(eachStar =>\r\n                                            eachStar.name === shapeName\r\n                                                ? {\r\n                                                      ...eachStar,\r\n                                                      stroke: stuff.color\r\n                                                  }\r\n                                                : eachStar\r\n                                        )\r\n                                    }))\r\n                                }\r\n                            }\r\n                        }}\r\n                        setObjectAttr={passed => {\r\n                            this.setState({ isPasteDisabled: false })\r\n                            let objectName = passed.target.name()\r\n                            if (objectName.includes('rect')) {\r\n                                if (\r\n                                    passed.attribute === 'link' &&\r\n                                    passed.value !== ''\r\n                                ) {\r\n                                    this.setState(prevState => ({\r\n                                        rectangles: prevState.rectangles.map(\r\n                                            eachRect =>\r\n                                                eachRect.name === objectName\r\n                                                    ? {\r\n                                                          ...eachRect,\r\n                                                          link: passed.value\r\n                                                      }\r\n                                                    : eachRect\r\n                                        )\r\n                                    }))\r\n                                }\r\n                            } else if (objectName.includes('ellipse')) {\r\n                                if (\r\n                                    passed.attribute === 'link' &&\r\n                                    passed.value !== ''\r\n                                ) {\r\n                                    this.setState(prevState => ({\r\n                                        ellipses: prevState.ellipses.map(\r\n                                            eachEllipse =>\r\n                                                eachEllipse.name === objectName\r\n                                                    ? {\r\n                                                          ...eachEllipse,\r\n                                                          link: passed.value\r\n                                                      }\r\n                                                    : eachEllipse\r\n                                        )\r\n                                    }))\r\n                                }\r\n                            } else if (objectName.includes('star')) {\r\n                                if (\r\n                                    passed.attribute === 'link' &&\r\n                                    passed.value !== ''\r\n                                ) {\r\n                                    this.setState(prevState => ({\r\n                                        stars: prevState.stars.map(eachStar =>\r\n                                            eachStar.name === objectName\r\n                                                ? {\r\n                                                      ...eachStar,\r\n                                                      link: passed.value\r\n                                                  }\r\n                                                : eachStar\r\n                                        )\r\n                                    }))\r\n                                }\r\n                            }\r\n                        }}\r\n                        setTextAttr={passed => {\r\n                            //may change\r\n                            console.log('paste abled....')\r\n                            this.setState({ isPasteDisabled: false })\r\n\r\n                            let text = passed.target\r\n\r\n                            if (\r\n                                passed.attribute === 'link' &&\r\n                                passed.value !== ''\r\n                            ) {\r\n                                this.setState(prevState => ({\r\n                                    texts: prevState.texts.map(eachText =>\r\n                                        eachText.name === text.name()\r\n                                            ? { ...eachText, fill: '#5ce1e6' }\r\n                                            : eachText\r\n                                    ),\r\n                                    isPasteDisabled: false\r\n                                }))\r\n                            }\r\n\r\n                            this.setState(prevState => ({\r\n                                texts: prevState.texts.map(eachText =>\r\n                                    eachText.name === text.name()\r\n                                        ? {\r\n                                              ...eachText,\r\n                                              [passed.attribute]: passed.value\r\n                                          }\r\n                                        : eachText\r\n                                )\r\n                            }))\r\n                        }}\r\n                    />\r\n                </div>\r\n            </React.Fragment>\r\n        )\r\n    }\r\n}\r\nconst mapStateToProps = state => ({\r\n    auth: state.auth\r\n})\r\n\r\nexport default connect(mapStateToProps)(withRouter(Graphics))\r\n"]},"metadata":{},"sourceType":"module"}