{"version":3,"file":"immer.umd.js","sources":["../src/patches.js","../src/common.js","../src/proxy.js","../src/es5.js","../src/immer.js"],"sourcesContent":["import {each} from \"./common\"\n\nexport function generatePatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    if (patches)\n        if (Array.isArray(baseValue))\n            generateArrayPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n        else\n            generateObjectPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n}\n\nexport function generateArrayPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    const shared = Math.min(baseValue.length, resultValue.length)\n    for (let i = 0; i < shared; i++) {\n        if (state.assigned[i] && baseValue[i] !== resultValue[i]) {\n            const path = basepath.concat(i)\n            patches.push({op: \"replace\", path, value: resultValue[i]})\n            inversePatches.push({op: \"replace\", path, value: baseValue[i]})\n        }\n    }\n    if (shared < resultValue.length) {\n        // stuff was added\n        for (let i = shared; i < resultValue.length; i++) {\n            const path = basepath.concat(i)\n            patches.push({op: \"add\", path, value: resultValue[i]})\n        }\n        inversePatches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: baseValue.length\n        })\n    } else if (shared < baseValue.length) {\n        // stuff was removed\n        patches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: resultValue.length\n        })\n        for (let i = shared; i < baseValue.length; i++) {\n            const path = basepath.concat(i)\n            inversePatches.push({op: \"add\", path, value: baseValue[i]})\n        }\n    }\n}\n\nfunction generateObjectPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    each(state.assigned, (key, assignedValue) => {\n        const origValue = baseValue[key]\n        const value = resultValue[key]\n        const op = !assignedValue\n            ? \"remove\"\n            : key in baseValue ? \"replace\" : \"add\"\n        if (origValue === baseValue && op === \"replace\") return\n        const path = basepath.concat(key)\n        patches.push(op === \"remove\" ? {op, path} : {op, path, value})\n        inversePatches.push(\n            op === \"add\"\n                ? {op: \"remove\", path}\n                : op === \"remove\"\n                  ? {op: \"add\", path, value: origValue}\n                  : {op: \"replace\", path, value: origValue}\n        )\n    })\n}\n\nexport function applyPatches(draft, patches) {\n    for (let i = 0; i < patches.length; i++) {\n        const patch = patches[i]\n        if (patch.path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value\n        } else {\n            const path = patch.path.slice()\n            const key = path.pop()\n            const base = path.reduce((current, part) => {\n                if (!current)\n                    throw new Error(\n                        \"Cannot apply patch, path doesn't resolve: \" +\n                            patch.path.join(\"/\")\n                    )\n                return current[part]\n            }, draft)\n            if (!base)\n                throw new Error(\n                    \"Cannot apply patch, path doesn't resolve: \" +\n                        patch.path.join(\"/\")\n                )\n            switch (patch.op) {\n                case \"replace\":\n                case \"add\":\n                    // TODO: add support is not extensive, it does not support insertion or `-` atm!\n                    base[key] = patch.value\n                    break\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        if (key === base.length - 1) base.length -= 1\n                        else\n                            throw new Error(\n                                `Remove can only remove the last key of an array, index: ${key}, length: ${\n                                    base.length\n                                }`\n                            )\n                    } else delete base[key]\n                    break\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op)\n            }\n        }\n    }\n    return draft\n}\n","import {generatePatches} from \"./patches\"\n\nexport const NOTHING =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-nothing\")\n        : {[\"immer-nothing\"]: true}\n\nexport const PROXY_STATE =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-proxy-state\")\n        : \"__$immer_state\"\n\nexport const RETURNED_AND_MODIFIED_ERROR =\n    \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n\nfunction verifyMinified() {}\n\nconst inProduction =\n    (typeof process !== \"undefined\" && process.env.NODE_ENV === \"production\") ||\n    verifyMinified.name !== \"verifyMinified\"\n\nlet autoFreeze = !inProduction\nlet useProxies = typeof Proxy !== \"undefined\"\n\n/**\n * Automatically freezes any state trees generated by immer.\n * This protects against accidental modifications of the state tree outside of an immer function.\n * This comes with a performance impact, so it is recommended to disable this option in production.\n * It is by default enabled.\n *\n * @returns {void}\n */\nexport function setAutoFreeze(enableAutoFreeze) {\n    autoFreeze = enableAutoFreeze\n}\n\nexport function setUseProxies(value) {\n    useProxies = value\n}\n\nexport function getUseProxies() {\n    return useProxies\n}\n\nexport function isProxy(value) {\n    return !!value && !!value[PROXY_STATE]\n}\n\nexport function isProxyable(value) {\n    if (!value) return false\n    if (typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    return proto === null || proto === Object.prototype\n}\n\nexport function freeze(value) {\n    if (autoFreeze) {\n        Object.freeze(value)\n    }\n    return value\n}\n\nexport function original(value) {\n    if (value && value[PROXY_STATE]) {\n        return value[PROXY_STATE].base\n    }\n    // otherwise return undefined\n}\n\nconst assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport function shallowCopy(value) {\n    if (Array.isArray(value)) return value.slice()\n    const target = value.__proto__ === undefined ? Object.create(null) : {}\n    return assign(target, value)\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i])\n    } else {\n        for (let key in value) cb(key, value[key])\n    }\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n// given a base object, returns it if unmodified, or return the changed cloned if modified\nexport function finalize(base, path, patches, inversePatches) {\n    if (isProxy(base)) {\n        const state = base[PROXY_STATE]\n        if (state.modified === true) {\n            if (state.finalized === true) return state.copy\n            state.finalized = true\n            const result = finalizeObject(\n                useProxies ? state.copy : (state.copy = shallowCopy(base)),\n                state,\n                path,\n                patches,\n                inversePatches\n            )\n            generatePatches(\n                state,\n                path,\n                patches,\n                inversePatches,\n                state.base,\n                result\n            )\n            return result\n        } else {\n            return state.base\n        }\n    }\n    finalizeNonProxiedObject(base)\n    return base\n}\n\nfunction finalizeObject(copy, state, path, patches, inversePatches) {\n    const base = state.base\n    each(copy, (prop, value) => {\n        if (value !== base[prop]) {\n            // if there was an assignment on this property, we don't need to generate\n            // patches for the subtree\n            const generatePatches = patches && !has(state.assigned, prop)\n            copy[prop] = finalize(\n                value,\n                generatePatches && path.concat(prop),\n                generatePatches && patches,\n                inversePatches\n            )\n        }\n    })\n    return freeze(copy)\n}\n\nfunction finalizeNonProxiedObject(parent) {\n    // If finalize is called on an object that was not a proxy, it means that it is an object that was not there in the original\n    // tree and it could contain proxies at arbitrarily places. Let's find and finalize them as well\n    if (!isProxyable(parent)) return\n    if (Object.isFrozen(parent)) return\n    each(parent, (i, child) => {\n        if (isProxy(child)) {\n            parent[i] = finalize(child)\n        } else finalizeNonProxiedObject(child)\n    })\n    // always freeze completely new data\n    freeze(parent)\n}\n\nexport function verifyReturnValue(returnedValue, proxy, isProxyModified) {\n    if (returnedValue !== undefined && returnedValue !== proxy) {\n        // something was returned, and it wasn't the proxy itself\n        if (isProxyModified)\n            throw new Error(\n                \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n            )\n    }\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    has,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    finalize,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each\n} from \"./common\"\n\nlet proxies = null\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty,\n    setPrototypeOf() {\n        throw new Error(\"Immer does not support `setPrototypeOf()`.\")\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support deleting properties from arrays: \" + prop\n        )\n    return objectTraps.deleteProperty.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop)))\n        throw new Error(\n            \"Immer does not support setting non-numeric properties on arrays: \" +\n                prop\n        )\n    return objectTraps.set.call(this, state[0], prop, value)\n}\n\nfunction createState(parent, base) {\n    return {\n        modified: false, // this tree is modified (either this object or one of it's children)\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        finalized: false,\n        parent,\n        base,\n        copy: undefined,\n        proxies: {}\n    }\n}\n\nfunction source(state) {\n    return state.modified === true ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    if (prop === PROXY_STATE) return state\n    if (state.modified) {\n        const value = state.copy[prop]\n        if (value === state.base[prop] && isProxyable(value))\n            // only create proxy if it is not yet a proxy, and not a new object\n            // (new objects don't need proxying, they will be processed in finalize anyway)\n            return (state.copy[prop] = createProxy(state, value))\n        return value\n    } else {\n        if (has(state.proxies, prop)) return state.proxies[prop]\n        const value = state.base[prop]\n        if (!isProxy(value) && isProxyable(value))\n            return (state.proxies[prop] = createProxy(state, value))\n        return value\n    }\n}\n\nfunction set(state, prop, value) {\n    // TODO: optimize\n    state.assigned[prop] = true\n    if (!state.modified) {\n        if (\n            (prop in state.base && is(state.base[prop], value)) ||\n            (has(state.proxies, prop) && state.proxies[prop] === value)\n        )\n            return true\n        markChanged(state)\n    }\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    state.assigned[prop] = false\n    markChanged(state)\n    delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = state.modified\n        ? state.copy\n        : has(state.proxies, prop) ? state.proxies : state.base\n    const descriptor = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (descriptor && !(Array.isArray(owner) && prop === \"length\"))\n        descriptor.configurable = true\n    return descriptor\n}\n\nfunction defineProperty() {\n    throw new Error(\n        \"Immer does not support defining properties on draft objects.\"\n    )\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = shallowCopy(state.base)\n        // copy the proxies over the base-copy\n        Object.assign(state.copy, state.proxies) // yup that works for arrays as well\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parentState, base, key) {\n    if (isProxy(base)) throw new Error(\"Immer bug. Plz report.\")\n    const state = createState(parentState, base, key)\n    const proxy = Array.isArray(base)\n        ? Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n    proxies.push(proxy)\n    return proxy.proxy\n}\n\nexport function produceProxy(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const previousProxies = proxies\n    proxies = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n\n            // See #117\n            // Should we just throw when returning a proxy which is not the root, but a subset of the original state?\n            // Looks like a wrongly modeled reducer\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // revoke all proxies\n        each(proxies, (_, p) => p.revoke())\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        proxies = previousProxies\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each,\n    finalize\n} from \"./common\"\n\nconst descriptors = {}\nlet states = null\n\nfunction createState(parent, proxy, base) {\n    return {\n        modified: false,\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        hasCopy: false,\n        parent,\n        base,\n        proxy,\n        copy: undefined,\n        finished: false,\n        finalizing: false,\n        finalized: false\n    }\n}\n\nfunction source(state) {\n    return state.hasCopy ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    assertUnfinished(state)\n    const value = source(state)[prop]\n    if (!state.finalizing && value === state.base[prop] && isProxyable(value)) {\n        // only create a proxy if the value is proxyable, and the value was in the base state\n        // if it wasn't in the base state, the object is already modified and we will process it in finalize\n        prepareCopy(state)\n        return (state.copy[prop] = createProxy(state, value))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnfinished(state)\n    state.assigned[prop] = true // optimization; skip this if there is no listener\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (state.hasCopy) return\n    state.hasCopy = true\n    state.copy = shallowCopy(state.base)\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parent, base) {\n    const proxy = shallowCopy(base)\n    each(base, i => {\n        Object.defineProperty(proxy, \"\" + i, createPropertyProxy(\"\" + i))\n    })\n    const state = createState(parent, proxy, base)\n    createHiddenProperty(proxy, PROXY_STATE, state)\n    states.push(state)\n    return proxy\n}\n\nfunction createPropertyProxy(prop) {\n    return (\n        descriptors[prop] ||\n        (descriptors[prop] = {\n            configurable: true,\n            enumerable: true,\n            get() {\n                return get(this[PROXY_STATE], prop)\n            },\n            set(value) {\n                set(this[PROXY_STATE], prop, value)\n            }\n        })\n    )\n}\n\nfunction assertUnfinished(state) {\n    if (state.finished === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(state.copy || state.base)\n        )\n}\n\n// this sounds very expensive, but actually it is not that expensive in practice\n// as it will only visit proxies, and only do key-based change detection for objects for\n// which it is not already know that they are changed (that is, only object for which no known key was changed)\nfunction markChangesSweep() {\n    // intentionally we process the proxies in reverse order;\n    // ideally we start by processing leafs in the tree, because if a child has changed, we don't have to check the parent anymore\n    // reverse order of proxy creation approximates this\n    for (let i = states.length - 1; i >= 0; i--) {\n        const state = states[i]\n        if (state.modified === false) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return\n    const state = object[PROXY_STATE]\n    if (!state) return\n    const {proxy, base} = state\n    if (Array.isArray(object)) {\n        if (hasArrayChanges(state)) {\n            markChanged(state)\n            state.assigned.length = true\n            if (proxy.length < base.length)\n                for (let i = proxy.length; i < base.length; i++)\n                    state.assigned[i] = false\n            else\n                for (let i = base.length; i < proxy.length; i++)\n                    state.assigned[i] = true\n            each(proxy, (index, child) => {\n                if (!state.assigned[index]) markChangesRecursively(child)\n            })\n        }\n    } else {\n        const {added, removed} = diffKeys(base, proxy)\n        if (added.length > 0 || removed.length > 0) markChanged(state)\n        each(added, (_, key) => {\n            state.assigned[key] = true\n        })\n        each(removed, (_, key) => {\n            state.assigned[key] = false\n        })\n        each(proxy, (key, child) => {\n            if (!state.assigned[key]) markChangesRecursively(child)\n        })\n    }\n}\n\nfunction diffKeys(from, to) {\n    // TODO: optimize\n    const a = Object.keys(from)\n    const b = Object.keys(to)\n    return {\n        added: b.filter(key => a.indexOf(key) === -1),\n        removed: a.filter(key => b.indexOf(key) === -1)\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const baseKeys = Object.keys(state.base)\n    const keys = Object.keys(state.proxy)\n    return !shallowEqual(baseKeys, keys)\n}\n\nfunction hasArrayChanges(state) {\n    const {proxy} = state\n    if (proxy.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(proxy, proxy.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nexport function produceEs5(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const prevStates = states\n    states = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        each(states, (_, state) => {\n            state.finalizing = true\n        })\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            if (patchListener) markChangesRecursively(rootProxy)\n            markChangesSweep() // this one is more efficient if we don't need to know which attributes have changed\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // make sure all proxies become unusable\n        each(states, (_, state) => {\n            state.finished = true\n        })\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        states = prevStates\n    }\n}\n\nfunction shallowEqual(objA, objB) {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) return true\n    if (\n        typeof objA !== \"object\" ||\n        objA === null ||\n        typeof objB !== \"object\" ||\n        objB === null\n    ) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) return false\n    for (let i = 0; i < keysA.length; i++) {\n        if (\n            !hasOwnProperty.call(objB, keysA[i]) ||\n            !is(objA[keysA[i]], objB[keysA[i]])\n        ) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","export {setAutoFreeze, setUseProxies, original} from \"./common\"\n\nimport {applyPatches as applyPatchesImpl} from \"./patches\"\nimport {isProxyable, getUseProxies, NOTHING} from \"./common\"\nimport {produceProxy} from \"./proxy\"\nimport {produceEs5} from \"./es5\"\n\n/**\n * produce takes a state, and runs a function against it.\n * That function can freely mutate the state, as it will create copies-on-write.\n * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned\n *\n * @export\n * @param {any} baseState - the state to start with\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the base state if nothing was modified\n */\nexport function produce(baseState, producer, patchListener) {\n    // prettier-ignore\n    if (arguments.length < 1 || arguments.length > 3) throw new Error(\"produce expects 1 to 3 arguments, got \" + arguments.length)\n\n    // curried invocation\n    if (typeof baseState === \"function\") {\n        // prettier-ignore\n        if (typeof producer === \"function\") throw new Error(\"if first argument is a function (curried invocation), the second argument to produce cannot be a function\")\n\n        const initialState = producer\n        const recipe = baseState\n\n        return function() {\n            const args = arguments\n\n            const currentState =\n                args[0] === undefined && initialState !== undefined\n                    ? initialState\n                    : args[0]\n\n            return produce(currentState, draft => {\n                args[0] = draft // blegh!\n                return recipe.apply(draft, args)\n            })\n        }\n    }\n\n    // prettier-ignore\n    {\n        if (typeof producer !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\")\n        if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\")\n    }\n\n    // if state is a primitive, don't bother proxying at all\n    if (typeof baseState !== \"object\" || baseState === null) {\n        const returnValue = producer(baseState)\n        return returnValue === undefined\n            ? baseState\n            : normalizeResult(returnValue)\n    }\n\n    if (!isProxyable(baseState))\n        throw new Error(\n            `the first argument to an immer producer should be a primitive, plain object or array, got ${typeof baseState}: \"${baseState}\"`\n        )\n    return normalizeResult(\n        getUseProxies()\n            ? produceProxy(baseState, producer, patchListener)\n            : produceEs5(baseState, producer, patchListener)\n    )\n}\n\nfunction normalizeResult(result) {\n    return result === NOTHING ? undefined : result\n}\n\nexport default produce\n\nexport const applyPatches = produce(applyPatchesImpl)\n\nexport const nothing = NOTHING\n"],"names":["generatePatches","state","basepath","patches","inversePatches","baseValue","resultValue","Array","isArray","shared","Math","min","length","i","assigned","path","concat","push","op","value","generateArrayPatches","key","assignedValue","origValue","NOTHING","Symbol","PROXY_STATE","RETURNED_AND_MODIFIED_ERROR","autoFreeze","process","env","NODE_ENV","name","useProxies","Proxy","isProxy","isProxyable","proto","Object","getPrototypeOf","prototype","freeze","assign","target","has","shallowCopy","slice","undefined","__proto__","create","each","cb","thing","prop","hasOwnProperty","call","finalize","base","modified","finalized","copy","result","finalizeNonProxiedObject","parent","isFrozen","child","is","x","y","proxies","objectTraps","createProxy","source","Reflect","ownKeys","owner","descriptor","getOwnPropertyDescriptor","configurable","Error","arrayTraps","markChanged","parentState","proxy","revocable","fn","arguments","apply","this","deleteProperty","isNaN","parseInt","set","descriptors","states","hasCopy","prepareCopy","defineProperty","finalizing","get","assertUnfinished","finished","JSON","stringify","markChangesRecursively","object","from","to","a","b","hasArrayChanges","index","keys","filter","indexOf","added","removed","_","produceEs5","baseState","producer","patchListener","returnValue","prevStates","rootProxy","baseKeys","objA","objB","keysA","keysB","shallowEqual","produce","initialState","recipe","args","draft","normalizeResult","previousProxies","p","revoke","produceProxy","applyPatches","patch","pop","reduce","current","part","join","nothing","enableAutoFreeze"],"mappings":"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"}